{"pages":[],"posts":[{"title":"NPM和Yarn添加淘宝镜像","text":"添加淘宝镜像 NPM设置淘宝镜像1.查询当前配置的镜像 12npm get registry &gt; https://registry.npmjs.org/ 设置成淘宝镜像 npm config set registry http://registry.npm.taobao.org/ 2.恢复默认 npm config set registry https://registry.npmjs.org/ Yarn 设置淘宝镜像1.查询当前配置的镜像 12yarn config get registry&gt; https://registry.yarnpkg.com 设置成淘宝镜像 yarn config set registry http://registry.npm.taobao.org/","link":"/2020/02/27/NPM%E5%92%8CYarn%E6%B7%BB%E5%8A%A0%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F/"},{"title":"es6语法","text":"ES6 各种新语法 入门了解 hello-es6ES6 各种新语法 入门了解 石川blue讲解 视频地址 b站：深入解读ES6系列 看视频整理要点笔记: hello-es6 1.ES6怎么来的 2.ES6兼容性 3.变量 let 和 常量 const 4.函数-箭头函数 5.函数-参数 6.解构赋值 7.数组 8.字符串 9.面向对象-基础 10.面向对象应用 11.json 12.Promise 13.generator-认识生成器函数 14.generator-yield是啥 15.generator-实例 16.ES7 预览 1.ES6怎么来的 ECMAScript 和 JavaScript ECMA 是标准，JS 是实现 ECMAScript 简称 ECMA 或 ES 历史版本 1996, ES1.0 Netscape 将 JS 提交给 ECMA 组织，ES 正式出现 1999, ES3.0 被广泛支持 2011, ES5.1 成为 ISO 国际标准 2015, ES6.0 正式发布 2.ES6兼容性 ES6(ES2015) 支持的环境 IE10+, Chrome, FireFox, 移动端, NodeJS 解决不兼容办法，编译、转换 在线转换 或者提前编译 Babel 中文网 Babel 入门教程 阮一峰 Babel 是一个 JavaScript 编译器 一个广泛使用的转码器，可以将ES6代码转为ES5代码，从而在现有环境执行 现在就用 ES6 编写程序，而不用担心现有环境是否支持 3.变量 let 和 常量 const var 的问题 可以重复声明，没有报错和警告 无法限制修改 没有块级作用域， { } let 和 const 不能重复声明 都是块级作用域, { } 块内声明的，块外无效 let 是变量，可以修改 const 是常量，不能修改 块级作用域举例 原来用 var 的方式，结果弹出的都是 3 或者将变量 封装到函数里，限制作用域，但比较麻烦 用 let 最简单，直接 var 改 let，解决作用域问题 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; window.onload= function () { /* var aBtn = document.getElementsByTagName('input') for (var i=0; i &lt; aBtn.length; i++) { aBtn[i].onclick = function () { alert(i) } }*/ var aBtn = document.getElementsByTagName('input') for (let i = 0; i &lt; aBtn.length; i++) { aBtn[i].onclick = function () { alert(i) } } /* var aBtn = document.getElementsByTagName('input') for (var i = 0; i &lt; aBtn.length; i++) { // 封装到函数里，限制作用域 (function (i) { aBtn[i].onclick = function () { alert(i) } })(i) }*/ } &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"按钮1\"&gt; &lt;input type=\"button\" value=\"按钮2\"&gt; &lt;input type=\"button\" value=\"按钮3\"&gt;&lt;/body&gt;&lt;/html&gt; 4.函数-箭头函数 箭头函数，就是函数的简写 如果只有一个参数，() 可以省 如果只有一个return，{}可以省 12345678// 普通函数function name() {}// 箭头函数，去掉 function， 加上 =&gt;() =&gt; {} 12345678910111213141516171819let show1 = function () { console.log('abc')}let show2 = () =&gt; { console.log('abc')}show1() // 调用函数show2()let show4 = function (a) { return a*2}let show5 = a =&gt; a * 2 //简洁，类似python lambda 函数console.log(show4(10))console.log(show5(10)) 5.函数-参数 参数扩展／展开 ...args 收集剩余的参数，必须当到最后一个参数位置 展开数组，简写，效果和直接把数组的内容写在这儿一样 默认参数 12345678910111213141516function show(a, b, ...args) { console.log(a) console.log(b) console.log(args)}console.log(show(1, 2, 3, 4, 5))let arr1 = [1, 2, 3]let arr2 = [4, 5, 6]let arr3 = [...arr1, ...arr2]console.log(arr3)function show2(a, b=5, c=8) { console.log(a, b, c)}show2(88, 12) 6.解构赋值12345678let [a, b, c] = [1, 2, 3]console.log(a, b, c)let {x, y, z} = {x: 1, y: 2, z: 3}console.log(x, y, z)let [json, arr, num, str] = [{ a: 1, b: 2 }, [1, 2, 3], 8, 'str']console.log(json, arr, num, str) 解构赋值 左右两个边结构必须一样 右边必须是个东西 声明和赋值赋值不能分开，必须在一句话里 7.数组 新增4个方法 map 映射 一个对一个 12345678910111213141516let arr = [12, 5, 8]let result = arr.map(function (item) { return item*2})let result2 = arr.map(item=&gt;item*2) // 简写console.log(result)console.log(result2)let score = [18, 86, 88, 24]let result3 = score.map(item =&gt; item &gt;= 60 ? '及格' : '不及格')console.log(result3)// 结果[ 24, 10, 16 ][ 24, 10, 16 ][ '不及格', '及格', '及格', '不及格' ] reduce 汇总 一堆出来一个 用于比如，算个总数，算个平均 1234567891011121314151617var arr = [1, 3, 5, 7]var result = arr.reduce(function (tmp, item, index) { //tmp 上次结果，item当前数，index次数1开始 console.log(tmp, item, index) return tmp + item})console.log(result)var arr = [1, 3, 5, 7]var result = arr.reduce(function (tmp, item, index) { if (index != arr.length - 1) { // 不是最后一次 return tmp + item } else { return (tmp + item)/arr.length }})console.log(result) // 平均值 filter 过滤器 保留为true的 123456789101112var arr = [12, 4, 8, 9]var result = arr.filter(item =&gt; (item % 3 === 0) ? true : false)console.log(result)var result = arr.filter(item =&gt; item % 3 === 0)console.log(result)var arr = [ { title: '苹果', price: 10 }, { title: '西瓜', price: 20 },]var result = arr.filter(json =&gt; json.price &gt;= 20)console.log(result) forEach 循环迭代 123var arr = [12, 4, 8, 9]var result = arr.forEach(item =&gt; console.log(item))var result = arr.forEach((item, index)=&gt;console.log(item, index)) 8.字符串 多了两个新方法 startsWith endsWith 1234var url = 'http://qq.com'console.log(url.startsWith('http'))console.log(url.endsWith('com'))// 都是 true 字符串模版 使用反引号，${变量} 可以折行 1234567891011121314let a = 12let str1 = `asdf${a}`console.log(str1)let title = '标题'let content = '内容'let str = `&lt;div&gt;&lt;h1&gt;${title}&lt;/h1&gt;&lt;p&gt;${content}&lt;/p&gt;`console.log(str)&lt;div&gt;&lt;h1&gt;标题&lt;/h1&gt;&lt;p&gt;内容&lt;/p&gt; 9.面向对象-基础 原来写法 类和构造函数一样 属性和方法分开写的 123456789101112131415161718192021222324252627282930// 老版本function User(name, pass) { this.name = name this.pass = pass}User.prototype.showName = function () { console.log(this.name)}User.prototype.showPass = function () { console.log(this.pass)}var u1 = new User('able', '1233')u1.showName()u1.showPass()// 老版本继承function VipUser(name, pass, level) { User.call(this, name, pass) this.level = level}VipUser.prototype = new User()VipUser.prototype.constructor = VipUserVipUser.prototype.showLevel = function () { console.log(this.level)}var v1 = new VipUser('blue', '1234', 3)v1.showName()v1.showLevel() 新版面向对象 有了 class 关键字、构造器 class 里面直接加方法 继承，super 超类==父类 12345678910111213141516171819202122232425262728293031class User { constructor(name, pass) { this.name = name this.pass = pass } showName() { console.log(this.name) } showPass() { console.log(this.pass) }}var u1 = new User('able2', '111')u1.showName()u1.showPass()// 新版本继承class VipUser extends User { constructor(name, pass, level) { super(name, pass) this.level = level } showLevel(){ console.log(this.level) }}v1 = new VipUser('blue', '123', 3)v1.showLevel() 10.面向对象应用 React 用于构建用户界面的 JavaScript 库 组件化，一个组件就是一个 class JSX == bable == browser.js 11.json JSON 格式 JavaScript Object Notation 的缩写，是一种用于数据交换的文本格式 JSON 是 JS对象 的严格子集 JSON 的标准写法 只能用双引号 所有的key都必须用双引号包起来 JSON 对象 JSON 对象是 JavaScript 的原生对象，用来处理 JSON 格式数据，有两个静态方法 JSON.parse(string) ：接受一个 JSON 字符串并将其转换成一个 JavaScript 对象。 JSON.stringify(obj) ：接受一个 JavaScript 对象并将其转换为一个 JSON 字符串。 123456789101112var json = {a: 12, b: 5}var str = 'hi,' + JSON.stringify(json)var url = 'http://www.xx.com/' + encodeURIComponent(JSON.stringify(json))console.log(str)console.log(url)var str = '{\"a\": 12, \"b\": 4, \"c\": \"abc\"}'var json = JSON.parse(str)console.log(json)hi,{\"a\":12,\"b\":5}http://www.xx.com/%7B%22a%22%3A12%2C%22b%22%3A5%7D{ a: 12, b: 4, c: 'abc' } 对象（object） 是 JavaScript 语言的核心概念，也是最重要的数据类型 对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合 对象的所有键名都是字符串, 所以加不加引号都可以 如果键名是数值，会被自动转为字符串 对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型 如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用 in 运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值 for…in循环用来遍历一个对象的全部属性 对象 简写 key-value 一样时可以简写 里面函数可以简写, 去掉 123456789var a = 12, b = 5console.log({a:a, b:b})console.log({a, b})console.log({a, b, c:\"c\"})console.log({ a, b, show(){ console.log('a') }}){ a: 12, b: 5 }{ a: 12, b: 5 }{ a: 12, b: 5, c: 'c' }{ a: 12, b: 5, show: [Function: show] } 12.Promise 异步和同步 异步，操作之间没有关系，同时执行多个操作， 代码复杂 同步，同时只能做一件事，代码简单 Promise 对象 用同步的方式来书写异步代码 Promise 让异步操作写起来，像在写同步操作的流程，不必一层层地嵌套回调函数 改善了可读性，对于多层嵌套的回调函数很方便 充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口 Promise 也是一个构造函数 接受一个回调函数f1作为参数，f1里面是异步操作的代码 返回的p1就是一个 Promise 实例 所有异步任务都返回一个 Promise 实例 Promise 实例有一个then方法，用来指定下一步的回调函数 12345function f1(resolve, reject) { // 异步代码...}var p1 = new Promise(f1);p1.then(f2); // f1的异步操作执行完成，就会执行f2。 Promise 使得异步流程可以写成同步流程 12345678910111213141516// 传统写法step1(function (value1) { step2(value1, function(value2) { step3(value2, function(value3) { step4(value3, function(value4) { // ... }); }); });});// Promise 的写法(new Promise(step1)) .then(step2) .then(step3) .then(step4); Promise.all(promiseArray)方法 将多个Promise对象实例包装，生成并返回一个新的Promise实例 promise数组中所有的promise实例都变为resolve的时候，该方法才会返回 并将所有结果传递results数组中 promise数组中任何一个promise为reject的话，则整个Promise.all调用会立即终止，并返回一个reject的新的promise对象 123456var p1 = Promise.resolve(1), p2 = Promise.resolve(2), p3 = Promise.resolve(3);Promise.all([p1, p2, p3]).then(function (results) { console.log(results); // [1, 2, 3]}); Promise.race([p1, p2, p3]) Promse.race就是赛跑的意思 哪个结果获得的快，就返回那个结果 不管结果本身是成功状态还是失败状态 13.generator-认识生成器函数 generator 生成器函数 普通函数，一路到底 generator函数，中间可以停，到哪停呢，用 yield 配合，交出执行权 yield 有 放弃、退让、退位的意思 需要调用next()方法启动执行，需要遇到 yield 停, 踹一脚走一步 generator函数前面加一个 * 两边可以有空格，或靠近函数或function 背后实际生成多个小函数，实现走走停停 123456789101112131415function show() { console.log('a') console.log('b')}show() // 普通函数function *show2() { console.log('1') yield console.log('2')}let genObj = show2()genObj.next() // 1genObj.next() // 2genObj.next() // 最后了，没有结果 14.generator-yield是啥 yield 既可传参，又可以返回 第一个next()传参无效，只用来启动 如果函数前漏掉 * 就是普通函数 如果有yield会报错， ReferenceError: yield is not defined yield 只能在Generator函数内部使用 1234567891011121314151617181920212223242526function * show() { console.log('1') var a = yield console.log('2') console.log(a)}// yield 传参var gen = show()gen.next() // 1gen.next() // 2 和 undefined 因为没有传参，yield没有返回值var gen = show()gen.next(10) // 1 第一次执行到yield，但没有执行赋值gen.next(20) // 2 和 20function* show2() { console.log('1') yield 10 console.log('2')}// yield 返回var gen = show2()var res1 = gen.next()console.log(res1) // { value: 10, done: false }var res2 = gen.next()console.log(res2)// { value: undefined, done: true } 最后的value需要return返回 15.generator-实例 Promise 适合一次读一组 generator 适合逻辑性的 12345678910// 带逻辑-generatorrunner(function * () { let userData = yield $.ajax({url: 'getUserData'}) if (userData.type == 'VIP') { let items = yield $.ajax({url: 'getVIPItems'}) } else { let items = yield $.ajax({url: 'getItems'}) }}) 12345// yield 实例，用同步方式写异步server.use(function * () { let data = yield db.query(`select * from user_table`) this.body = data}) 16.ES7 预览 数组 arr.includes() 数组是否包含某个东西 数组的 arr.keys(), arr,entries() for … in 遍历数组 下标 key for … of 遍历数组 值 value, 不能用于json 123456789101112131415161718192021let arr = ['a', 'b', 'c']console.log(arr.includes(1))for (let i in arr) { console.log(i) // 循环的时下标 key}for (let i of arr) { console.log(i) // 循环的是值 value}for (let i of arr.keys()) { console.log('&gt;'+i)}for (let [key, value] of arr.entries()) { console.log('&gt;' + key + value)}let json = { a: 12, b: 5, c: 7 }for (let i in json) { console.log(i)} 字符串 padStart()/padEnd() 指定宽度，不够就补空格或指定字符 1234console.log('=' + 'abcd'.padStart(6, '0') + '=')console.log('=' + 'abcd'.padEnd(6, '0') + '=')=00abcd==abcd00= 容忍度 [1, 2, 3,] 老版数组最后不能有逗号，新的可以有 函数参数最后多的逗号也可以 async await 和 generator yield 类似 generator 不可以写成箭头函数， async 可以 12345async function show() { console.log(1) await console.log(2)}","link":"/2020/02/26/es6%E8%AF%AD%E6%B3%95/"},{"title":"【前端面试】经典面试题基础","text":"javascript基础面试题 说说写JavaScript的基本规范？ 不要在同一行声明多个变量使用 ===或!==来比较true/false或者数值switch必须带有default分支函数应该有返回值语句结束加分号命名要有意义，使用驼峰命名法 javascript的typeof返回哪些数据类型. string,boolean,number,undefined,function,object,es6新增symbol 栈和堆的区别？ 栈（stack）：由编译器自动分配释放，存放函数的参数值，局部变量等；堆（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统释放。 null，undefined的区别？ null表示一个对象被定义了，但存放了空指针，转换为数值时为0。undefined表示声明的变量未初始化，转换为数值时为NAN。typeof(null) – object;typeof(undefined) – undefined split() join() 的区别 前者是将字符串切割成数组的形式，后者是将数组转换成字符串 [“1”, “2”, “3”].map(parseInt) 答案是多少？ 答案：[1,NaN,NaN] 是不是很奇怪, 1 为什么能被转换成1 其他2 ，3 会被转换成NAN12345678解析： Array.prototype.map() array.map(callback[, thisArg]) callback函数的执行规则 参数：自动传入三个参数 currentValue（当前被传递的元素）； index（当前被传递的元素的索引）； array（调用map方法的数组） javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？ 除了正常模式运行外，ECMAscript添加了第二种运行模式：“严格模式”。作用： 1) 消除js不合理，不严谨地方，减少怪异行为2) 消除代码运行的不安全之处，3) 提高编译器的效率，增加运行速度4) 为未来的js新版本做铺垫。 如何判断一个对象是否属于某个类？ 使用instanceof 即if(a instanceof Person){alert(‘yes’);} new操作符具体干了什么呢? 1) 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。2) 属性和方法被加入到 this 引用的对象中。3) 新创建的对象由 this 所引用，并且最后隐式的返回 this 。","link":"/2019/03/12/js%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"【前端面试】经典面试题基础","text":"javascript基础面试题2 什么闭包,闭包有什么用闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量。闭包作用域链通常包括三个部分： 函数本身作用域。 闭包定义时的作用域。 全局作用域。 闭包常见用途： 创建特权方法用于访问控制 事件处理程序及回调 javascript 有哪些方法定义对象 对象字面量： var obj = {}; 构造函数： var obj = new Object(); Object.create(): var obj = Object.create(Object.prototype); 对象到字符串的转换步骤 如果对象有 toString()方法，javascript 调用它。如果返回一个原始值（primitive value 如：string number boolean）,将这个值转换为字符串作为结果 如果对象没有 toString()方法或者返回值不是原始值，javascript 寻找对象的 valueOf()方法，如果存在就调用它，返回结果是原始值则转为字符串作为结果 否则，javascript 不能从 toString()或者 valueOf()获得一个原始值，此时 throws a TypeError 对象到数字的转换步骤 如果对象有valueOf()方法并且返回元素值，javascript将返回值转换为数字作为结果 否则，如果对象有toString()并且返回原始值，javascript将返回结果转换为数字作为结果 否则，throws a TypeError &lt;,&gt;,&lt;=,&gt;=的比较规则所有比较运算符都支持任意类型，但是比较只支持数字和字符串，所以需要执行必要的转换然后进行比较，转换规则如下: 如果操作数是对象，转换为原始值：如果 valueOf 方法返回原始值，则使用这个值，否则使用 toString 方法的结果，如果转换失败则报错 经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的 16 位 unicode 值的大小） 否则，如果有一个操作数不是字符串，将两个操作数转换为数字进行比较 +运算符工作流程 如果有操作数是对象，转换为原始值 此时如果有一个操作数是字符串，其他的操作数都转换为字符串并执行连接 否则：所有操作数都转换为数字并执行加法 客户端存储 localStorage 和 sessionStorage localStorage 有效期为永久，sessionStorage 有效期为顶层窗口关闭前 同源文档可以读取并修改 localStorage 数据，sessionStorage 只允许同一个窗口下的文档访问，如通过 iframe 引入的同源文档。 Storage 对象通常被当做普通 javascript 对象使用：通过设置属性来存取字符串值，也可以通过setItem(key, value)设置，getItem(key)读取，removeItem(key)删除，clear()删除所有数据，length 表示已存储的数据项数目，key(index)返回对应索引的 key 1234567891011localStorage.setItem('x', 1); // storge x-&gt;1localStorage.getItem('x); // return value of x// 枚举所有存储的键值对for (var i = 0, len = localStorage.length; i &lt; len; ++i ) { var name = localStorage.key(i); var value = localStorage.getItem(name);}localStorage.removeItem('x'); // remove xlocalStorage.clear(); // remove all data sessionStorage,localStorage,cookie 区别 都会在浏览器端保存，有大小限制，同源限制 cookie 会在请求时发送到服务器，作为会话标识，服务器可修改 cookie；web storage 不会发送到服务器 cookie 有 path 概念，子路径可以访问父路径 cookie，父路径不能访问子路径 cookie 有效期：cookie 在设置的有效期内有效，默认为浏览器关闭；sessionStorage 在窗口关闭前有效，localStorage 长期有效，直到用户删除 共享：sessionStorage 不能共享，localStorage 在同源文档之间共享，cookie 在同源且符合 path 规则的文档之间共享 localStorage 的修改会促发其他文档窗口的 update 事件 cookie 有 secure 属性要求 HTTPS 传输 浏览器不能保存超过 300 个 cookie，单个服务器不能超过 20 个，每个 cookie 不能超过 4k。web storage 大小支持能达到 5M 评价一下三种方法实现继承的优缺点,并改进12345678910111213141516function Shape() {}function Rect() {}// 方法1Rect.prototype = new Shape();// 方法2Rect.prototype = Shape.prototype;// 方法3Rect.prototype = Object.create(Shape.prototype);Rect.prototype.area = function () { // do something}; 方法 1： 优点：正确设置原型链实现继承 优点：父类实例属性得到继承，原型链查找效率提高，也能为一些属性提供合理的默认值 缺点：父类实例属性为引用类型时，不恰当地修改会导致所有子类被修改 缺点：创建父类实例作为子类原型时，可能无法确定构造函数需要的合理参数，这样提供的参数继承给子类没有实际意义，当子类需要这些参数时应该在构造函数中进行初始化和设置 总结：继承应该是继承方法而不是属性，为子类设置父类实例属性应该是通过在子类构造函数中调用父类构造函数进行初始化 方法 2： 优点：正确设置原型链实现继承 缺点：父类构造函数原型与子类相同。修改子类原型添加方法会修改父类 方法 3： 优点：正确设置原型链且避免方法 1.2 中的缺点 缺点：ES5 方法需要注意兼容性 改进： 所有三种方法应该在子类构造函数中调用父类构造函数实现实例属性初始化 123function Rect() { Shape.call(this);} 用新创建的对象替代子类默认原型，设置Rect.prototype.constructor = Rect;保证一致性 第三种方法的 polyfill： 123456789function create(obj) { if (Object.create) { return Object.create(obj); } function f() {}; f.prototype = obj; return new f();}","link":"/2020/02/25/js%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%982/"},{"title":"js编程部分面试题","text":"javascript 算法题 请用原生 js 实现一个函数,给页面制定的任意一个元素添加一个透明遮罩(透明度可变,默认 0.2),使这个区域点击无效,要求兼容 IE8+及各主流浏览器,12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style&gt;#target { width: 200px; height: 300px; margin: 40px; background-color: tomato;}&lt;/style&gt;&lt;div id=&quot;target&quot;&gt;&lt;/div&gt;&lt;script&gt;function addMask(elem, opacity) { opacity = opacity || 0.2; var rect = elem.getBoundingClientRect(); var style = getComputedStyle(elem, null); var mask = document.createElement('div'); mask.style.position = 'absolute'; var marginLeft = parseFloat(style.marginLeft); mask.style.left = (elem.offsetLeft - marginLeft) + 'px'; var marginTop = parseFloat(style.marginTop); mask.style.top = (elem.offsetTop - marginTop) + 'px'; mask.style.zIndex = 9999; mask.style.opacity = '' + opacity; mask.style.backgroundColor = '#000'; mask.style.width = (parseFloat(style.marginLeft) + parseFloat(style.marginRight) + rect.width) + 'px'; mask.style.height = (parseFloat(style.marginTop) + parseFloat(style.marginBottom) + rect.height) + 'px'; elem.parentNode.appendChild(mask);}var target = document.getElementById('target');addMask(target);target.addEventListener('click', function () { console.log('click');}, false);&lt;/script&gt; 请用代码写出(今天是星期 x)其中 x 表示当天是星期几,如果当天是星期一,输出应该是”今天是星期一”1234var days = ['日','一','二','三','四','五','六'];var date = new Date();console.log('今天是星期' + days[date.getDay()]); 下面这段代码想要循环延时输出结果 0 1 2 3 4,请问输出结果是否正确,如果不正确,请说明为什么,并修改循环内的代码使其输出正确结果12345for (var i = 0; i &lt; 5; ++i) { setTimeout(function () { console.log(i + ' '); }, 100);} 不能输出正确结果，因为循环中 setTimeout 接受的参数函数通过闭包访问变量 i。javascript 运行环境为单线程，setTimeout 注册的函数需要等待线程空闲才能执行，此时 for 循环已经结束，i 值为 5.五个定时输出都是 5修改方法：将 setTimeout 放在函数立即调用表达式中，将 i 值作为参数传递给包裹函数，创建新闭包 1234567for (var i = 0; i &lt; 5; ++i) { (function (i) { setTimeout(function () { console.log(i + ' '); }, 100); }(i));} 现有一个 Page 类,其原型对象上有许多以 post 开头的方法(如 postMsg);另有一拦截函数 chekc,只返回 ture 或 false.请设计一个函数,该函数应批量改造原 Page 的 postXXX 方法,在保留其原有功能的同时,为每个 postXXX 方法增加拦截验证功能,当 chekc 返回 true 时继续执行原 postXXX 方法,返回 false 时不再执行原 postXXX 方法1234567891011121314151617181920212223242526272829303132333435363738394041function Page() {}Page.prototype = { constructor: Page, postA: function (a) { console.log('a:' + a); }, postB: function (b) { console.log('b:' + b); }, postC: function (c) { console.log('c:' + c); }, check: function () { return Math.random() &gt; 0.5; }}function checkfy(obj) { for (var key in obj) { if (key.indexOf('post') === 0 &amp;&amp; typeof obj[key] === 'function') { (function (key) { var fn = obj[key]; obj[key] = function () { if (obj.check()) { fn.apply(obj, arguments); } }; }(key)); } }} // end checkfy()checkfy(Page.prototype);var obj = new Page();obj.postA('checkfy');obj.postB('checkfy');obj.postC('checkfy'); 编写 javascript 深度克隆函数 deepClonefunction deepClone(obj) { var _toString = Object.prototype.toString; // null, undefined, non-object, function if (!obj || typeof obj !== &apos;object&apos;) { return obj; } // DOM Node if (obj.nodeType &amp;&amp; &apos;cloneNode&apos; in obj) { return obj.cloneNode(true); } // Date if (_toString.call(obj) === &apos;[object Date]&apos;) { return new Date(obj.getTime()); } // RegExp if (_toString.call(obj) === &apos;[object RegExp]&apos;) { var flags = []; if (obj.global) { flags.push(&apos;g&apos;); } if (obj.multiline) { flags.push(&apos;m&apos;); } if (obj.ignoreCase) { flags.push(&apos;i&apos;); } return new RegExp(obj.source, flags.join(&apos;&apos;)); } var result = Array.isArray(obj) ? [] : obj.constructor ? new obj.constructor() : {}; for (var key in obj ) { result[key] = deepClone(obj[key]); } return result; } function A() { this.a = a; } var a = { name: &apos;qiu&apos;, birth: new Date(), pattern: /qiu/gim, container: document.body, hobbys: [&apos;book&apos;, new Date(), /aaa/gim, 111] }; var c = new A(); var b = deepClone(c); console.log(c.a === b.a); console.log(c, b);补充代码,鼠标单击 Button1 后将 Button1 移动到 Button2 的后面&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;TEst&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;input type=&quot;button&quot; id =&quot;button1&quot; value=&quot;1&quot; /&gt; &lt;input type=&quot;button&quot; id =&quot;button2&quot; value=&quot;2&quot; /&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var btn1 = document.getElementById(&apos;button1&apos;); var btn2 = document.getElementById(&apos;button2&apos;); addListener(btn1, &apos;click&apos;, function (event) { btn1.parentNode.insertBefore(btn2, btn1); }); function addListener(elem, type, handler) { if (elem.addEventListener) { elem.addEventListener(type, handler, false); return handler; } else if (elem.attachEvent) { function wrapper() { var event = window.event; event.target = event.srcElement; handler.call(elem, event); } elem.attachEvent(&apos;on&apos; + type, wrapper); return wrapper; } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;网页中实现一个计算当年还剩多少时间的倒数计时程序,要求网页上实时动态显示”×× 年还剩 ×× 天 ×× 时 ×× 分 ×× 秒”&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;TEst&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;span id=&quot;target&quot;&gt;&lt;/span&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 为了简化。每月默认30天 function getTimeString() { var start = new Date(); var end = new Date(start.getFullYear() + 1, 0, 1); var elapse = Math.floor((end - start) / 1000); var seconds = elapse % 60 ; var minutes = Math.floor(elapse / 60) % 60; var hours = Math.floor(elapse / (60 * 60)) % 24; var days = Math.floor(elapse / (60 * 60 * 24)) % 30; var months = Math.floor(elapse / (60 * 60 * 24 * 30)) % 12; var years = Math.floor(elapse / (60 * 60 * 24 * 30 * 12)); return start.getFullYear() + &apos;年还剩&apos; + years + &apos;年&apos; + months + &apos;月&apos; + days + &apos;日&apos; + hours + &apos;小时&apos; + minutes + &apos;分&apos; + seconds + &apos;秒&apos;; } function domText(elem, text) { if (text == undefined) { if (elem.textContent) { return elem.textContent; } else if (elem.innerText) { return elem.innerText; } } else { if (elem.textContent) { elem.textContent = text; } else if (elem.innerText) { elem.innerText = text; } else { elem.innerHTML = text; } } } var target = document.getElementById(&apos;target&apos;); setInterval(function () { domText(target, getTimeString()); }, 1000) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;完成一个函数,接受数组作为参数,数组元素为整数或者数组,数组元素包含整数或数组,函数返回扁平化后的数组如：[1, [2, [ [3, 4], 5], 6]] =&gt; [1, 2, 3, 4, 5, 6] 123456789101112131415161718var data = [1, [2, [ [3, 4], 5], 6]];function flat(data, result) { var i, d, len; for (i = 0, len = data.length; i &lt; len; ++i) { d = data[i]; if (typeof d === 'number') { result.push(d); } else { flat(d, result); } }}var result = [];flat(data, result);console.log(result); 如何判断一个对象是否为数组如果浏览器支持 Array.isArray()可以直接判断否则需进行必要判断 123456789101112/** * 判断一个对象是否是数组，参数不是对象或者不是数组，返回false * * @param {Object} arg 需要测试是否为数组的对象 * @return {Boolean} 传入参数是数组返回true，否则返回false */function isArray(arg) { if (typeof arg === 'object') { return Object.prototype.toString.call(arg) === '[object Array]'; } return false;} 请评价以下事件监听器代码并给出改进意见123456789101112if (window.addEventListener) { var addListener = function (el, type, listener, useCapture) { el.addEventListener(type, listener, useCapture); };}else if (document.all) { addListener = function (el, type, listener) { el.attachEvent('on' + type, function () { listener.apply(el); }); };} 作用：浏览器功能检测实现跨浏览器 DOM 事件绑定 优点： 测试代码只运行一次，根据浏览器确定绑定方法 通过listener.apply(el)解决 IE 下监听器 this 与标准不一致的地方 在浏览器不支持的情况下提供简单的功能，在标准浏览器中提供捕获功能 缺点： document.all 作为 IE 检测不可靠，应该使用 if(el.attachEvent) addListener 在不同浏览器下 API 不一样 listener.apply使 this 与标准一致但监听器无法移除 未解决 IE 下 listener 参数 event。 target 问题 改进: 12345678910111213141516171819202122var addListener;if (window.addEventListener) { addListener = function (el, type, listener, useCapture) { el.addEventListener(type, listener, useCapture); return listener; };}else if (window.attachEvent) { addListener = function (el, type, listener) { // 标准化this，event，target var wrapper = function () { var event = window.event; event.target = event.srcElement; listener.call(el, event); }; el.attachEvent('on' + type, wrapper); return wrapper; // 返回wrapper。调用者可以保存，以后remove };}","link":"/2020/02/25/js%E7%BC%96%E7%A8%8B%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"js编程部分面试题2","text":"javascript 算法题 如何判断一个对象是否为函数1234567891011121314151617/** * 判断对象是否为函数，如果当前运行环境对可调用对象（如正则表达式） * 的typeof返回'function'，采用通用方法，否则采用优化方法 * * @param {Any} arg 需要检测是否是函数的对象 * @return {boolean} 如果参数是函数，返回true，否则false */function isFunction(arg) { if (arg) { if (typeof (/./) !== 'function') { return typeof arg === 'function'; } else { return Object.prototype.toString.call(arg) === '[object Function]'; } } // end if return false;} 编写一个函数接受 url 中 query string 为参数,返回解析后的 Object,query string 使用 application/x-www-form-urlencoded 编码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 解析query string转换为对象，一个key有多个值时生成数组 * * @param {String} query 需要解析的query字符串，开头可以是?， * 按照application/x-www-form-urlencoded编码 * @return {Object} 参数解析后的对象 */function parseQuery(query) { var result = {}; // 如果不是字符串返回空对象 if (typeof query !== 'string') { return result; } // 去掉字符串开头可能带的? if (query.charAt(0) === '?') { query = query.substring(1); } var pairs = query.split('&amp;'); var pair; var key, value; var i, len; for (i = 0, len = pairs.length; i &lt; len; ++i) { pair = pairs[i].split('='); // application/x-www-form-urlencoded编码会将' '转换为+ key = decodeURIComponent(pair[0]).replace(/\\+/g, ' '); value = decodeURIComponent(pair[1]).replace(/\\+/g, ' '); // 如果是新key，直接添加 if (!(key in result)) { result[key] = value; } // 如果key已经出现一次以上，直接向数组添加value else if (isArray(result[key])) { result[key].push(value); } // key第二次出现，将结果改为数组 else { var arr = [result[key]]; arr.push(value); result[key] = arr; } // end if-else } // end for return result;}function isArray(arg) { if (arg &amp;&amp; typeof arg === 'object') { return Object.prototype.toString.call(arg) === '[object Array]'; } return false;}/**console.log(parseQuery('sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8')); */ 解析一个完整的 url,返回 Object 包含域与 window.location 相同12345678910111213141516171819202122232425262728293031323334353637/** * 解析一个url并生成window.location对象中包含的域 * location: * { * href: '包含完整的url', * origin: '包含协议到pathname之前的内容', * protocol: 'url使用的协议，包含末尾的:', * username: '用户名', // 暂时不支持 * password: '密码', // 暂时不支持 * host: '完整主机名，包含:和端口', * hostname: '主机名，不包含端口' * port: '端口号', * pathname: '服务器上访问资源的路径/开头', * search: 'query string，?开头', * hash: '#开头的fragment identifier' * } * * @param {string} url 需要解析的url * @return {Object} 包含url信息的对象 */function parseUrl(url) { var result = {}; var keys = ['href', 'origin', 'protocol', 'host', 'hostname', 'port', 'pathname', 'search', 'hash']; var i, len; var regexp = /(([^:]+:)\\/\\/(([^:\\/\\?#]+)(:\\d+)?))(\\/[^?#]*)?(\\?[^#]*)?(#.*)?/; var match = regexp.exec(url); if (match) { for (i = keys.length - 1; i &gt;= 0; --i) { result[keys[i]] = match[i] ? match[i] : ''; } } return result;} 完成函数 getViewportSize 返回指定窗口的视口尺寸1234567891011121314151617181920212223242526272829/*** 查询指定窗口的视口尺寸，如果不指定窗口，查询当前窗口尺寸**/function getViewportSize(w) { w = w || window; // IE9及标准浏览器中可使用此标准方法 if ('innerHeight' in w) { return { width: w.innerWidth, height: w.innerHeight }; } var d = w.document; // IE 8及以下浏览器在标准模式下 if (document.compatMode === 'CSS1Compat') { return { width: d.documentElement.clientWidth, height: d.documentElement.clientHeight }; } // IE8及以下浏览器在怪癖模式下 return { width: d.body.clientWidth, height: d.body.clientHeight };} 完成函数 getScrollOffset 返回窗口滚动条偏移量/** * 获取指定window中滚动条的偏移量，如未指定则获取当前window * 滚动条偏移量 * * @param {window} w 需要获取滚动条偏移量的窗口 * @return {Object} obj.x为水平滚动条偏移量,obj.y为竖直滚动条偏移量 */ function getScrollOffset(w) { w = w || window; // 如果是标准浏览器 if (w.pageXOffset != null) { return { x: w.pageXOffset, y: w.pageYOffset }; } // 老版本IE，根据兼容性不同访问不同元素 var d = w.document; if (d.compatMode === &apos;CSS1Compat&apos;) { return { x: d.documentElement.scrollLeft, y: d.documentElement.scrollTop } } return { x: d.body.scrollLeft, y: d.body.scrollTop }; }现有一个字符串 richText,是一段富文本,需要显示在页面上.有个要求,需要给其中只包含一个 img 元素的 p 标签增加一个叫 pic 的 class.请编写代码实现.可以使用 jQuery 或 KISSY.function richText(text) { var div = document.createElement(&apos;div&apos;); div.innerHTML = text; var p = div.getElementsByTagName(&apos;p&apos;); var i, len; for (i = 0, len = p.length; i &lt; len; ++i) { if (p[i].getElementsByTagName(&apos;img&apos;).length === 1) { p[i].classList.add(&apos;pic&apos;); } } return div.innerHTML; }请实现一个 Event 类,继承自此类的对象都会拥有两个方法 on,off,once 和 triggerfunction Event() { if (!(this instanceof Event)) { return new Event(); } this._callbacks = {}; } Event.prototype.on = function (type, handler) { this_callbacks = this._callbacks || {}; this._callbacks[type] = this.callbacks[type] || []; this._callbacks[type].push(handler); return this; }; Event.prototype.off = function (type, handler) { var list = this._callbacks[type]; if (list) { for (var i = list.length; i &gt;= 0; --i) { if (list[i] === handler) { list.splice(i, 1); } } } return this; }; Event.prototype.trigger = function (type, data) { var list = this._callbacks[type]; if (list) { for (var i = 0, len = list.length; i &lt; len; ++i) { list[i].call(this, data); } } }; Event.prototype.once = function (type, handler) { var self = this; function wrapper() { handler.apply(self, arguments); self.off(type, wrapper); } this.on(type, wrapper); return this; };编写一个函数将列表子元素顺序反转1234567891011121314151617&lt;ul id=&quot;target&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var target = document.getElementById('target'); var i; var frag = document.createDocumentFragment(); for (i = target.children.length - 1; i &gt;= 0; --i) { frag.appendChild(target.children[i]); } target.appendChild(frag);&lt;/script&gt; 以下函数的作用是?空白区域应该填写什么123456789101112131415161718192021// define(function (window) { function fn(str) { this.str = str; } fn.prototype.format = function () { var arg = __1__; return this.str.replace(__2__, function (a, b) { return arg[b] || ''; }); }; window.fn = fn;})(window);// use(function () { var t = new fn('&lt;p&gt;&lt;a href=&quot;{0}&quot;&gt;{1}&lt;/a&gt;&lt;span&gt;{2}&lt;/span&gt;&lt;/p&gt;'); console.log(t.format('http://www.alibaba.com', 'Alibaba', 'Welcome'));})(); define 部分定义一个简单的模板类，使用{}作为转义标记，中间的数字表示替换目标，format 实参用来替换模板内标记横线处填： Array.prototype.slice.call(arguments, 0) /\\{\\s*(\\d+)\\s*\\}/g 编写一个函数实现 form 的序列化(即将一个表单中的键值序列化为可提交的字符串)&lt;form id=&quot;target&quot;&gt; &lt;select name=&quot;age&quot;&gt; &lt;option value=&quot;aaa&quot;&gt;aaa&lt;/option&gt; &lt;option value=&quot;bbb&quot; selected&gt;bbb&lt;/option&gt; &lt;/select&gt; &lt;select name=&quot;friends&quot; multiple&gt; &lt;option value=&quot;qiu&quot; selected&gt;qiu&lt;/option&gt; &lt;option value=&quot;de&quot;&gt;de&lt;/option&gt; &lt;option value=&quot;qing&quot; selected&gt;qing&lt;/option&gt; &lt;/select&gt; &lt;input name=&quot;name&quot; value=&quot;qiudeqing&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;11111&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;salery&quot; value=&quot;3333&quot;&gt; &lt;textarea name=&quot;description&quot;&gt;description&lt;/textarea&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; checked value=&quot;football&quot;&gt;Football &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;basketball&quot;&gt;Basketball &lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked value=&quot;Female&quot;&gt;Female &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;Male&quot;&gt;Male &lt;/form&gt; &lt;script&gt; /** * 将一个表单元素序列化为可提交的字符串 * * @param {FormElement} form 需要序列化的表单元素 * @return {string} 表单序列化后的字符串 */ function serializeForm(form) { if (!form || form.nodeName.toUpperCase() !== &apos;FORM&apos;) { return; } var result = []; var i, len; var field, fieldName, fieldType; for (i = 0, len = form.length; i &lt; len; ++i) { field = form.elements[i]; fieldName = field.name; fieldType = field.type; if (field.disabled || !fieldName) { continue; } // enf if switch (fieldType) { case &apos;text&apos;: case &apos;password&apos;: case &apos;hidden&apos;: case &apos;textarea&apos;: result.push(encodeURIComponent(fieldName) + &apos;=&apos; + encodeURIComponent(field.value)); break; case &apos;radio&apos;: case &apos;checkbox&apos;: if (field.checked) { result.push(encodeURIComponent(fieldName) + &apos;=&apos; + encodeURIComponent(field.value)); } break; case &apos;select-one&apos;: case &apos;select-multiple&apos;: for (var j = 0, jLen = field.options.length; j &lt; jLen; ++j) { if (field.options[j].selected) { result.push(encodeURIComponent(fieldName) + &apos;=&apos; + encodeURIComponent(field.options[j].value || field.options[j].text)); } } // end for break; case &apos;file&apos;: case &apos;submit&apos;: break; // 是否处理？ default: break; } // end switch } // end for return result.join(&apos;&amp;&apos;); } var form = document.getElementById(&apos;target&apos;); console.log(serializeForm(form)); &lt;/script&gt;使用原生 javascript 给下面列表中的 li 节点绑定点击事件,点击时创建一个 Object 对象,兼容 IE 和标准浏览器12345678910111213&lt;ul id=&quot;nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;http://11111&quot;&gt;111&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://2222&quot;&gt;222&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://333&quot;&gt;333&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://444&quot;&gt;444&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;Object:{ &quot;index&quot;: 1, &quot;name&quot;: &quot;111&quot;, &quot;link&quot;: &quot;http://1111&quot;} script: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778var EventUtil = { getEvent: function (event) { return event || window.event; }, getTarget: function (event) { return event.target || event.srcElement; }, // 返回注册成功的监听器，IE中需要使用返回值来移除监听器 on: function (elem, type, handler) { if (elem.addEventListener) { elem.addEventListener(type, handler, false); return handler; } else if (elem.attachEvent) { function wrapper(event) { return handler.call(elem, event); }; elem.attachEvent('on' + type, wrapper); return wrapper; } }, off: function (elem, type, handler) { if (elem.removeEventListener) { elem.removeEventListener(type, handler, false); } else if (elem.detachEvent) { elem.detachEvent('on' + type, handler); } }, preventDefault: function (event) { if (event.preventDefault) { event.preventDefault(); } else if ('returnValue' in event) { event.returnValue = false; } }, stopPropagation: function (event) { if (event.stopPropagation) { event.stopPropagation(); } else if ('cancelBubble' in event) { event.cancelBubble = true; } }};var DOMUtil = { text: function (elem) { if ('textContent' in elem) { return elem.textContent; } else if ('innerText' in elem) { return elem.innerText; } }, prop: function (elem, propName) { return elem.getAttribute(propName); }};var nav = document.getElementById('nav');EventUtil.on(nav, 'click', function (event) { var event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); var children = this.children; var i, len; var anchor; var obj = {}; for (i = 0, len = children.length; i &lt; len; ++i) { if (children[i] === target) { obj.index = i + 1; anchor = target.getElementsByTagName('a')[0]; obj.name = DOMUtil.text(anchor); obj.link = DOMUtil.prop(anchor, 'href'); } } alert('index: ' + obj.index + ' name: ' + obj.name + ' link: ' + obj.link);}); 有一个大数组,var a = [‘1’, ‘2’, ‘3’, …];a 的长度是 100,内容填充随机整数的字符串.请先构造此数组 a,然后设计一个算法将其内容去重123456789101112131415161718192021222324252627282930313233343536373839404142434445/*** 数组去重**/function normalize(arr) { if (arr &amp;&amp; Array.isArray(arr)) { var i, len, map = {}; for (i = arr.length; i &gt;= 0; --i) { if (arr[i] in map) { arr.splice(i, 1); } else { map[arr[i]] = true; } } } return arr;}/*** 用100个随机整数对应的字符串填充数组。**/function fillArray(arr, start, end) { start = start == undefined ? 1 : start; end = end == undefined ? 100 : end; if (end &lt;= start) { end = start + 100; } var width = end - start; var i; for (i = 100; i &gt;= 1; --i) { arr.push('' + (Math.floor(Math.random() * width) + start)); } return arr;}var input = [];fillArray(input, 1, 100);input.sort(function (a, b) { return a - b;});console.log(input);normalize(input);console.log(input);","link":"/2020/02/25/js%E7%BC%96%E7%A8%8B%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%982/"}],"tags":[{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"面试题基础","slug":"面试题基础","link":"/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9F%BA%E7%A1%80/"},{"name":"面试题算法","slug":"面试题算法","link":"/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"npm","slug":"npm","link":"/categories/npm/"},{"name":"ES6","slug":"ES6","link":"/categories/ES6/"},{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"}]}