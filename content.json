{"pages":[],"posts":[{"title":"04-样式表的继承性和层叠性","text":"本文重点 CSS的继承性 CSS的层叠性 计算权重 权重问题大总结 CSS样式表的冲突的总结 权重问题深入 同一个标签，携带了多个类名 !important标记 前言来自 https://github.com/qianguyihao/Web CSS的继承性我们来看下面这样的代码，来引入继承性： 上方代码中，我们给div标签增加红色属性，却发现，div里的每一个子标签&lt;p&gt;也增加了红色属性。于是我们得到这样的结论： 有一些属性，当给自己设置的时候，自己的后代都继承上了，这个就是继承性。 继承性是从自己开始，直到最小的元素。 但是呢，如果再给上方的代码加一条属性： 上图中，我们给div加了一个border，但是发现只有div具备了border属性，而p标签却没有border属性。于是我们可以得出结论： 关于文字样式的属性，都具有继承性。这些属性包括：color、 text-开头的、line-开头的、font-开头的。 关于盒子、定位、布局的属性，都不能继承。 以后当我们谈到css有哪些特性的时候，我们要首先想到继承性。而且，要知道哪些属性具有继承性、哪些属性没有继承性。 CSS的层叠性很多公司如果要笔试，那么一定会考层叠性。 层叠性：计算权重层叠性：就是css处理冲突的能力。 所有的权重计算，没有任何兼容问题！ CSS像艺术家一样优雅，像工程师一样严谨。 我们来看一个例子，就知道什么叫层叠性了。 上图中，三种选择器同时给P标签增加颜色的属性，但是，文字最终显示的是蓝色，这个时候，就出现了层叠性的情况。 当多个选择器，选择上了某个元素的时候，要按照如下顺序统计权重： id 选择器 类选择器、属性选择器、伪类选择器 标签选择器、伪元素选择器 因为对于相同方式的样式表，其选择器排序的优先级为：ID选择器 &gt; 类选择器 &gt; 标签选择器 针对上面这句话，我们接下来举一些复杂一点的例子。 层叠性举例举例1：计算权重 如上图所示，统计各个选择器的数量，优先级高的胜出。文字的颜色为红色。 PS：不进位，实际上能进位（奇淫知识点：255个标签，等于1个类名）但是没有实战意义！ 举例2：权重相同时 上图可以看到，第一个样式和第二个样式的权重相同。但第二个样式的书写顺序靠后，因此以第二个样式为准（就近原则）。 举例3：具有实战性的例子 现在我要让一个列表实现上面的这种样式：第一个li为红色，剩下的li全部为蓝色","link":"/2020/03/07/css/04-%E6%A0%B7%E5%BC%8F%E8%A1%A8%E7%9A%84%E7%BB%A7%E6%89%BF%E6%80%A7%E5%92%8C%E5%B1%82%E5%8F%A0%E6%80%A7/"},{"title":"01-css属性和文本属性","text":"本文重要内容 CSS的单位 字体属性 文本属性 定位属性：position、float、overflow等 前言来自 https://github.com/qianguyihao/Web CSS的单位html中的单位只有一种，那就是像素px，所以单位是可以省略的，但是在CSS中不一样。CSS中的单位是必须要写的，因为它没有默认单位。 绝对单位1 in=2.54cm=25.4mm=72pt=6pc。 各种单位的含义： in：英寸Inches (1 英寸 = 2.54 厘米) cm：厘米Centimeters mm：毫米Millimeters pt：点Points，或者叫英镑 (1点 = 1/72英寸) pc：皮卡Picas (1 皮卡 = 12 点) 相对单位px：像素em：印刷单位相当于12个点%：百分比，相对周围的文字的大小 为什么说像素px是一个相对单位呢，这也很好理解。比如说，电脑屏幕的的尺寸是不变的，但是我们可以让其显示不同的分辨率，在不同的分辨率下，单个像素的长度肯定是不一样的啦。 百分比%这个相对单位要怎么用呢？这里也举个例子： font 字体属性CSS中，有很多非布局样式（与布局无关），包括：字体、行高、颜色、大小、背景、边框、滚动、换行、装饰性属性（粗体、斜体、下划线）等。 这一段，我们先来讲一下字体属性。 css样式中，常见的字体属性有以下几种： 12345678p{ font-size: 50px; /*字体大小*/ line-height: 30px; /*行高*/ font-family: 幼圆,黑体; /*字体类型：如果没有幼圆就显示黑体，没有黑体就显示默认*/ font-style: italic ; /*italic表示斜体，normal表示不倾斜*/ font-weight: bold; /*粗体*/ font-variant: small-caps; /*小写变大写*/} 行高CSS中，所有的行，都有行高。盒子模型的padding，绝对不是直接作用在文字上的，而是作用在“行”上的。 如下图所示： 上图中，我们设置行高为30px，30px * 5 = 150px，通过查看审查元素，这个p标签的高度果然为150px。而且我们发现，我们并没有给这个p标签设置高度，显然是内容将其撑高的。 垂直方向来看，文字在自己的行里是居中的。比如，文字是14px，行高是24px，那么padding就是5px： 为了严格保证字在行里面居中，我们的工程师有一个约定： 行高、字号，一般都是偶数。这样可以保证，它们的差一定偶数，就能够被2整除。 如何让单行文本垂直居中小技巧：如果一段文本只有一行，如果此时设置行高 = 盒子高，就可以保证单行文本垂直居中。这个很好理解。 上面这个小技巧，只适用于单行文本垂直居中，不适用于多行。如果想让多行文本垂直居中，还需要计算盒子的padding。计算方式如下： vertical-align: middle; 属性1vertical-align: middle; /*指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。*/ 字号、行高、字体三大属性（1）字号： 1font-size:14px; （2）行高： 1line-height:24px; （3）字体：（font-family就是“字体”，family是“家庭”的意思） 1font-family:&quot;宋体&quot;; 是否加粗属性以及上面这三个属性，我们可以连写：（是否加粗、字号 font-size、行高 line-height、字体 font-family） 格式： 1font: 加粗 字号/行高/ 字体 举例： 1font: 400 14px/24px &quot;宋体&quot;; PS：400是nomal，700是bold。 上面这几个属性可以连写，但是有一个要求，font属性连写至少要有字号和字体，否则连写是不生效的（相当于没有这一行代码）。 2、字体属性的说明： （1）网页中不是所有字体都能用，因为这个字体要看用户的电脑里面装没装，比如你设置： 1font-family: &quot;华文彩云&quot;; 上方代码中，如果用户的 Windows 电脑里面没有这个字体，那么就会变成宋体。 页面中，中文我们一般使用：微软雅黑、宋体、黑体。英文使用：Arial、Times New Roman。页面中如果需要其他的字体，就需要单独安装字体，或者切图。 （2）为了防止用户电脑里，没有微软雅黑这个字体。就要用英语的逗号，提供备选字体。如下：（可以备选多个） 1font-family: &quot;微软雅黑&quot;,&quot;宋体&quot;; 上方代码表示：如果用户电脑里没有安装微软雅黑字体，那么就是宋体。 （3）我们须将英语字体放在最前面，这样所有的中文，就不能匹配英语字体，就自动的变为后面的中文字体： 1font-family: &quot;Times New Roman&quot;,&quot;微软雅黑&quot;,&quot;宋体&quot;; 上方代码的意思是，英文会采用Times New Roman字体，而中文会采用微软雅黑字体（因为美国人设计的Times New Roman字体并不针对中文，所以中文会采用后面的微软雅黑）。比如说，对于smyhvae哈哈哈这段文字，smyhvae会采用Times New Roman字体，而哈哈哈会采用微软雅黑字体。 可是，如果我们把中文字体写在前面：(错误写法) 1font-family: &quot;微软雅黑&quot;,&quot;Times New Roman&quot;,&quot;宋体&quot;; 上方代码会导致，中文和英文都会采用微软雅黑字体。 （4）所有的中文字体，都有英语别名。 微软雅黑的英语别名： 1font-family: &quot;Microsoft YaHei&quot;; 宋体的英语别名： 1font-family: &quot;SimSun&quot;; 于是，当我们把字号、行高、字体这三个属性合二为一时，也可以写成： 1font:12px/30px &quot;Times New Roman&quot;,&quot;Microsoft YaHei&quot;,&quot;SimSun&quot;; （5）行高可以用百分比，表示字号的百分之多少。 一般来说，百分比都是大于100%的，因为行高一定要大于字号。 比如说， font:12px/200% “宋体”等价于font:12px/24px “宋体”。200%可以理解成word里面的2倍行高。 反过来， font:16px/48px “宋体”;等价于font:16px/300% “宋体”。 字体加粗属性1234567.div { font-weight: normal; /*正常*/ font-weight: bold; /*加粗*/ font-weight: 100; font-weight: 200; font-weight: 900;} 在设置字体是否加粗时，属性值既可以填写normal、bold这样的加粗字体，也可以直接填写 100至900 这样的数字。normal的值相当于400，bold的值相当于700。 文本属性CSS样式中，常见的文本属性有以下几种： letter-spacing: 0.5cm ; 单个字母之间的间距 word-spacing: 1cm; 单词之间的间距 text-decoration: none; 字体修饰：none 去掉下划线、underline 下划线、line-through 中划线、overline 上划线 text-transform: lowercase; 单词字体大小写。uppercase大写、lowercase小写 color:red; 字体颜色 text-align: center; 在当前容器中的对齐方式。属性值可以是：left、right、center（在当前容器的中间）、justify text-transform: lowercase; 单词的字体大小写。属性值可以是：uppercase（单词大写）、lowercase（单词小写）、capitalize（每个单词的首字母大写） 这里来一张表格的图片吧，一览无遗： 列表属性1234ul li{ list-style-image:url(images/2.gif) ; /*列表项前设置为图片*/ margin-left:80px; /*公有属性*/} 另外还有一个简写属性叫做list-style，它的作用是：将上面的多个属性写在一个声明中。 我们来看一下list-style-image属性的效果： 给列表前面的图片加个边距吧，不然显示不完整： 这里来一张表格的图片吧，一览无遗： overflow属性：超出范围的内容要怎么处理overflow属性的属性值可以是： visible：默认值。多余的内容不剪切也不添加滚动条，会全部显示出来。 hidden：不显示超过对象尺寸的内容。 auto：如果内容不超出，则不显示滚动条；如果内容超出，则显示滚动条。 scroll：Windows 平台下，无论内容是否超出，总是显示滚动条。Mac 平台下，和 auto 属性相同。 针对上面的不同的属性值，我们来看一下效果：举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"Generator\" content=\"EditPlus®\"&gt; &lt;meta name=\"Author\" content=\"\"&gt; &lt;meta name=\"Keywords\" content=\"\"&gt; &lt;meta name=\"Description\" content=\"\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=\"text/css\"&gt; div{ width: 100px; height: 100px; background-color: #00cc66; margin-right: 100px; float: left; } #div1{ overflow: auto;/*超出的部分让浏览器自行解决*/ } #div2{ overflow: visible;/*超出的部分会显示出来*/ } #div3{ overflow: hidden;/*超出的部分将剪切掉*/ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"div1\"&gt;其实很简单 其实很自然 两个人的爱由两人分担 其实并不难 是你太悲观 隔着一道墙不跟谁分享 不想让你为难 你不再需要给我个答案&lt;/div&gt; &lt;div id=\"div2\"&gt;其实很简单 其实很自然 两个人的爱由两人分担 其实并不难 是你太悲观 隔着一道墙不跟谁分享 不想让你为难 你不再需要给我个答案&lt;/div&gt; &lt;div id=\"div3\"&gt;其实很简单 其实很自然 两个人的爱由两人分担 其实并不难 是你太悲观 隔着一道墙不跟谁分享 不想让你为难 你不再需要给我个答案&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 效果： 鼠标的属性 cursor鼠标的属性cursor有以下几个属性值： auto：默认值。浏览器根据当前情况自动确定鼠标光标类型。 pointer：IE6.0，竖起一只手指的手形光标。就像通常用户将光标移到超链接上时那样。 hand：和pointer的作用一样：竖起一只手指的手形光标。就像通常用户将光标移到超链接上时那样。 比如说，我想让鼠标放在那个标签上时，光标显示手状，代码如下： 123p:hover{ cursor: pointer;} 另外还有以下的属性：（不用记，需要的时候查一下就行了） all-scroll : IE6.0 有上下左右四个箭头，中间有一个圆点的光标。用于标示页面可以向上下左右任何方向滚动。 col-resize : IE6.0 有左右两个箭头，中间由竖线分隔开的光标。用于标示项目或标题栏可以被水平改变尺寸。 crosshair : 简单的十字线光标。 default : 客户端平台的默认光标。通常是一个箭头。 hand : 竖起一只手指的手形光标。就像通常用户将光标移到超链接上时那样。 move : 十字箭头光标。用于标示对象可被移动。 help : 带有问号标记的箭头。用于标示有帮助信息存在。 no-drop : IE6.0 带有一个被斜线贯穿的圆圈的手形光标。用于标示被拖起的对象不允许在光标的当前位置被放下。 not-allowed : IE6.0 禁止标记(一个被斜线贯穿的圆圈)光标。用于标示请求的操作不允许被执行。 progress : IE6.0 带有沙漏标记的箭头光标。用于标示一个进程正在后台运行。 row-resize : IE6.0 有上下两个箭头，中间由横线分隔开的光标。用于标示项目或标题栏可以被垂直改变尺寸。 text : 用于标示可编辑的水平文本的光标。通常是大写字母 I 的形状。 vertical-text : IE6.0 用于标示可编辑的垂直文本的光标。通常是大写字母 I 旋转90度的形状。 wait : 用于标示程序忙用户需要等待的光标。通常是沙漏或手表的形状。 *-resize : 用于标示对象可被改变尺寸方向的箭头光标。 w-resize | s-resize | n-resize | e-resize | ne-resize | sw-resize | se-resize | nw-resize url ( url ) : IE6.0 用户自定义光标。使用绝对或相对 url 地址指定光标文件(后缀为 .cur 或者 .ani )。 滤镜这里只举一个滤镜的例子吧。比如说让图片变成灰度图的效果，可以这样设置滤镜： 1&lt;img src=\"3.jpg\" style=\"filter:gray()\"&gt; 举例代码： 123456789101112&lt;body&gt;&lt;table&gt; &lt;tr&gt; &lt;td&gt;原始图片&lt;/td&gt; &lt;td&gt;图片加入黑白效果&lt;/td&gt; &lt;/tr&gt;&lt;tr&gt; &lt;td&gt;&lt;img src=\"3.jpg\"&gt;&lt;/td&gt; &lt;td&gt;&lt;img src=\"3.jpg\" style=\"filter:gray()\"&gt;&lt;/td&gt; /*滤镜：设置图片为灰白效果*/&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 效果如下：（IE有效果，google浏览器无效果） 延伸：滤镜本身是平面设计中的知识。如果你懂一点PS的话···打开PS看看吧： 爆料一下，表示博主有两年多的平面设计经验，我做设计的时间其实比写代码的时间要长，嘿嘿··· 导航栏的制作（本段内容请忽略）现在，我们利用float浮动属性来把无序列表做成一个简单的导航栏吧，效果如下： 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"Generator\" content=\"EditPlus®\"&gt; &lt;meta name=\"Author\" content=\"\"&gt; &lt;meta name=\"Keywords\" content=\"\"&gt; &lt;meta name=\"Description\" content=\"\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=\"text/css\"&gt; ul{ list-style: none;/*去掉列表前面的圆点*/ width: 420px; height: 60px; background-color: black;/*设置整个导航栏的背景为灰色*/ } li{ float: left;/*平铺*/ margin-right: 30px; margin-top: 16px; } a{ text-decoration: none;/*去掉超链的下划线*/ font-size: 20px; color: #BBBBBB;/*设置超链的字体为黑色*/ font-family:微软雅黑; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"\"&gt;博客园&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;新随笔&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;联系&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;订阅&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;管理&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2020/03/06/css/01-css%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%87%E6%9C%AC%E5%B1%9E%E6%80%A7/"},{"title":"03-样式表和选择器","text":"本文主要内容 CSS概述 CSS和HTML结合的三种方式：行内样式表、内嵌样式表、外部样式表 CSS四种基本选择器：标签选择器、类选择器、ID选择器、通用选择器 CSS几种扩展选择器：后代选择器、交集选择器、并集选择器 CSS样式优先级 前言来自 https://github.com/qianguyihao/Web CSS 概述CSS：Cascading Style Sheet，层叠样式表。CSS的作用就是给HTML页面标签添加各种样式，定义网页的显示效果。简单一句话：CSS将网页内容和显示样式进行分离，提高了显示功能。 css的最新版本是css3，我们目前学习的是css2.1。 因为css3和css2.1不矛盾，必须先学2.1然后学3。 接下来我们要讲一下为什么要使用CSS。 HTML的缺陷： 不能够适应多种设备 要求浏览器必须智能化足够庞大 数据和显示没有分开 功能不够强大 CSS 优点： 使数据和显示分开 降低网络流量 使整个网站视觉效果一致 使开发效率提高了（耦合性降低，一个人负责写html，一个人负责写css） 比如说，有一个样式需要在一百个页面上显示，如果是html来实现，那要写一百遍，现在有了css，只要写一遍。现在，html只提供数据和一些控件，完全交给css提供各种各样的样式。 CSS的重点知识点盒子模型、浮动、定位 CSS 整体感知我们先来看一段简单的css代码： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; p{ color:red; font-size: 30px; text-decoration: underline; font-weight: bold; text-align: center; font-style: italic; } h1{ color:blue; font-size: 50px; font-weight: bold; background-color: pink; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我是大标题&lt;/h1&gt; &lt;p&gt; 我是内容 &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 解释如下： 我们写css的地方是style标签，就是“样式”的意思，写在head里面。后面的课程中我们将知道，css也可以写在单独的文件里面，现在我们先写在style标签里面。 如果在sublime中输入&lt;st或者&lt;style然后按tab键，可以自动生成的格式如下：（建议） 1&lt;style type=\"text/css\"&gt;&lt;/style&gt; type表示“类型”，text就是“纯文本”，css也是纯文本。 但是，如果在sublime中输入st或者style然后按tab键，可以自动生成的格式如下：（不建议） 1&lt;style&gt;&lt;/style&gt; css对换行不敏感，对空格也不敏感。但是一定要有标准的语法。冒号，分号都不能省略。 CSS语法语法格式：（其实就是键值对） 1234选择器{ 属性名: 属性值; 属性名: 属性值;} 或者可以写成： 123456789101112选择器{ k:v; k:v; k:v; k:v;}选择器{ k:v; k:v; k:v; k:v;} 解释： 选择器代表页面上的某类元素，选择器后一定是大括号。 属性名后必须用冒号隔开，属性值后用分号（最后一个属性可以不用分号）。 属性名和冒号之间最好不要有空格（经验）。 如果一个属性有多个值的话，那么多个值用 空格 隔开 举例： 1p{color: red;} 完整版代码举例： 1234567891011121314&lt;style type=\"text/css\"&gt; p{ font-weight: bold; font-style: italic; color: red; }&lt;/style&gt; &lt;body&gt; &lt;p&gt;洗白白&lt;/p&gt; &lt;p&gt;你懂得&lt;/p&gt; &lt;p&gt;我不会就这样轻易的狗带&lt;/p&gt; &lt;/body&gt; 效果： css代码的注释格式： 12345678910111213&lt;style type=\"text/css\"&gt; /* 具体的注释 */ p{ font-weight: bold; font-style: italic; color: red; }&lt;/style&gt; 注意：CSS只有/* */这种注释，没有//这种注释。而且注释要写在&lt;style&gt;标签里面才算生效哦。 接下来，我们要开始真正地讲css的知识咯。 css怎么学？CSS有两个知识部分：1） 选择器，怎么选；2） 属性，样式是什么 CSS的一些简单常见的属性 我们先来接触CSS的一些简单常见的属性，因为接下来需要用到。后期会专门用一篇文章来写CSS的属性。 以下属性值中，括号中的内容表示sublime中的快捷键。 字体颜色：（c） 1color:red; color属性的值，可以是英语单词，比如red、blue、yellow等等；也可以是rgb、十六进制(后期详细讲)。 字号大小：（fos） 1font-size:40px; font就是“字体”，size就是“尺寸”。px是“像素”。单位必须加，不加不行。 背景颜色：（bgc） 1background-color: blue; background就是“背景”。 加粗：（fwb） 1font-weight: bold; font是“字体” weight是“重量”的意思，bold粗。 不加粗：（fwn） 1font-weight: normal; normal就是正常的意思。 斜体：（fsi） 1font-style: italic; italic就是“斜体”。 不斜体：（fsn） 1font-style: normal; 下划线：（tdu） 1text-decoration: underline; decoration就是“装饰”的意思。 没有下划线：（tdn） 1text-decoration:none; CSS和HTML结合的方式（样式表）CSS和HTML结合的方式，其实就是问你css的代码放在哪里比较合适。CSS代码理论上的位置是任意的，但通常写在&lt;style&gt;标签里。只要是&lt;style&gt;标签里的代码，那就是css代码，浏览器就是这样来进行解析的。 CSS和HTML的结合方式有3种： 行内样式：在某个特定的标签里采用style属性。范围只针对此标签。 内嵌样式表：在页面的head里采用&lt;style&gt;标签。范围针对此页面。 引入外部样式表css文件的方式。这种引入方式又分为两种： 1、采用&lt;link&gt;标签。例如：&lt;link rel = &quot;stylesheet&quot; type = &quot;text/css&quot; href = &quot;a.css&quot;&gt;&lt;/link&gt; 2、采用import，必须写在&lt;style&gt;标签中，并且必须是第一句。例如：@import url(a.css) ; 两种引入样式方式的区别：外部样式表中不能写标签，但是可以写import语句。 下面来详细的讲一讲这三种方式。 1、CSS和HTML结合方式一：行内样式采用style属性。范围只针对此标签适用。 该方式比较灵活，但是对于多个相同标签的同一样式定义比较麻烦，适合局部修改。 举例： 1&lt;p style=\"color:white;background-color:red\"&gt;我不会就这样轻易的狗带&lt;/p&gt; 效果： 2、CSS和HTML结合方式二：内嵌样式表在head标签中加入&lt;style&gt;标签，对多个标签进行统一修改，范围针对此页面。 该方式可以对单个页面的样式进行统一设置，但对于局部不够灵活。 举例： 12345678910111213&lt;style type=\"text/css\"&gt; p{ font-weight: bold; font-style: italic; color: red; }&lt;/style&gt; &lt;body&gt; &lt;p&gt;洗白白&lt;/p&gt; &lt;p style=\"color:blue\"&gt;你懂得&lt;/p&gt; &lt;/body&gt; 3、CSS和HTML结合方式三：引入外部样式表css文件引入样式表文件的方式又分为两种： （1）采用&lt;link&gt;标签。例如：&lt;link rel = &quot;stylesheet&quot; type = &quot;text/css&quot; href = &quot;a.css&quot;&gt;&lt;/link&gt; （2）采用import，必须写在&lt;style&gt;标签中，并且必须是第一句。例如：@import url(a.css) ; 两种引入样式方式的区别：外部样式表中不能写标签，但是可以写import语句。 具体操作如下： 我们先在html页面的同级目录下新建一个a.css文件，那说明这里面的代码全是css代码，此时就没有必要再写&lt;style&gt;标签这几个字了。a.css的代码如下： 1234p{ border: 1px solid red; font-size: 40px;} 上方的css代码中，注意像素要带上px这个单位，不然不生效。然后我们在html文件中通过&lt;link&gt;标签引入这个css文件就行了。效果如下： 这里再讲一个补充的知识：&lt;link&gt;标签的rel属性：。其属性值有以下两种： stylesheet：定义的样式表 alternate stylesheet：候选的样式表 看字面意思可能比较难理解，我们来举个例子，一下子就明白了。举例： 现在我们来定义3个样式表： a.css：定义一个实线的黑色边框 12345div{ width: 200px; height: 200px; border: 3px solid black;} ba.css：蓝色的虚线边框 12345div{ width: 200px; height: 200px; border: 3px dotted blue;} c.css：来个背景图片 123456div{ width: 200px; height: 200px; border: 3px solid red; background-image: url(\"1.jpg\");} 然后我们在html文件中引用三个样式表： 123&lt;link rel = \"stylesheet\" type = \"text/css\" href = \"a.css\"&gt;&lt;/link&gt;&lt;link rel = \"alternate stylesheet\" type = \"text/css\" href = \"b.css\" title=\"第二种样式\"&gt;&lt;/link&gt;&lt;link rel = \"alternate stylesheet\" type = \"text/css\" href = \"c.css\" title=\"第三种样式\"&gt;&lt;/link&gt; 上面引入的三个样式表中，后面两个样式表作为备选。注意备选的样式表中，title属性不要忘记写，不然显示不出来效果的。现在来看一下效果：（在IE中打开网页） CSS的四种基本选择器CSS选择器：就是指定CSS要作用的标签，那个标签的名称就是选择器。意为：选择哪个容器。 CSS的选择器分为两大类：基本选择题和扩展选择器。 基本选择器： 标签选择器：针对一类标签 ID选择器：针对某一个特定的标签使用 类选择器：针对你想要的所有标签使用 通用选择器（通配符）：针对所有的标签都适用（不建议使用） 下面来分别讲一讲。 1、标签选择器：选择器的名字代表html页面上的标签标签选择器，选择的是页面上所有这种类型的标签，所以经常描述“共性”，无法描述某一个元素的“个性”。 举例： 123p{ font-size:14px;} 上方选择器的意思是说：所有的&lt;p&gt;标签里的内容都将显示14号字体。 效果： 再比如说，我想让“生命壹号学完了安卓，继续学前端哟”这句话中的“前端”两个变为红色字体，那么我可以用&lt;span&gt;标签把“前端”这两个字围起来，然后给&lt;span&gt;标签加一个标签选择器。 代码如下： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=\"text/css\"&gt; span{ color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;生命壹号学完了安卓，继续学&lt;span&gt;前端&lt;/span&gt;哟&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 【总结】需要注意的是： （1）所有的标签，都可以是选择器。比如ul、li、label、dt、dl、input。 （2）无论这个标签藏的多深，一定能够被选择上。 （3）选择的所有，而不是一个。 2、ID选择器：规定用#来定义针对某一个特定的标签来使用，只能使用一次。css中的ID选择器以”#”来定义。 举例： 123#mytitle{ border:3px dashed green;} 效果： id选择器的选择符是“#”。 任何的HTML标签都可以有id属性。表示这个标签的名字。这个标签的名字，可以任取，但是： （1）只能有字母、数字、下划线。 （2）必须以字母开头。 （3）不能和标签同名。比如id不能叫做body、img、a。 另外，特别强调的是：HTML页面，不能出现相同的id，哪怕他们不是一个类型。比如页面上有一个id为pp的p，一个id为pp的div，是非法的！ 一个标签可以被多个css选择器选择： 比如，我们可以同时让标签选择器和id选择器作用于同一个标签。如下： 然后我们通过网页的审查元素看一下效果： 现在，假设选择器冲突了，比如id选择器说这个文字是红色的，标签选择器说这个文字是绿色的。那么听谁的？实际上，css有着非常严格的计算公式，能够处理冲突. 一个标签可以被多个css选择器选择，共同作用，这就是“层叠式”的第一层含义（第一层含义和第二层含义，放到css基础的第三篇文章里讲）。 3、类选择器：规定用圆点.来定义、针对你想要的所有标签使用。优点：灵活。 css中用.来表示类。举例如下： 123.one{ width:800px;} 效果： 和id非常相似，任何的标签都可以携带id属性和class属性。class属性的特点： 特性1：类选择器可以被多种标签使用。 特性2：同一个标签可以使用多个类选择器。用空格隔开。举例如下：（正确） 1&lt;h3 class=\"teshu zhongyao\"&gt;我是一个h3啊&lt;/h3&gt; 初学者常见的错误，就是写成了两个class。举例如下：（错误） 1&lt;h3 class=\"teshu\" class=\"zhongyao\"&gt;我是一个h3啊&lt;/h3&gt; 类选择器使用的举例： 类选择器的使用，能够决定一个人的css水平。 比如，我们现在要做下面这样一个页面： 正确的思路，就是用所谓“公共类”的思路，就是我们类就是提供“公共服务”，比如有绿、大、线，一旦携带这个类名，就有相应的样式变化。对应css里的代码如下： 1234567891011&lt;style type=\"text/css\"&gt; .lv{ color: green; } .da{ font-size: 30px; } .underline{ text-decoration: underline; }&lt;/style&gt; 然后让每个标签去选取自己想要用的类选择器： 123 &lt;p class=\"lv da\"&gt;段落1&lt;/p&gt;&lt;p class=\"lv xian\"&gt;段落2&lt;/p&gt;&lt;p class=\"da xian\"&gt;段落3&lt;/p&gt; 也就是说： （1）不要去试图用一个类名，把某个标签的所有样式写完。这个标签要多携带几个类，共同完成这个标签的样式。 （2）每一个类要尽可能小，有“公共”的概念，能够让更多的标签使用。 问题：到底用id还是用class？ 答案：尽可能的用class，除非极特殊的情况可以用id。 原因：id是js用的。也就是说，js要通过id属性得到标签，所以css层面尽量不用id，要不然js就很别扭。另一层面，我们会认为一个有id的元素，有动态效果。 举例如下： 上图所示，css和js都在用同一个id，会出现不好沟通的情况。 我们记住这句话：类上样式，id上行为。意思是说，class属性交给css使用，id属性交给js使用。 上面这三种选择器的区别： 标签选择器针对的是页面上的一类标签。 ID选择器是只针对特定的标签(一个)，ID是此标签在此页面上的唯一标识。 类选择器可以被多种标签使用。 4、通配符*：匹配任何标签通用选择器，将匹配任何标签。不建议使用，IE有些版本不支持，大网站增加客户端负担。 效率不高，如果页面上的标签越多，效率越低，所以页面上不能出现这个选择器。 举例： 1234*{ margin-left:0px; margin-top:0px;} 效果： CSS的几种高级选择器高级选择器： 后代选择器：用空格隔开 交集选择器：选择器之间紧密相连 并集选择器（分组选择器）：用逗号隔开 伪类选择器 下面详细讲一下这几种高级（扩展）选择器。 1、后代选择器: 定义的时候用空格隔开对于E F这种格式，表示所有属于E元素后代的F元素，有这个样式。空格就表示后代。 后代选择器，就是一种平衡：共性、特性的平衡。当要把某一个部分的所有的什么，进行样式改变，就要想到后代选择器。 后代选择器，描述的是祖先结构。 看定义可能有点难理解，我们来看例子吧。 举例1： 12345&lt;style type=\"text/css\"&gt; .div1 p{ color:red; }&lt;/style&gt; 空格就表示后代。.div1 p 表示.div1的后代所有的p。 这里强调一下：这两个标签不一定是连续紧挨着的，只要保持一个后代的关联即可。也就是说，选择的是后代，不一定是儿子。 举例： 12345&lt;style type=\"text/css\"&gt; h3 b i{ color:red ; }&lt;/style&gt; 上方代码的意思是说：定义了&lt;h3&gt;标签中的&lt;b&gt;标签中的&lt;i&gt;标签的样式。同理：h3和b和i标签不一定是连续紧挨着的，只要保持一个后代的关联即可。 效果： 或者还有下面这种写法： 上面的这种写法，&lt;h3&gt;标签和&lt;i&gt;标签并不是紧挨着的，但他们保持着一种后代关系。 还有下面这种写法：（含类选择器、id选择器都是可以的） 我们在开头说了：后代选择器，描述的是一种祖先结构。我们举个例子来说明这句话： 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=\"text/css\"&gt; div div p{ color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;div class=\"div2\"&gt; &lt;div class=\"div3\"&gt; &lt;div class=\"div4\"&gt; &lt;p&gt;我是什么颜色？&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上面css中的div div p，也能使文字的颜色变红。通过浏览器的审查元素，我们可以看到 p元素的祖先列表： 讲到这里，我们再提一个sublme的快捷键。 在sublime中输入p#haha，按tab键后，会生成&lt;p id=&quot;haha&quot;&gt;&lt;/p&gt;。 在sublime中输入p.haha，按tab键后，会生成&lt;p class=&quot;haha&quot;&gt;&lt;/p&gt;。 2、交集选择器：定义的时候紧密相连定义交集选择器的时候，两个选择器之间紧密相连。一般是以标签名开头，比如div.haha，再比如p.special。 如果后一个选择器是类选择器，则写为div.special；如果后一个选择器id选择器，则写为div#special。 来看下面这张图就明白了： 123h3.special{ color:red;} 选择的元素要求同时满足两个条件：必须是h3标签，然后必须是special标签。 举例： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;交集选择器测试&lt;/title&gt; &lt;style type=\"text/css\"&gt; h3.special { color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h3 class=\"special zhongyao\"&gt;标题1&lt;/h3&gt; &lt;h3 class=\"special\"&gt;我也是标题&lt;/h3&gt; &lt;p&gt;我是段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 注意，交集选择器没有空格。所以，没有空格的div.red（交集选择器）和有空格的div .red（后代选择器）不是一个意思。 交集选择器可以连续交：（一般不要这么写） 123h3.special.zhongyao{ color:red;} 上面这种写法，是 IE7 开始兼容的，IE6 不兼容。 3、并集选择器：定义的时候用逗号隔开三种基本选择器都可以放进来。 举例： 123p,h1,#mytitle,.one{ color:red;} 效果： 一些 CSS3 选择器 所有的 CSS3 选择器，我们放在 CSS3 的内容里介绍。本文暂时先接触一部分。 浏览器的兼容性问题 我们可以用IETester这个软件测一下CSS在各个版本IE浏览器上的显示效果。 IE： 微软的浏览器，随着操作系统安装的。所以每个windows都有IE浏览器。各版本如下： windows xp 操作系统安装的IE6 windows vista 操作系统安装的IE7 windows 7 操作系统安装的IE8 windows 8 操作系统安装的IE9 windows10 操作系统安装的edge 浏览器兼容问题，要出，就基本上就是出在IE6、7身上，这两个浏览器是非常低级的浏览器。 为了测试浏览器CSS 3的兼容性，我们可以在网上搜”css3 机器猫”关键字，然后在不同的浏览器中打开如下链接： http://www1.pconline.com.cn/pcedu/specialtopic/css3-doraemon/ 测试结果如下： 我们可以在百度统计里查看浏览器的市场占有率： IE9 5.94% IE8 21.19% IE7 4.79% IE6 4.11% 我们可以在http://html5test.com/results/desktop.html中查看 我们要知道典型的IE6兼容问题（面试要问），但是做项目我们兼容到IE8即可。不解决IE8以下的兼容问题，目的在于：培养更高的兴趣和眼光，别天天的跟IE6较劲。 我们可以用「IETester」软件看看css在各个浏览器中的显示效果。 1.子代选择器，用符号&gt;表示 IE7开始兼容，IE6不兼容。 123div&gt;p{ color:red;} div的儿子p。和div的后代p的截然不同。 能够选择： 123&lt;div&gt; &lt;p&gt;我是div的儿子&lt;/p&gt;&lt;/div&gt; 不能选择： 1234567&lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;我是div的重孙子&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 2.序选择器 IE8开始兼容；IE6、7都不兼容 设置无序列表&lt;ul&gt;中的第一个&lt;li&gt;为红色： 12345&lt;style type=\"text/css\"&gt; ul li:first-child{ color:red; }&lt;/style&gt; 设置无序列表&lt;ul&gt;中的最后一个&lt;li&gt;为红色： 123ul li:last-child{ color:blue;} 序选择器还有更复杂的用法，以后再讲。 由于浏览器的更新需要过程，所以现在如果公司还要求兼容IE6、7，那么就要自己写类名： 123456789101112&lt;ul&gt; &lt;li class=\"first\"&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li class=\"last\"&gt;项目&lt;/li&gt;&lt;/ul&gt; 用类选择器来选择第一个或者最后一个： 1234567ul li.first{ color:red;}ul li.last{ color:blue;} 3.下一个兄弟选择器 IE7开始兼容，IE6不兼容。 +表示选择下一个兄弟 12345&lt;style type=\"text/css\"&gt; h3+p{ color:red; }&lt;/style&gt; 上方的选择器意思是：选择的是h3元素后面紧挨着的第一个兄弟。 12345678910111213 &lt;h3&gt;我是一个标题&lt;/h3&gt;&lt;p&gt;我是一个段落&lt;/p&gt;&lt;p&gt;我是一个段落&lt;/p&gt;&lt;p&gt;我是一个段落&lt;/p&gt;&lt;h3&gt;我是一个标题&lt;/h3&gt;&lt;p&gt;我是一个段落&lt;/p&gt;&lt;p&gt;我是一个段落&lt;/p&gt;&lt;p&gt;我是一个段落&lt;/p&gt;&lt;h3&gt;我是一个标题&lt;/h3&gt;&lt;p&gt;我是一个段落&lt;/p&gt;&lt;p&gt;我是一个段落&lt;/p&gt;&lt;p&gt;我是一个段落&lt;/p&gt;&lt;h3&gt;我是一个标题&lt;/h3&gt; 效果如下： 这种选择器作用不大。","link":"/2020/03/07/css/03-%E6%A0%B7%E5%BC%8F%E8%A1%A8%E5%92%8C%E9%80%89%E6%8B%A9%E5%99%A8/"},{"title":"02-css属性-背景属性","text":"background 的常见背景属性 前言来自 https://github.com/qianguyihao/Web 以下是正文。 background 的常见背景属性css2.1 中，常见的背景属性有以下几种：（经常用到，要记住） background-color:#ff99ff; 设置元素的背景颜色。 background-image:url(images/2.gif); 将图像设置为背景。 background-repeat: no-repeat; 设置背景图片是否重复及如何重复，默认平铺满。（重要） no-repeat不要平铺； repeat-x横向平铺； repeat-y纵向平铺。 background-position:center top; 设置背景图片在当前容器中的位置。 background-attachment:scroll; 设置背景图片是否跟着滚动条一起移动。属性值可以是：scroll（与fixed属性相反，默认属性）、fixed（背景就会被固定住，不会被滚动条滚走）。 另外还有一个综合属性叫做background，它的作用是：将上面的多个属性写在一个声明中。 CSS3 中，新增了一些background属性： background-origin background-clip 背景裁切 background-size 调整尺寸 多重背景 上面这几个属性经常用到，需要记住。现在我们逐个进行讲解。 background-color：背景颜色的表示方法css2.1 中，背景颜色的表示方法有三种：单词、rgb表示法、十六进制表示法。 比如红色可以有下面的三种表示方法： 123background-color: red;background-color: rgb(255,0,0);background-color: #ff0000; CSS3 中，有一种新的表示颜色的方式：RGBA或者HSLA。 RGBA、HSLA可应用于所有使用颜色的地方。 下面分别介绍。 用英语单词表示能够用英语单词来表述的颜色，都是简单颜色。比如红色、绿色等。代码举例： 1background-color: red; RGB 表示法RGB 表示三原色“红”red、“绿”green、“蓝”blue。 光学显示器中，每个像素都是由三原色的发光原件组成的，靠明亮度不同调成不同的颜色的。r、g、b的值，每个值的取值范围0~255，一共256个值。 比如红色： 1background-color: rgb(255,0,0); 黑色： 1background-color: rgb(0,0,0); 颜色可以叠加，比如黄色就是红色和绿色的叠加： 1background-color: rgb(255,255,0); RGBA 表示法123background-color: rgba(0, 0, 255, 0.3);border: 30px solid rgba(0, 255, 0, 0.3); 解释： RGBA 即：Red、Green、Blue、Alpha R、G、B 的取值范围是：0~255 十六进制表示法比如红色： 1background-color: #ff0000; PS:所有用#开头的值，都是16进制的。 这里，我们就要学会16进制与10进制之间的转换。下面举几个例子。 问：16进制中28等于10进制多少？答：2*16+8 = 40。 16进制中的af等于10进制多少？答：10 * 16 + 15 = 175 所以，#ff0000就等于rgb(255,0,0)。 background-color: #123456;等价于background-color: rgb(18,52,86); 十六进制可以简化为3位，所有#aabbcc的形式，能够简化为#abc。举例如下： 比如： 1background-color:#ff0000; 等价于： 1background-color:#f00; 比如： 1background-color:#112233; 等价于： 1background-color:#123; 但是，比如下面这个是无法简化的： 1background-color:#222333; 再比如，下面这个也是无法简化的： 1background-color:#123123; 几种常见的颜色简写可以记住。如下： 123456#000 黑#fff 白#f00 红#222 深灰#333 灰#ccc 浅灰 HSLA 表示法举例： 1background-color: hsla(240,50%,50%,0.4); 解释： H 色调，取值范围 0~360。0或360表示红色、120表示绿色、240表示蓝色。 S 饱和度，取值范围 0%~100%。值越大，越鲜艳。 L 亮度，取值范围 0%~100%。亮度最大时为白色，最小时为黑色。 A 透明度，取值范围 0~1。 如果不知道 H 的值该设置多少，我们不妨来看一下色盘： 推荐链接：配色宝典 关于设置透明度的其他方式： （1）opacity: 0.3; 会将整个盒子及子盒子设置透明度。也就是说，当盒子设置半透明的时候，会影响里面的子盒子。 （2）background: transparent; 可以单独设置透明度，但设置的是完全透明（不可调节透明度）。 background-repeat属性background-repeat:no-repeat;设置背景图片是否重复及如何重复，默认平铺满。属性值可以是： no-repeat（不要平铺） repeat-x（横向平铺） repeat-y（纵向平铺） 这个属性在开发的时候也是经常用到的。我们通过设置不同的属性值来看一下效果吧： （1）不加这个属性时：（即默认时）（背景图片会被平铺满） PS：padding的区域也是有背景图的。 （2）属性值为no-repeat（不要平铺）时： （3）属性值为repeat-x（横向平铺）时： 其实这种属性的作用还是很广的。举个例子，设计师设计一张宽度只有1px、颜色纵向渐变的图片，然后我们通过这个属性将其进行水平方向的平铺，就可以看到整个页面都是渐变的了。 在搜索引擎上搜“平铺背景”，就可以发现，周期性的图片可以采用此种方法进行平铺。 （4）属性值为repeat-y（纵向平铺）时： background-position属性background-position属性指的是背景定位属性。公式如下： 在描述属性值的时候，有两种方式：用像素描述、用单词描述。下面分别介绍。 1、用像素值描述属性值： 格式如下： 1background-position:向右偏移量 向下偏移量; 属性值可以是正数，也可以是负数。比如：100px 200px、-50px -120px。 举例如下： 2、用单词描述属性值： 格式如下： 1background-position: 描述左右的词 描述上下的词; 描述左右的词：left、center、right 描述上下的词：top 、center、bottom 比如说，right center表示将图片放到右边的中间；center center表示将图片放到正中间。 比如说，bottom表示图片的底边和父亲底边贴齐（好好理解）。 位置属性有很多使用场景的。我们来举两个例子。 场景1：（大背景图） 打开“暗黑3 台湾”的官网https://tw.battle.net/d3/zh/，可以看到官网的效果是比较炫的： 检查网页后，找到网站背景图片的url：https://tw.battle.net/d3/static/images/layout/bg-repeat.jpg。背景图如下： 实际上，我们是通过把这张图片作为网站的背景图来达到显示效果的。只需要给body标签加如下属性即可： 12345body{ background-image: url(/Users/smyhvae/Dropbox/img/20170812_1950.jpg); background-repeat: no-repeat; background-position: center top;} 上方代码中，如果没加background-position这个属性，背景图会默认处于浏览器的左上角（显得很丑）；加了此属性之后，图片在水平方向就位于浏览器的中间了。 场景2：（通栏banner） 很多网站的首页都会有banner图（网站最上方的全屏大图叫做「通栏banner」），这种图要求横向的宽度特别大。比如说，设计师给你一张1920*465的超大banner图，如果我们把这个banner图作为img标签直接插入网页中，会有问题的：首先，图片不在网页的中间；其次，肯定会出现横向滚动条。如下图所示： 正确的做法是，将banner图作为div的背景图，这样的话，背景图超出div的部分，会自动移溢出。需要给div设置的属性如下： 123456div{ height: 465px; background-image: url(http://img.smyhvae.com/20170813_1053.jpg); background-position: center top; background-repeat: no-repeat;} 上方代码中，我们给div设置height（高度为banner图的高度），不需要设置宽度（因为宽度会自动霸占整行）。效果如下： 上图可以看出，将banner图作为div的背景后，banner图会永远处于网页的正中间（水平方向来看）。 background-attachment 属性 background-attachment:scroll; 设置背景图片是否固定。属性值可以是： fixed（背景就会被固定住，不会被滚动条滚走）。 scroll（与fixed属性相反，默认属性） background-attachment:fixed;的效果如下： background 综合属性background属性和border一样，是一个综合属性，可以将多个属性写在一起。(在盒子模型这篇文章中专门讲到border) 举例1: 1background:red url(1.jpg) no-repeat 100px 100px fixed; 等价于： 12345background-color:red;background-image:url(1.jpg);background-repeat:no-repeat;background-position:100px 100px;background-attachment:fixed; 以后，我们可以用小属性层叠掉大属性。 上面的属性中，可以任意省略其中的一部分。 比如说，对于下面这样的属性： 1background: blue url(images/wuyifan.jpg) no-repeat 100px 100px; 效果如下： background-size属性：背景尺寸background-size属性：设置背景图片的尺寸。 格式举例： 12345678910111213/* 宽、高的具体数值 */background-size: 500px 500px;/* 宽高的百分比（相对于容器的大小） */background-size: 50% 50%; // 如果两个属性值相同，可以简写成：background-size: 50%;background-size: 100% auto; //这个属性可以自己试验一下。/* cover：图片始终填充满容器，且保证长宽比不变。图片如果有超出部分，则超出部分会被隐藏。 */background-size: cover;/* contain：将图片完整地显示在容器中，且保证长宽比不变。可能会导致容器的部分区域为空白。 */background-size: contain; 这里我们对属性值 cover 和 contain 进行再次强调： cover：图片始终填充满容器，且保证长宽比不变。图片如果有超出部分，则超出部分会被隐藏。 contain：将图片完整地显示在容器中，且保证长宽比不变。可能会导致容器的部分区域留白。 代码举例：（这张图片本身的尺寸是 1080 * 1350） 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .img_wrap { display: flex; } .img { width: 200px; height: 200px; border:1px solid red; background: url(http://img.smyhvae.com/20191006_1330.jpg) no-repeat; margin-right: 20px; } .div1 { background-size: cover; } .div2{ background-size: contain; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class=\"img_wrap\"&gt; &lt;div class=\"img div1\"&gt;&lt;/div&gt; &lt;div class=\"img div2\"&gt;&lt;/div&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 在上方代码的基础之上，再加一个 background-position: center属性之后，图片就会在容器里居中显示： 背景原点：background-origin 属性background-origin 属性：控制背景从什么地方开始显示。 格式举例： 123456789/* 从 padding-box 内边距开始显示背景图 */background-origin: padding-box; //默认值/* 从 border-box 边框开始显示背景图 */background-origin: border-box;/* 从 content-box 内容区域开始显示背景图 */background-origin: content-box; 如果属性值设置成了border-box，那边框部分也会显示图片哦。 如下图所示： background-clip属性：设置元素的背景（背景图片或颜色）是否延伸到边框下面格式举例： background-clip: content-box; 超出的部分，将裁剪掉。属性值可以是： border-box 超出 border-box 的部分，将裁剪掉 padding-box 超出 padding-box 的部分，将裁剪掉 content-box 超出 content-box 的部分，将裁剪掉 假设现在有这样的属性设置： 123background-origin: border-box;background-clip: content-box; 上方代码的意思是，背景图片从边框部分开始加载，但是呢，超出内容区域的部分将被裁减掉。 同时设置多个背景我们可以给一个盒子同时设置多个背景，用以逗号隔开即可。可用于自适应局。 代码举例： 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box { height: 416px; border: 1px solid #000; margin: 100px auto; /* 给盒子加多个背景，按照背景语法格式书写，多个背景使用逗号隔开 */ background: url(images/bg1.png) no-repeat left top, url(images/bg2.png) no-repeat right top, url(images/bg3.png) no-repeat right bottom, url(images/bg4.png) no-repeat left bottom, url(images/bg5.png) no-repeat center; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 实现效果如下： 上方代码中，我们其实给盒子设置了五张小图，拼成的一张大图。当改变浏览器窗口大小时，可以自适应布局。 渐变：background-image渐变是CSS3当中比较丰富多彩的一个特性，通过渐变我们可以实现许多炫丽的效果，有效的减少图片的使用数量，并且具有很强的适应性和可扩展性。 渐变分为： 线性渐变：沿着某条直线朝一个方向产生渐变效果。 径向渐变：从一个中心点开始沿着四周产生渐变效果。 重复渐变。 见下图： 线性渐变格式： 1234background-image: linear-gradient(方向, 起始颜色, 终止颜色);background-image: linear-gradient(to right, yellow, green); 参数解释： 方向可以是：to left、to right、to top、to bottom、角度30deg（指的是顺时针方向30°）。 格式举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div { width: 500px; height: 100px; margin: 10px auto; border: 1px solid #000; } /* 语法： linear-gradient(方向，起始颜色，终止颜色); 方向：to left to right to top to bottom 角度 30deg 起始颜色 终止颜色 */ div:nth-child(1) { background-image: linear-gradient(to right, yellow, green); } /* 不写方向，表示默认的方向是：从上往下 */ div:nth-child(2) { background-image: linear-gradient(yellow, green); } /* 方向可以指定角度 */ div:nth-child(3) { width: 100px; height: 100px; background-image: linear-gradient(135deg, yellow, green); } /* 0%的位置开始出现黄色，40%的位置开始出现红色的过度。70%的位置开始出现绿色的过度，100%的位置开始出现蓝色 */ div:nth-child(4) { background-image: linear-gradient(to right, yellow 0%, red 40%, green 70%, blue 100%); } /* 颜色之间，出现突变 */ div:nth-child(5) { background-image: linear-gradient(45deg, yellow 0%, yellow 25%, blue 25%, blue 50%, red 50%, red 75%, green 75%, green 100% ); } div:nth-child(6) { background-image: linear-gradient(to right, #000 0%, #000 25%, #fff 25%, #fff 50%, #000 50%, #000 75%, #fff 75%, #fff 100% ); } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 举例：按钮 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;CSS3 渐变&lt;/title&gt; &lt;style&gt; html, body { height: 100%; } body { margin: 0; padding: 0; background-color: #f8fcd4; } .nav { width: 800px; text-align: center; padding-top: 50px; margin: 0 auto; } /*设置按钮基本样式*/ .nav a { display: inline-block; width: 100px; height: 30px; text-align: center; line-height: 30px; font-size: 14px; color: #fff; text-decoration: none; border: 1px solid #e59500; background-color: #FFB700; background-image: linear-gradient( to bottom, #FFB700 0%, #FF8C00 100% ); } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"nav\"&gt; &lt;a href=\"javascript:;\"&gt;导航1&lt;/a&gt; &lt;a href=\"javascript:;\"&gt;导航2&lt;/a&gt; &lt;a href=\"javascript:;\"&gt;导航3&lt;/a&gt; &lt;a href=\"javascript:;\"&gt;导航4&lt;/a&gt; &lt;a href=\"javascript:;\"&gt;导航5&lt;/a&gt; &lt;a href=\"javascript:;\"&gt;导航6&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果： 径向渐变格式： 123background-image: radial-gradient(辐射的半径大小, 中心的位置, 起始颜色, 终止颜色);background-image: radial-gradient(100px at center,yellow ,green); 解释：围绕中心点做渐变，半径是150px，从黄色到绿色做渐变。 中心点的位置可以是：at left right center bottom top。如果以像素为单位，则中心点参照的是盒子的左上角。 当然，还有其他的各种参数。格式举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div { width: 250px; height: 250px; border: 1px solid #000; margin: 20px; float: left; } /* 径向渐变： radial-gradient（辐射的半径大小, 中心的位置，起始颜色，终止颜色）; 中心点位置：at left right center bottom top */ /*辐射半径为100px，中心点在中间*/ div:nth-child(1) { background-image: radial-gradient(100px at center, yellow, green); } /*中心点在左上角*/ div:nth-child(3) { background-image: radial-gradient(at left top, yellow, green); } div:nth-child(2) { background-image: radial-gradient(at 50px 50px, yellow, green); } /*设置不同的颜色渐变*/ div:nth-child(4) { background-image: radial-gradient(100px at center, yellow 0%, green 30%, blue 60%, red 100%); } /*如果辐射半径的宽高不同，那就是椭圆*/ div:nth-child(5) { background-image: radial-gradient(100px 50px at center, yellow, green); } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"box\"&gt;&lt;/div&gt;&lt;div class=\"box\"&gt;&lt;/div&gt;&lt;div class=\"box\"&gt;&lt;/div&gt;&lt;div class=\"box\"&gt;&lt;/div&gt;&lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 举例：利用径向渐变和边框圆角的属性，生成按钮。代码如下： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;CSS3 渐变&lt;/title&gt; &lt;style&gt; div:nth-child(1) { width: 200px; height: 200px; margin: 40px auto; border-radius: 100px; background-color: yellowgreen; } div:nth-child(2) { width: 200px; height: 200px; margin: 40px auto; border-radius: 100px; background-color: yellowgreen; background-image: radial-gradient( 200px at 100px 100px, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.5) ); } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上图中，给第二个div设置的透明度是从0到0.5。如果设置的透明度是从0到0，则样式无变化，和第一个div一样。如果设置的透明度是从1到1，则盒子是全黑的。 clip-path：裁剪出元素的部分区域做展示clip-path属性可以创建一个只有元素的部分区域可以显示的剪切区域。区域内的部分显示，区域外的隐藏。 虽然clip-path不是背景属性，但这个属性非常强大，但往往会结合背景属性一起使用，达到一些效果。 举例：（鼠标悬停时，放大裁剪的区域） 123456789101112131415.div1 { width: 320px; height: 320px; border: 1px solid red; background: url(http://img.smyhvae.com/20191006_1410.png) no-repeat; background-size: cover; /* 裁剪出圆形区域 */ clip-path: circle(50px at 100px 100px); transition: clip-path .4s;}.div1:hover{ /* 鼠标悬停时，裁剪出更大的圆形 */ clip-path: circle(80px at 100px 100px);} clip-path属性的好处是，即使做了任何裁剪，容器的占位大小是不变的。比如上方代码中，容器的占位大小一直都是 320px * 320px。这样的话，也方便我们做一些动画效果。 clip-path: polygon()举例： 另外，通过 clip-path: (svg) 可以导入svg矢量图，实现 iOS图标的圆角。这里就不详细展开了。","link":"/2020/03/06/css/02-css%E5%B1%9E%E6%80%A7-%E8%83%8C%E6%99%AF%E5%B1%9E%E6%80%A7/"},{"title":"05-CSS盒模型详解（重点）","text":"前言盒子模型，英文即box model。无论是div、span、还是a都是盒子。 但是，图片、表单元素一律看作是文本，它们并不是盒子。这个很好理解，比如说，一张图片里并不能放东西，它自己就是自己的内容。 前言来自 https://github.com/qianguyihao/Web 盒子模型盒子中的区域一个盒子中主要的属性就5个：width、height、padding、border、margin。如下： width和height：内容的宽度、高度（不是盒子的宽度、高度）。 padding：内边距。 border：边框。 margin：外边距。 盒子模型的示意图： 代码演示： 上面这个盒子，width:200px; height:200px; 但是真实占有的宽高是302*302。 这是因为还要加上padding、border。 注意：宽度和真实占有宽度，不是一个概念！来看下面这例子。 标准盒模型和IE盒模型 我们目前所学习的知识中，以标准盒子模型为准。 标准盒子模型： IE盒子模型： 上图显示： 在 CSS 盒子模型 (Box Model) 规定了元素处理元素的几种方式： width和height：内容的宽度、高度（不是盒子的宽度、高度）。 padding：内边距。 border：边框。 margin：外边距。 CSS盒模型和IE盒模型的区别： 在 标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。 IE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。 注：Android中也有margin和padding的概念，意思是差不多的，如果你会一点Android，应该比较好理解吧。区别在于，Android中没有border这个东西，而且在Android中，margin并不是控件的一部分，我觉得这样做更合理一些，呵呵。 &lt;body&gt;标签也有margin&lt;body&gt;标签有必要强调一下。很多人以为&lt;body&gt;标签占据的是整个页面的全部区域，其实是错误的，正确的理解是这样的：整个网页最大的盒子是&lt;document&gt;，即浏览器。而&lt;body&gt;是&lt;document&gt;的儿子。浏览器给&lt;body&gt;默认的margin大小是8个像素，此时&lt;body&gt;占据了整个页面的一大部分区域，而不是全部区域。来看一段代码。 1234567891011121314151617181920212223242526272829303132&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"Generator\" content=\"EditPlus®\"&gt; &lt;meta name=\"Author\" content=\"\"&gt; &lt;meta name=\"Keywords\" content=\"\"&gt; &lt;meta name=\"Description\" content=\"\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=\"text/css\"&gt; div{ width: 100px; height: 100px; border: 1px solid red; padding: 20px; margin: 30px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;有生之年&lt;/div&gt; &lt;div&gt;狭路相逢&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 上面的代码中，我们对div标签设置了边距等信息。打开google浏览器，按住F12，显示效果如下： 认识width、height一定要知道，在前端开发工程师眼中，世界中的一切都是不同的。 比如说，丈量稿纸，前端开发工程师只会丈量内容宽度： 下面这两个盒子，真实占有宽高，都是302*302： 盒子1： 123456.box1{ width: 100px; height: 100px; padding: 100px; border: 1px solid red;} 盒子2： 123456.box2{ width: 250px; height: 250px; padding: 25px; border: 1px solid red;} 真实占有宽度 = 左border + 左padding + width + 右padding + 右border 上面这两个盒子的盒模型图如下： 如果想保持一个盒子的真实占有宽度不变，那么加width的时候就要减padding。加padding的时候就要减width。因为盒子变胖了是灾难性的，这会把别的盒子挤下去。 认识paddingpadding区域也有颜色padding就是内边距。padding的区域有背景颜色，css2.1前提下，并且背景颜色一定和内容区域的相同。也就是说，background-color将填充所有border以内的区域。 效果如下： padding有四个方向padding是4个方向的，所以我们能够分别描述4个方向的padding。 方法有两种，第一种写小属性；第二种写综合属性，用空格隔开。 小属性的写法： 1234padding-top: 30px;padding-right: 20px;padding-bottom: 40px;padding-left: 100px; 综合属性的写法：(上、右、下、左)（顺时针方向，用空格隔开。margin的道理也是一样的） 1padding:30px 20px 40px 100px; 如果写了四个值，则顺序为：上、右、下、左。 如果只写了三个值，则顺序为：上、右、下。??和右一样。 如果只写了两个值，比如说： 1padding: 30px 40px; 则顺序等价于：30px 40px 30px 40px; 要懂得，用小属性层叠大属性。比如： 12padding: 20px;padding-left: 30px; 上面的padding对应盒子模型为： 下面的写法： 12padding-left: 30px;padding: 20px; 第一行的小属性无效，因为被第二行的大属性层叠掉了。 下面的题，会做了，说明你明白了。 一些题目题目1：说出下面盒子真实占有宽高，并画出盒模型图。 1234567div{ width: 200px; height: 200px; padding: 10px 20px 30px; padding-right: 40px; border: 1px solid #000;} 答案： 题目2：说出下面盒子真实占有宽高，并画出盒模型图。 123456789div{ width: 200px; height: 200px; padding-left: 10px; padding-right: 20px; padding:40px 50px 60px; padding-bottom: 30px; border: 1px solid #000;} 答案： padding-left:10px； 和padding-right:20px; 没用，因为后面的padding大属性，层叠掉了他们。 盒子模型如下： 题目3：现在给你一个盒子模型图，请写出代码，试着用最最简单的方法写。 答案： 1234width:123px;height:123px;padding:20px 40px;border:1px solid red; 题目4：现在给你一个盒子模型图，请写出代码，试着用最最简单的方法写。 答案： 12345width:123px;height:123px;padding:20px;padding-right:40px;border:1px solid red; 一些元素，默认带有padding一些元素，默认带有padding，比如ul标签。如下： 上图显示，不加任何样式的ul，也是有40px的padding-left。 所以，我们做站的时候，为了便于控制，总是喜欢清除这个默认的padding。 可以使用*进行清除： 1234*{ margin: 0; padding: 0;} 但是，*的效率不高，所以我们使用并集选择器，罗列所有的标签（不用背，有专业的清除默认样式的样式表，今后学习）： 1234body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td{ margin:0; padding:0;} 认识borderborder就是边框。边框有三个要素：像素（粗细）、线型、颜色。 比如： 123456.div1{ width: 10px; height: 10px; border: 2px solid red;} 颜色如果不写，默认是黑色。另外两个属性如果不写，则无法显示边框。 border-styleborder的所有的线型如下：（我们可以通过查看CSS参考手册得到） 比如border:10px ridge red;这个属性，在chrome和firefox、IE中有细微差别：（因为可以显示出效果，因此并不是兼容性问题，只是有细微差别而已） 如果公司里面的设计师是处女座的，追求极高的页面还原度，那么不能使用css来制作边框。就要用到图片，就要切图了。 所以，比较稳定的border-style就几个：solid、dashed、dotted。 border拆分border是一个大综合属性。比如说： 1border:1px solid red; 就是把上下左右这四个方向的边框，都设置为 1px 宽度、线型实线、red颜色。 PS：小技巧：在sublime text中，为了快速输入border:1px solid red;这个属性，可以直接输入bd，然后选第二个后回车。 border属性是能够被拆开的，有两大种拆开的方式： （1）按三要素拆开：border-width、border-style、border-color。（一个border属性是由三个小属性综合而成的） （2）按方向拆开：border-top、border-right、border-bottom、border-left。 现在我们明白了：一个border属性，是由三个小属性综合而成的。如果某一个小属性后面是空格隔开的多个值，那么就是上右下左的顺序。举例如下： 123border-width:10px 20px;border-style:solid dashed dotted;border-color:red green blue yellow; 效果如下： （1）按三要素拆： 123border-width:10px; //边框宽度border-style:solid; //线型border-color:red; //颜色。 等价于： 1border:10px solid red; (2)按方向来拆： 1234border-top:10px solid red;border-right:10px solid red;border-bottom:10px solid red;border-left:10px solid red; 等价于： 1border:10px solid red; （3）按三要素和方向来拆：(就是把每个方向的，每个要素拆开。3*4 = 12) 123456789101112border-top-width:10px;border-top-style:solid;border-top-color:red;border-right-width:10px;border-right-style:solid;border-right-color:red;border-bottom-width:10px;border-bottom-style:solid;border-bottom-color:red;border-left-width:10px;border-left-style:solid;border-left-color:red; 等价于： 1border:10px solid red; 工作中到底用什么？很简答：什么简单用什么。但要懂得，用小属性层叠大属性。举例如下： 为了实现上方效果，写法如下： 12border:10px solid red;border-right-color:blue; 为了实现上方效果，写法如下： 12border:10px solid red;border-style:solid dashed; border可以没有： 1border:none; 可以某一条边没有： 1border-left: none; 也可以调整左边边框的宽度为0： 1border-left-width: 0; border-image 属性比如： 1border-image: url(.img.png) 30 round; 这个属性在实际开发中用得不多，暂时忽略。 举例1：利用 border 属性画一个三角形（小技巧）完整代码如下： 1234567div{ width: 0; height: 0; border: 50px solid transparent; border-top-color: red; border-bottom: none;} 步骤如下： （1）当我们设置盒子的width和height为0时，此时效果如下： （2）然后将border的底部取消： （3）最后设置border的左边和右边为白色或者透明： 这样，一个三角形就画好了。 举例2：利用 border 属性画一个三角形（更推荐的技巧）上面的例子1中，画出来的是直角三角形，可如果我想画等边三角形，要怎么做呢？ 完整代码如下：（用 css 画等边三角形） 12345678.div1{ width: 0; height: 0; border-top: 30px solid red; /* 通过改变 border-left 和 border-right 中的像素值，来改变三角形的形状 */ border-left: 20px solid transparent; border-right: 20px solid transparent;} 效果如下： 另外，我们在上方代码的基础之上，再加一个 border-radus: 20px; 就能画出一个扇形。","link":"/2020/03/08/css/05-CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89/"},{"title":"07-CSS定位","text":"CSS的定位属性有三种，分别是绝对定位、相对定位、固定定位。 12345position: absolute; &lt;!-- 绝对定位 --&gt;position: relative; &lt;!-- 相对定位 --&gt;position: fixed; &lt;!-- 固定定位 --&gt; 前言来自 https://github.com/qianguyihao/Web 下面逐一介绍。 相对定位相对定位：让元素相对于自己原来的位置，进行位置调整（可用于盒子的位置微调）。 我们之前学习的背景属性中，是通过如下格式： 1background-position:向右偏移量 向下偏移量; 但这回的定位属性，是通过如下格式： 123position: relative;left: 50px;top: 50px; 相对定位的举例： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"Generator\" content=\"EditPlus®\"&gt; &lt;meta name=\"Author\" content=\"\"&gt; &lt;meta name=\"Keywords\" content=\"\"&gt; &lt;meta name=\"Description\" content=\"\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=\"text/css\"&gt; body{ margin: 0px; } .div1{ width: 200px; height: 200px; border: 1px solid red; } .div2{ position: relative;/*相对定位：相对于自己原来的位置*/ left: 50px;/*横坐标：正值表示向右偏移，负值表示向左偏移*/ top: 50px;/*纵坐标：正值表示向下偏移，负值表示向上偏移*/ width: 200px; height: 200px; border: 1px solid red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"div1\"&gt;有生之年&lt;/div&gt; &lt;div class=\"div2\"&gt;狭路相逢&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 效果： 相对定位不脱标相对定位：不脱标，老家留坑，别人不会把它的位置挤走。 也就是说，相对定位的真实位置还在老家，只不过影子出去了，可以到处飘。 相对定位的用途如果想做“压盖”效果（把一个div放到另一个div之上），我们一般不用相对定位来做。相对定位，就两个作用： （1）微调元素 （2）做绝对定位的参考，子绝父相 相对定位的定位值 left：盒子右移 right：盒子左移 top：盒子下移 bottom：盒子上移 PS：负数表示相反的方向。 ↘： 123position: relative;left: 40px;top: 10px; ↙： 123position: relative;right: 100px;top: 100px; ↖： 123position: relative;right: 100px;bottom: 100px; ↗： 123position: relative;left: 200px;bottom: 200px; 如果要描述上面这张图的方向，我们可以首先可以这样描述： 123position: relative;left: 200px;top: 100px; 因为left: 200px等价于right: -200px，所以这张图其实有四种写法。 绝对定位绝对定位：定义横纵坐标。原点在父容器的左上角或左下角。横坐标用left表示，纵坐标用top或者bottom表示。 格式举例如下： 123position: absolute; /*绝对定位*/left: 10px; /*横坐标*/top/bottom: 20px; /*纵坐标*/ 绝对定位脱标绝对定位的盒子脱离了标准文档流。 所以，所有的标准文档流的性质，绝对定位之后都不遵守了。 绝对定位之后，标签就不区分所谓的行内元素、块级元素了，不需要display:block就可以设置宽、高了。 绝对定位的参考点（重要）（1）如果用top描述，那么参考点就是页面的左上角，而不是浏览器的左上角： （2）如果用bottom描述，那么参考点就是浏览器首屏窗口尺寸（好好理解“首屏”二字），对应的页面的左下角： 为了理解“首屏”二字的含义，我们来看一下动态图： 问题： 答案： 用bottom的定位的时候，参考的是浏览器首屏大小对应的页面左下角。 以盒子为参考点一个绝对定位的元素，如果父辈元素中也出现了已定位（无论是绝对定位、相对定位，还是固定定位）的元素，那么将以父辈这个元素，为参考点。 如下：（子绝父相） 以下几点需要注意。 （1） 要听最近的已经定位的祖先元素的，不一定是父亲，可能是爷爷： 12345&lt;div class=&quot;box1&quot;&gt; 相对定位 &lt;div class=&quot;box2&quot;&gt; 没有定位 &lt;p&gt;&lt;/p&gt; 绝对定位，将以box1为参考，因为box2没有定位，box1就是最近的父辈元素 &lt;/div&gt;&lt;/div&gt; 再比如： 12345&lt;div class=&quot;box1&quot;&gt; 相对定位 &lt;div class=&quot;box2&quot;&gt; 相对定位 &lt;p&gt;&lt;/p&gt; 绝对定位，将以box2为参考，因为box2是自己最近的父辈元素 &lt;/div&gt;&lt;/div&gt; （2）不一定是相对定位，任何定位，都可以作为儿子的参考点： 子绝父绝、子绝父相、子绝父固，都是可以给儿子定位的。但是在工程上，如果子绝、父绝，没有一个盒子在标准流里面了，所以页面就不稳固，没有任何实战用途。 工程应用： “子绝父相”有意义：这样可以保证父亲没有脱标，儿子脱标在父亲的范围里面移动。于是，工程上经常这样做： 父亲浮动，设置相对定位（零偏移），然后让儿子绝对定位一定的距离。 （3）绝对定位的儿子，无视参考的那个盒子的padding： 下图中，绿色部分是父亲div的padding，蓝色部分p是div的内容区域。此时，如果div相对定位，p绝对定位，那么，p将无视父亲的padding，在border内侧为参考点，进行定位： 工程应用： 绝对定位非常适合用来做“压盖”效果。我们来举个lagou.com上的例子。 现在有如下两张图片素材： 要求作出如下效果： 代码实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=\"text/css\"&gt; .box{ margin: 100px; width: 308px; height: 307px; border: 1px solid #FF7E00; position: relative; /*子绝父相*/ } .box .image img{ width: 308px; height: 196px; } .box .dtc{ display: block; /*转为块级元素，才能设置span的宽高*/ width: 52px; height: 28px; background-image: url(http://img.smyhvae.com/20180116_1115.png); background-position: -108px 0px; /*这里用到了精灵图*/ position: absolute; /*采用绝对定位的方式，将精灵图盖在最上层*/ top: -9px; left: 13px; } .box h4{ background-color: black; color: white; width:308px; height: 40px; line-height: 40px; position: absolute; top: 156px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt; &lt;span class=\"dtc\"&gt;&lt;/span&gt; &lt;div class=\"image\"&gt; &lt;img src=\"http://img.smyhvae.com/20180116_1116.jpg\" alt=\"\"&gt; &lt;/div&gt; &lt;h4&gt;广东深圳宝安区建安一路海雅缤纷城4楼&lt;/h3&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 代码解释如下： 为了显示“多套餐”那个小图，我们需要用到精灵图。 “多套餐”下方黑色背景的文字都是通过“子绝父相”的方式的盖在大海报image的上方的。 代码的效果如下： 让绝对定位中的盒子在父亲里居中我们知道，如果想让一个标准流中的盒子在父亲里居中（水平方向看），可以将其设置margin: 0 auto属性。 可如果盒子是绝对定位的，此时已经脱标了，如果还想让其居中（位于父亲的正中间），可以这样做： 12345678div { width: 600px; height: 60px; position: absolute; 绝对定位的盒子 left: 50%; 首先，让左边线居中 top: 0; margin-left: -300px; 然后，向左移动宽度（600px）的一半} 如上方代码所示，我们先让这个宽度为600px的盒子，左边线居中，然后向左移动宽度（600px）的一半，就达到效果了。 我们可以总结成一个公式： left:50%; margin-left:负的宽度的一半 固定定位固定定位：就是相对浏览器窗口进行定位。无论页面如何滚动，这个盒子显示的位置不变。 备注：IE6不兼容。 用途1：网页右下角的“返回到顶部” 比如我们经常看到的网页右下角显示的“返回到顶部”，就可以固定定位。 1234567891011121314&lt;style type=\"text/css\"&gt; .backtop{ position: fixed; bottom: 100px; right: 30px; width: 60px; height: 60px; background-color: gray; text-align: center; line-height:30px; color:white; text-decoration: none; /*去掉超链接的下划线*/ }&lt;/style&gt; 用途2：顶部导航条 我们经常能看到固定在网页顶端的导航条，可以用固定定位来做。 需要注意的是，假设顶部导航条的高度是60px，那么，为了防止其他的内容被导航条覆盖，我们要给body标签设置60px的padding-top。 顶部导航条的实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\"&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=\"text/css\"&gt; *{ margin: 0; padding: 0; }body{ /*为什么要写这个？*/ /*不希望我们的页面被nav挡住*/ padding-top: 60px; /*IE6不兼容固定定位，所以这个padding没有什么用，就去掉就行了*/ _padding-top:0; } .nav{ position: fixed; top: 0; left: 0; width: 100%; height: 60px; background-color: #333; z-index: 99999999; } .inner_c{ width: 1000px; height: 60px; margin: 0 auto; } .inner_c ul{ list-style: none; } .inner_c ul li{ float: left; width: 100px; height: 60px; text-align: center; line-height: 60px; } .inner_c ul li a{ display: block; width: 100px; height: 60px; color:white; text-decoration: none; } .inner_c ul li a:hover{ background-color: gold; } p{ font-size: 30px; } .btn{ display: block; width: 120px; height: 30px; background-color: orange; position: relative; top: 2px; left: 1px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"nav\"&gt; &lt;div class=\"inner_c\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5、z-index属性：z-index属性：表示谁压着谁。数值大的压盖住数值小的。 有如下特性： （1）属性值大的位于上层，属性值小的位于下层。 （2）z-index值没有单位，就是一个正整数。默认的z-index值是0。 （3）如果大家都没有z-index值，或者z-index值一样，那么在HTML代码里写在后面，谁就在上面能压住别人。定位了的元素，永远能够压住没有定位的元素。 （4）只有定位了的元素，才能有z-index值。也就是说，不管相对定位、绝对定位、固定定位，都可以使用z-index值。而浮动的元素不能用。 （5）从父现象：父亲怂了，儿子再牛逼也没用。意思是，如果父亲1比父亲2大，那么，即使儿子1比儿子2小，儿子1也能在最上层。 针对（1）（2）（3）条，举例如下： 这是默认情况下的例子：（div2在上层，div1在下层） 现在加一个z-index属性，要求效果如下： 第五条分析： z-index属性的应用还是很广泛的。当好几个已定位的标签出现覆盖的现象时，我们可以用这个z-index属性决定，谁处于最上方。也就是层级的应用。 层级： （1）必须有定位（除去static） （2）用z-index来控制层级数。","link":"/2020/03/08/css/07-CSS%E5%AE%9A%E4%BD%8D/"},{"title":"div&&css相对定位和绝对定位用法讲解","text":"css定位用法讲解 CSS relative相对定位设置为相对定位的元素框会偏移某个距离。元素仍然保持其未定位前的形状，它原本所占的空间仍保留。 CSS 相对定位相对定位是一个非常容易掌握的概念。如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。 如果将 top 设置为 20px，那么框将在原位置顶部下面 20 像素的地方。如果 left 设置为 30 像素，那么会在元素左边创建 30 像素的空间，也就是将元素向右移动。 12345#main_relative { position: relative; left: 30px; top: 20px; } 注意，在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 css position 绝对定位注意： 设置为绝对定位的元素框从文档流完全删除，并相对于其包含块定位，包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。绝对定位使元素的位置与文档流无关，因此不占据空间。这一点与相对定位不同，相对定位实际上被看作普通流定位模型的一部分，因为元素的位置相对于它在普通流中的位置。普通流中其它元素的布局就像绝对定位的元素不存在一样： 12345#main_relative { position: relative; left: 30px; top: 20px; } 绝对定位的元素的位置相对于最近的已定位祖先元素，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块。 对于定位的主要问题是要记住每种定位的意义。所以，现在让我们复习一下学过的知识吧：相对定位是“相对于”元素在文档中的初始位置，而绝对定位是“相对于”最近的已定位祖先元素，如果不存在已定位的祖先元素，那么“相对于”最初的包含块。 注释：根据用户代理的不同，最初的包含块可能是画布或 HTML 元素。","link":"/2020/02/27/html/div%E3%80%81css%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D%E5%92%8C%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E7%94%A8%E6%B3%95%E5%AE%9E%E4%BE%8B%E8%AF%A6%E8%A7%A3/"},{"title":"html-标签图文3","text":"本文主要内容 列表标签：&lt;ul&gt;、&lt;ol&gt;、&lt;dl&gt; 表格标签：&lt;table&gt; 框架标签及内嵌框架&lt;iframe&gt; 表单标签：&lt;form&gt; 多媒体标签 滚动字幕标签：&lt;marquee&gt; 前言来自 https://github.com/qianguyihao/Web 列表标签列表标签分为三种。 1、无序列表&lt;ul&gt;，无序列表中的每一项是&lt;li&gt;英文单词解释如下： ul：unordered list，“无序列表”的意思。 li：list item，“列表项”的意思。 例如： 12345&lt;ul&gt; &lt;li&gt;默认1&lt;/li&gt; &lt;li&gt;默认2&lt;/li&gt; &lt;li&gt;默认3&lt;/li&gt;&lt;/ul&gt; 效果： 注意： li不能单独存在，必须包裹在ul里面；反过来说，ul的“儿子”不能是别的东西，只能有li。 我们这里再次强调，ul的作用，并不是给文字增加小圆点的，而是增加无序列表的“语义”的。 属性： type=&quot;属性值&quot;。属性值可以选： disc(实心原点，默认)，square(实心方点)，circle(空心圆)。效果如下： 不光是&lt;ul&gt;标签有type属性，&lt;ul&gt;里面的&lt;li&gt;标签也有type属性（虽然说这种写法很少见）。效果如下： 注意：项目符号可以是图片，需要通过CSS设置&lt;li&gt;标记的背景图片来实现(CSS中讲)。 当然了，列表之间是可以嵌套的。我们来举个例子。代码： 1234567891011121314151617 &lt;ul&gt;&lt;li&gt;&lt;b&gt;北京市&lt;/b&gt; &lt;ul&gt; &lt;li&gt;海淀区&lt;/li&gt; &lt;li&gt;朝阳区&lt;/li&gt; &lt;li&gt;东城区&lt;/li&gt; &lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;广州市&lt;/b&gt; &lt;ul&gt; &lt;li&gt;天河区&lt;/li&gt; &lt;li&gt;越秀区&lt;/li&gt; &lt;/ul&gt;&lt;/li&gt; &lt;/ul&gt; 效果： css 属性： 1list-style-position: inside /* 给 ul 设置这个属性后，将小圆点包含在 li 元素的内部 */ ul标签实际应用场景：场景1、导航条： 场景2、li 里面放置的内容可能很多： 声明：ul的儿子，只能是li。但是li是一个容器级标签，li里面什么都能放，甚至可以再放一个ul。 2、有序列表&lt;OL&gt;，里面的每一项是&lt;li&gt;英文单词：Ordered List。 例如： 12345&lt;ol &gt; &lt;li&gt;呵呵哒1&lt;/li&gt; &lt;li&gt;呵呵哒2&lt;/li&gt; &lt;li&gt;呵呵哒3&lt;/li&gt;&lt;/ol&gt; 效果： 属性： type=&quot;属性值&quot;。属性值可以是：1(阿拉伯数字，默认)、a、A、i、I。结合start属性表示从几开始。 举例： 1234567891011121314151617181920212223&lt;ol type=\"1\"&gt; &lt;li&gt;呵呵&lt;/li&gt; &lt;li&gt;呵呵&lt;/li&gt; &lt;li&gt;呵呵&lt;/li&gt;&lt;/ol&gt;&lt;ol type=\"a\"&gt; &lt;li&gt;嘿嘿&lt;/li&gt; &lt;li&gt;嘿嘿&lt;/li&gt; &lt;li&gt;呵呵&lt;/li&gt;&lt;/ol&gt;&lt;ol type=\"i\" start=\"4\"&gt; &lt;li&gt;哈哈&lt;/li&gt; &lt;li&gt;哈哈&lt;/li&gt; &lt;li&gt;哈哈&lt;/li&gt;&lt;/ol&gt;&lt;ol type=\"I\" start=\"10\"&gt; &lt;li&gt;么么&lt;/li&gt; &lt;li&gt;么么&lt;/li&gt; &lt;li&gt;么么&lt;/li&gt;&lt;/ol&gt; 效果如下： 和无序列表一样，有序列表也是可以嵌套的哦，这里就不举类似的例子了。 ol和ul就是语义不一样，怎么使用都是一样的。ol里面只能有li，li必须被ol包裹。li是容器级。 ol这个东西用的不多，如果想表达顺序，大家一般也用ul。举例如下： 12345&lt;ul&gt; &lt;li&gt;1. 小苹果&lt;/li&gt; &lt;li&gt;2. 月亮之上&lt;/li&gt; &lt;li&gt;3. 最炫民族风&lt;/li&gt;&lt;/ul&gt; 3、定义列表&lt;dl&gt; 定义列表的作用非常大。 &lt;dl&gt;英文单词：definition list，没有属性。dl的子元素只能是dt和dd。 &lt;dt&gt;：definition title 列表的标题，这个标签是必须的 &lt;dd&gt;：definition description 列表的列表项，如果不需要它，可以不加 备注：dt、dd只能在dl里面；dl里面只能有dt、dd。 举例： 1234567891011121314&lt;dl&gt; &lt;dt&gt;第一条&lt;/dt&gt; &lt;dd&gt;你若是觉得你有实力和我玩，良辰不介意奉陪到底&lt;/dd&gt; &lt;dd&gt;我会让你明白，我从不说空话&lt;/dd&gt; &lt;dd&gt;我是本地的，我有一百种方式让你呆不下去；而你，无可奈何&lt;/dd&gt; &lt;dt&gt;第二条&lt;/dt&gt; &lt;dd&gt;良辰最喜欢对那些自认能力出众的人出手&lt;/dd&gt; &lt;dd&gt;你可以继续我行我素，不过，你的日子不会很舒心&lt;/dd&gt; &lt;dd&gt;你只要记住，我叫叶良辰&lt;/dd&gt; &lt;dd&gt;不介意陪你玩玩&lt;/dd&gt; &lt;dd&gt;良辰必有重谢&lt;/dd&gt;&lt;/dl&gt; 效果： 上图可以看出，定义列表表达的语义是两层： （1）是一个列表，列出了几个dd项目 （2）每一个词儿都有自己的描述项。 备注：dd是描述dt的。 定义列表用法非常灵活，可以一个dt配很多dd： 123456789&lt;dl&gt; &lt;dt&gt;北京&lt;/dt&gt; &lt;dd&gt;国家首都，政治文化中心&lt;/dd&gt; &lt;dd&gt;污染很严重，PM2.0天天报表&lt;/dd&gt; &lt;dt&gt;上海&lt;/dt&gt; &lt;dd&gt;魔都，有外滩、东方明珠塔、黄浦江&lt;/dd&gt; &lt;dt&gt;广州&lt;/dt&gt; &lt;dd&gt;中国南大门，有珠江、小蛮腰&lt;/dd&gt;&lt;/dl&gt; 还可以拆开，让每一个dl里面只有一个dt和dd，这样子感觉清晰一些： 123456789101112131415&lt;dl&gt; &lt;dt&gt;北京&lt;/dt&gt; &lt;dd&gt;国家首都，政治文化中心&lt;/dd&gt; &lt;dd&gt;污染很严重，PM2.0天天报表&lt;/dd&gt;&lt;/dl&gt;&lt;dl&gt; &lt;dt&gt;上海&lt;/dt&gt; &lt;dd&gt;魔都，有外滩、东方明珠塔、黄浦江&lt;/dd&gt;&lt;/dl&gt;&lt;dl&gt; &lt;dt&gt;广州&lt;/dt&gt; &lt;dd&gt;中国南大门，有珠江、小蛮腰&lt;/dd&gt;&lt;/dl&gt; 真实案例：（京东最下方） 上图中的结构如下： 123456789101112131415161718192021&lt;dl&gt; &lt;dt&gt;购物指南&lt;/dt&gt; &lt;dd&gt; &lt;a href=\"#\"&gt;购物流程&lt;/a&gt; &lt;a href=\"#\"&gt;会员介绍&lt;/a&gt; &lt;a href=\"#\"&gt;生活旅行/团购&lt;/a&gt; &lt;a href=\"#\"&gt;常见问题&lt;/a&gt; &lt;a href=\"#\"&gt;大家电&lt;/a&gt; &lt;a href=\"#\"&gt;联系客服&lt;/a&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;dl&gt; &lt;dt&gt;配送方式&lt;/dt&gt; &lt;dd&gt; &lt;a href=\"#\"&gt;上门自提&lt;/a&gt; &lt;a href=\"#\"&gt;211限时达&lt;/a&gt; &lt;a href=\"#\"&gt;配送服务查询&lt;/a&gt; &lt;a href=\"#\"&gt;配送费收取标准&lt;/a&gt; &lt;a href=\"#\"&gt;海外配送&lt;/a&gt; &lt;/dd&gt;&lt;/dl&gt; 京东商品分类如下： dt、dd都是容器级标签，想放什么都可以。所以，现在就应该更加清晰的知道：用什么标签，不是根据样子来决定，而是语义（语义本质上是结构）。 表格标签表格标签用&lt;table&gt;表示。一个表格&lt;table&gt;是由每行&lt;tr&gt;组成的，每行是由每个单元格&lt;td&gt;组成的。所以我们要记住，一个表格是由行组成的（行是由列组成的），而不是由行和列组成的。在以前，要想固定标签的位置，唯一的方法就是表格。现在可以通过CSS定位的功能来实现。但是现在在做页面的时候，表格作用还是有一些的。 例如，一行的单元格： 12345678&lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 上面的表格中没有加文字，所以在生成的网页中什么都看不到。例如，3行4列的单元格： 1234567891011121314151617181920212223&lt;table&gt; &lt;tr&gt; &lt;td&gt;生命壹号&lt;/td&gt; &lt;td&gt;23&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;黄冈&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;许嵩&lt;/td&gt; &lt;td&gt;29&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;安徽&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;邓紫棋&lt;/td&gt; &lt;td&gt;23&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;香港&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 效果： 上图中的表格好像没看到边框呀，不急，接下来看看&lt;table&gt;标签的属性。 &lt;table&gt;的属性： border：边框。像素为单位。 style=&quot;border-collapse:collapse;&quot;：单元格的线和表格的边框线合并（表格的两边框合并为一条） width：宽度。像素为单位。 height：高度。像素为单位。 bordercolor：表格的边框颜色。 align：表格的水平对齐方式。属性值可以填：left right center。注意：这里不是设置表格里内容的对齐方式，如果想设置内容的对齐方式，要对单元格标签&lt;td&gt;进行设置） cellpadding：单元格内容到边的距离，像素为单位。默认情况下，文字是紧挨着左边那条线的，即默认情况下的值为0。注意不是单元格内容到四条边的距离哈，而是到一条边的距离，默认是与左边那条线的距离。如果设置属性dir=&quot;rtl&quot;，那就指的是内容到右边那条线的距离。 cellspacing：单元格和单元格之间的距离（外边距），像素为单位。默认情况下的值为0 bgcolor=&quot;#99cc66&quot;：表格的背景颜色。 background=&quot;路径src/...&quot;：背景图片。背景图片的优先级大于背景颜色。 bordercolorlight：表格的上、左边框，以及单元格的右、下边框的颜色 bordercolordark：表格的右、下边框，以及单元格的上、左的边框的颜色这两个属性的目的是为了设置3D的效果。 dir：公有属性，单元格内容的排列方式(direction)。 可以 取值：ltr：从左到右（left to right，默认），rtl：从右到左（right to left）既然说dir是共有属性，如果把这个属性放在任意标签中，那表明这个标签的位置可能会从右开始排列。 单元格带边框的效果： 备注：表格中很细表格边线的制作，CSS的写法： 1style=\"border-collapse:collapse;\" &lt;tr&gt;：行一个表格就是一行一行组成的。 属性： dir：公有属性，设置这一行单元格内容的排列方式。可以取值： ltr：从左到右（left to right，默认） rtl：从右到左（right to left） bgcolor：设置这一行的单元格的背景色。注：没有background属性，即：无法设置这一行的背景图片，如果非要设置，可以用css实现。 height：一行的高度 align=&quot;center&quot;：一行的内容水平居中显示，取值：left、center、right valign=&quot;center&quot;：一行的内容垂直居中，取值：top、middle、bottom &lt;td&gt;：单元格属性： align：内容的横向对齐方式。属性值可以填：left right center。如果想让每个单元格的内容都居中，这个属性太麻烦了，以后用css来解决。 valign：内容的纵向对齐方式。属性值可以填：top middle bottom width：绝对值或者相对值(%) height：单元格的高度 bgcolor：设置这个单元格的背景色。 background：设置这个单元格的背景图片。 单元格的合并单元格的属性： colspan：横向合并。例如colspan=&quot;2&quot;表示当前单元格在水平方向上要占据两个单元格的位置。 rowspan：纵向合并。例如rowspan=&quot;2&quot;表示当前单元格在垂直方向上要占据两个单元格的位置。 效果举例：（横向合并） 效果举例：（纵向合并） &lt;th&gt;：加粗的单元格。相当于&lt;td&gt; + &lt;b&gt; 属性同&lt;td&gt;标签。 ### ``：表格的标题。使用时和`tr`标签并列 - 属性：`align`，表示标题相对于表格的位置。属性取值可以是：left、center、right、top、bottom 效果： 表格的&lt;thead&gt;标签、&lt;tbody&gt;标签、&lt;tfoot&gt;标签这三个标签有与没有的区别： 1、如果写了，那么这三个部分的代码顺序可以任意，浏览器显示的时候还是按照thead、tbody、tfoot的顺序依次来显示内容。如果不写thead、tbody、tfoot，那么浏览器解析并显示表格内容的时候是从按照代码的从上到下的顺序来显示。 2、当表格非常大内容非常多的时候，如果用thead、tbody、tfoot标签的话，那么数据可以边获取边显示。如果不写，则必须等表格的内容全部从服务器获取完成才能显示出来。 举例： 12345678910111213141516171819202122232425262728293031323334&lt;body&gt;&lt;table border=\"1\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;生命壹号&lt;/td&gt; &lt;td&gt;23&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;黄冈&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;许嵩&lt;/td&gt; &lt;td&gt;29&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;安徽&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;邓紫棋&lt;/td&gt; &lt;td&gt;23&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;香港&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt;&lt;/table&gt;&lt;/body&gt; 效果： 框架标签如果我们希望在一个网页中显示多个页面，那框架标签就派上用场了。 注意，框架标签不能放在&lt;body&gt;标签里面，因为&lt;body&gt;标签代表的只是一个页面，而框架标签代表的是多个页面。于是：&lt;frameset&gt;和&lt;body&gt;只能二选一。 框架的集合用&lt;frameset&gt;表示，然后在&lt;frameset&gt;集合里放入一个一个的框架&lt;frame&gt; &lt;frameset&gt;：框架的集合一个框架的集合可以包含多个框架或框架的集合。属性： rows：水平分割，将框架分为上下部分。写法有两种： 1、绝对值写法：rows=&quot;200,*&quot; 其中*代表剩余的。这里其实包含了两个框架：上面的框架占200个像素，下面的框架占剩下的部分。 2、相对值写法：rows=&quot;30%,*&quot; 其中*代表剩余的。这里其实包含了两个框架：上面的框架占30%，下面的框架占70%。 注：如果你想将框架分成很多行，在属性值里用逗号隔开就行了。 cols：垂直分割，将框架分为左右部分。写法有两种： 1、绝对值写法：cols=&quot;200,*&quot; 其中*代表剩余的。这里其实包含了两个框架：左边的框架占200个像素，右边的框架占剩下的部分。 2、相对值写法：cols=&quot;30%,*&quot; 其中*代表剩余的。这里其实包含了两个框架：左边的框架占30%，右边的框架占70%。 注：如果你想将框架分成很多列，在属性值里用逗号隔开就行了。 效果： 上图中，如果删掉页面right.html，显示效果如下： &lt;frame&gt;：框架一个框架显示一个页面。 属性： scrolling=&quot;no&quot;：是否需要滚动条。默认值是true。 noresize：不可以改变框架大小。默认情况下，单个框架的边界是可以拖动的，这样的话，框架大小就不固定了。如果用了这个属性值，框架大小将固定。 举例： 1&lt;frame src=\"top.html\" noresize&gt;&lt;/frame&gt; bordercolor=&quot;#00FF00&quot;：给框架的边框定义颜色。这个属性在框架集合&lt;frameset&gt;中同样适用。颜色这个属性在IE浏览器中生效，但是在google浏览器中无效，不知道为啥。 frameborder=&quot;0&quot;或frameborder=&quot;1&quot;：隐藏或显示边框（框架线）。 name：给框架起一个名字。 利用name这个属性，我们可以在框架里进行超链。 举例： 效果： 内嵌框架内嵌框架用&lt;iframe&gt;表示。&lt;iframe&gt;是&lt;body&gt;的子标记。 内嵌框架inner frame：嵌入在一个页面上的框架(仅仅IE、新版google浏览器支持，可能有其他浏览器也支持，暂时我不清楚)。 属性： src=&quot;subframe/the_second.html&quot;：内嵌的那个页面 width=800：宽度 height=“150：高度 scrolling=&quot;no&quot;：是否需要滚动条。默认值是true。 name=&quot;mainFrame&quot;：窗口名称。公有属性。 效果： 内嵌框架举例：（在内嵌页面中切换显示不同的压面） 1234567891011&lt;body&gt; &lt;a href=\"文字页面.html\" target=\"myframe\"&gt;默认显示文字页面&lt;/a&gt;&lt;br&gt; &lt;a href=\"图片页面.html\" target=\"myframe\"&gt;点击进入图片页面&lt;/a&gt;&lt;br&gt; &lt;a href=\"表格页面.html\" target=\"myframe\"&gt;点击进入表格页面&lt;/a&gt;&lt;br&gt; &lt;iframe src=\"文字页面.html\" width=\"400\" height=\"400\" name=\"myframe\"&gt;&lt;/iframe&gt; &lt;br&gt; 嘿嘿&lt;/body&gt; 效果演示： 表单标签表单标签用&lt;form&gt;表示，用于与服务器的交互。表单就是收集用户信息的，就是让用户填写的、选择的。 属性： name：表单的名称，用于JS来操作或控制表单时使用； id：表单的名称，用于JS来操作或控制表单时使用； action：指定表单数据的处理程序，一般是PHP，如：action=“login.php” method：表单数据的提交方式，一般取值：get(默认)和post 注意：表单和表格嵌套时，是在标记中套标记。 form标签里面的action属性和method属性，在《Ajax》课程上给大家讲解。稍微说一下：action属性就是表示，表单将提交到哪里。 method属性表示用什么HTTP方法提交，有get、post两种。 get提交和post提交的区别： GET方式：将表单数据，以”name=value”形式追加到action指定的处理程序的后面，两者间用”?”隔开，每一个表单的”name=value”间用”&amp;”号隔开。特点：只适合提交少量信息，并且不太安全(不要提交敏感数据)、提交的数据类型只限于ASCII字符。 POST方式：将表单数据直接发送(隐藏)到action指定的处理程序。POST发送的数据不可见。Action指定的处理程序可以获取到表单数据。特点：可以提交海量信息，相对来说安全一些，提交的数据格式是多样的(Word、Excel、rar、img)。 Enctype：表单数据的编码方式(加密方式)，取值可以是：application/x-www-form-urlencoded、multipart/form-data。Enctype只能在POST方式下使用。 Application/x-www-form-urlencoded：默认加密方式，除了上传文件之外的数据都可以 Multipart/form-data：上传附件时，必须使用这种编码方式。 &lt;input&gt;：输入标签（文本框）用于接收用户输入。 1&lt;input type=\"text\" /&gt; 属性： type=&quot;属性值&quot;：文本类型。属性值可以是： text（默认） password：密码类型 radio：单选按钮，名字相同的按钮作为一组进行单选（单选按钮，天生是不能互斥的，如果想互斥，必须要有相同的name属性。name就是“名字”。）。非常像以前的收音机，按下去一个按钮，其他的就抬起来了。所以叫做radio。 checkbox：多选按钮，name 属性值相同的按钮作为一组进行选择。 checked：将单选按钮或多选按钮默认处于选中状态。当&lt;input&gt;标签的type=&quot;radio&quot;时，可以用这个属性。属性值也是checked，可以省略。 hidden：隐藏框，在表单中包含不希望用户看见的信息 button：普通按钮，结合js代码进行使用。 submit：提交按钮，传送当前表单的数据给服务器或其他程序处理。这个按钮不需要写value自动就会有“提交”文字。这个按钮真的有提交功能。点击按钮后，这个表单就会被提交到form标签的action属性中指定的那个页面中去。 reset：重置按钮，清空当前表单的内容，并设置为最初的默认值 image：图片按钮，和提交按钮的功能完全一致，只不过图片按钮可以显示图片。 file：文件选择框。提示：如果要限制上传文件的类型，需要配合JS来实现验证。对上传文件的安全检查：一是扩展名的检查，二是文件数据内容的检查。 value=&quot;内容&quot;：文本框里的默认内容（已经被填好了的） size=&quot;50&quot;：表示文本框内可以显示五十个字符。一个英文或一个中文都算一个字符。注意size属性值的单位不是像素哦。 readonly：文本框只读，不能编辑。因为它的属性值也是readonly，所以属性值可以不写。用了这个属性之后，在google浏览器中，光标点不进去；在IE浏览器中，光标可以点进去，但是文字不能编辑。 disabled：文本框只读，不能编辑，光标点不进去。属性值可以不写。 备注：HTML5中，input的类型又增加了很多（比如date、color，我们会在 html5 中讲到）。 举例： 1234567891011&lt;form&gt; 姓名：&lt;input value=\"呵呵\" &gt;逗比&lt;br&gt; 昵称：&lt;input value=\"哈哈\" readonly=\"\"&gt;&lt;br&gt; 名字：&lt;input type=\"text\" value=\"name\" disabled=\"\"&gt;&lt;br&gt; 密码：&lt;input type=\"password\" value=\"pwd\" size=\"50\"&gt;&lt;br&gt; 性别：&lt;input type=\"radio\" name=\"gender\" id=\"radio1\" value=\"male\" checked=\"\"&gt;男 &lt;input type=\"radio\" name=\"gender\" id=\"radio2\" value=\"female\" &gt;女&lt;br&gt; 爱好：&lt;input type=\"checkbox\" name=\"love\" value=\"eat\"&gt;吃饭 &lt;input type=\"checkbox\" name=\"love\" value=\"sleep\"&gt;睡觉 &lt;input type=\"checkbox\" name=\"love\" value=\"bat\"&gt;打豆豆&lt;/form&gt; 效果： 注意，多个个单选框的input标签中，name 的属性值可以相同，但是 id 的属性值必须是唯一的。我们知道，html的标签中，id的属性值是唯一的。 四种按钮的举例： 12345678&lt;form&gt; &lt;input type=\"button\" value=\"普通按钮\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交按钮\"&gt;&lt;br&gt; &lt;input type=\"reset\" value=\"重置按钮\"&gt;&lt;br&gt; &lt;input type=\"image\" value=\"图片按钮1\"&gt;&lt;br&gt; &lt;input type=\"image\" src=\"1.jpg\" width=\"800\" value=\"图片按钮2\"&gt;&lt;br&gt; &lt;input type=\"file\" value=\"文件选择框\"&gt;&lt;/form&gt; 前端开发工程师，重点关心页面的美、样式、板式、交互。至于数据的提供和比较重的业务逻辑，都是后台工程师做的事情。 效果： &lt;select&gt;：下拉列表标签&lt;select&gt;标签里面的每一项用&lt;option&gt;表示。select就是“选择”，option“选项”。 select标签和ul、ol、dl一样，都是组标签。 &lt;select&gt;标签的属性： multiple：可以对下拉列表中的选项进行多选。没有属性值。 size=&quot;3&quot;：如果属性值大于1，则列表为滚动视图。默认属性值为1，即下拉视图。 &lt;option&gt;标签的属性： selected：预选中。没有属性值。 举例： 1234567891011121314151617181920212223242526272829&lt;form&gt; &lt;select&gt; &lt;option&gt;小学&lt;/option&gt; &lt;option&gt;初中&lt;/option&gt; &lt;option&gt;高中&lt;/option&gt; &lt;option&gt;大学&lt;/option&gt; &lt;option selected=\"\"&gt;研究生&lt;/option&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;select size=\"3\"&gt; &lt;option&gt;小学&lt;/option&gt; &lt;option&gt;初中&lt;/option&gt; &lt;option&gt;高中&lt;/option&gt; &lt;option&gt;大学&lt;/option&gt; &lt;option&gt;研究生&lt;/option&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;select multiple=\"\"&gt; &lt;option&gt;小学&lt;/option&gt; &lt;option&gt;初中&lt;/option&gt; &lt;option selected=\"\"&gt;高中&lt;/option&gt; &lt;option selected=\"\"&gt;大学&lt;/option&gt; &lt;option&gt;研究生&lt;/option&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/form&gt; 效果： &lt;textare&gt;标签：多行文本输入框text就是“文本”，area就是“区域”。 属性： value：提交给服务器的值。 rows=&quot;4&quot;：指定文本区域的行数。 cols=&quot;20&quot;：指定文本区域的列数。 readonly：只读。 举例： 123&lt;form&gt; &lt;textarea name=\"txtInfo\" rows=\"4\" cols=\"20\"&gt;1、不爱摄影不懂设计的程序猿不是一个好的产品经理。&lt;/textarea&gt;&lt;/form&gt; 上方代码解释：textarea这个标签，是个标签对儿。对儿里面不用写东西。如果写的话，就是这个框的默认文字。 效果： 上图的红框部分表示，我在文本区域进行了换行，所以显示的效果也出现了空白。 表单的语义化比如，我们在注册一个网站的信息的时候，有一部分是必填信息，有一部分是选填信息，这个时候可以利用表单的语义化。举例： 123456789101112131415161718&lt;form&gt; &lt;fieldset&gt; &lt;legend&gt;账号信息&lt;/legend&gt; 姓名：&lt;input value=\"呵呵\" &gt;逗比&lt;br&gt; 密码：&lt;input type=\"password\" value=\"pwd\" size=\"50\"&gt;&lt;br&gt; &lt;/fieldset&gt; &lt;fieldset&gt; &lt;legend&gt;其他信息&lt;/legend&gt; 性别：&lt;input type=\"radio\" name=\"gender\" value=\"male\" checked=\"\"&gt;男 &lt;input type=\"radio\" name=\"gender\" value=\"female\" &gt;女&lt;br&gt; 爱好：&lt;input type=\"checkbox\" name=\"love\" value=\"eat\"&gt;吃饭 &lt;input type=\"checkbox\" name=\"love\" value=\"sleep\"&gt;睡觉 &lt;input type=\"checkbox\" name=\"love\" value=\"bat\"&gt;打豆豆 &lt;/fieldset&gt;&lt;/form&gt; 效果： &lt;label&gt;标签我们先来看下面一段代码： 12&lt;input type=\"radio\" name=\"sex\" /&gt; 男&lt;input type=\"radio\" name=\"sex\" /&gt; 女 对于上面这样的单选框，我们只有点击那个单选框（小圆圈）才可以选中，点击“男”、“女”这两个文字时是无法选中的；于是，label标签派上了用场。 本质上来讲，“男”、“女”这两个文字和input标签时没有关系的，而label就是解决这个问题的。我们可以通过label把input和汉字包裹起来作为整体。 解决方法如下： 12&lt;input type=\"radio\" name=\"sex\" id=\"nan\" /&gt; &lt;label for=\"nan\"&gt;男&lt;/label&gt;&lt;input type=\"radio\" name=\"sex\" id=\"nv\" /&gt; &lt;label for=\"nv\"&gt;女&lt;/label&gt; 上方代码中，让label标签的for 属性值，和 input 标签的 id 属性值相同，那么这个label和input就有绑定关系了。 当然了，复选框也有label：（任何表单元素都有label） 12&lt;input type=\"checkbox\" id=\"kk\" /&gt;&lt;label for=\"kk\"&gt;10天内免登陆&lt;/label&gt; 多媒体标签声明：多媒体包含：音频、视频、Flash。网页上的多媒体基本都是Flash格式的。.wmv、.dat、.mob、.rmvb等视频格式，在网页上不能直接播放，需要安装第三方的插件，才可以播放。不同的浏览器，播客上述视频格式，所使用插件参数又不一样。上述格式视频一般文件较大，不利于网络下载播放。一般情况下，是将其它的视频格式，转成Flash来在网页上播放。转换软件：格式工厂等。Flash格式的视频兼容性非常好，Flash格式的文件很小。 &lt;bgsound&gt;标签：播放背景音乐属性： src=&quot;音乐文件的路径&quot; loop=&quot;-1&quot;：属性值代表播放次数，-1代表循环播放。 举例： 123&lt;body&gt;&lt;bgsound src=\"王菲 - 清风徐来.mp3\"&gt;&lt;/bgsound&gt;&lt;/body&gt; 运行效果：打开网页后，在IE 8中播放正常，播放时网页上显示一片空白。在google浏览器中无法播放。 &lt;embed&gt;标签：播放多媒体文件（音频、视频等）主要应用Netscape浏览器，它不是W3C规范。 备注：视频格式可以支持 mp4、wav等，但不是所有视频格式都支持。 属性： src=&quot;多媒体文件的路径&quot; loop=&quot;-1&quot;：属性值代表播放次数，-1代表循环播放。 autostart=&quot;false&quot;：打开网页时，禁止自动播放。默认值是true。 volume=&quot;100&quot;：设置默认的音量大小，测试发现这个值好像不起作用哦。 width：指Flash文件的宽度 height：指Flash文件的高度 quality：指Flash的播放质量，质量有高有低 hight low pluginspage：如果指定的Flash插件不存在，则从pluginspage指定的地方进行下载。 type：指定Flash的文件格式类型 wmode：指Flash的背景是否可以透明，取值：transparent是透明的 &lt;embed&gt;标签播放音频举例： 123&lt;body&gt;&lt;embed src=\"王菲 - 清风徐来.mp3\"&gt;&lt;/embed&gt;&lt;/body&gt; IE 8中的运行效果： google浏览器中的运行效果： 注：在HTML5中新增了&lt;video&gt;标签播放视频。 &lt;object&gt;标签：播放多媒体文件（音频、视频等）主要应用IE浏览器，它是W3C规范。 属性： classid：指定Flash插件的ID号，一般存在于注册表中。 codebase：如果Flash插件不存在，则从codebase指定的地址下载。 &lt;param&gt;标签的主要作用：设置具体的详细参数。 总结：在网页中插入Flash时，为了同时兼容多种浏览器，需要将&lt;object&gt;标签和&lt;embed&gt;标签标记一起使用，但使用的顺序是：&lt;object&gt;中嵌套&lt;embed&gt;标记。举例： 123456&lt;object classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\" codebase=\"http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,29,0\" width=\"778\" height=\"202\"&gt; &lt;param name=\"movie\" value=\"images/banner.swf\"&gt; &lt;param name=\"quality\" value=\"high\"&gt; &lt;param name=\"wmode\" value=\"transparent\"&gt; &lt;embed src=\"images/banner.swf\" width=\"778\" height=\"202\" quality=\"high\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" type=\"application/x-shockwave-flash\" wmode=\"transparent\"&gt;&lt;/embed&gt;&lt;/object&gt; &lt;marquee&gt;：滚动字幕标签如果在这个标签里设置了内容，那么，打开网页时，内容会像弹幕一样自动移动。属性： direction=&quot;right&quot;：移动的目标方向。属性值可以是：left（从右向左移动，默认值）、right（从左向右移动）、up（从下向上移动）、down（从上向下移动）。 behavior=&quot;slide&quot;：行为方式。属性值可以是：slide（只移动一次）、scroll（循环移动，默认值）、alternate（循环移动）、。alternate和scroll属性值都是循环移动，区别在于：假设在direction=&quot;right&quot;的情况下，behavior=&quot;scroll&quot;表示从左到右、从左到右、从左到右···behavior=&quot;alternate&quot;表示从左到右、从右到左、从左到右··· scrollamount=&quot;30&quot;：移动的速度 loop=&quot;3&quot;: 循环多少圈。负值表示无限循环 scrolldelay=&quot;1000&quot;：移动一次休息多长时间。单位是毫秒。 举例： 1&lt;marquee behavior=\"alternate\" direction=\"down\" width=\"300\" height=\"200\" bgcolor=\"#8c5dc1\"&gt;我来了&lt;/marquee&gt; 效果： html废弃标签介绍HTML现在只负责语义，而不负责样式。但是HTML一开始，连样式也包办了。这些样式的标签，都已经被废弃。 2004年之前的东西： 1&lt;font size=\"9\" color=\"red\"&gt;哈哈&lt;/font&gt; 下面这些标签都是css钩子，而不是原意： 123456&lt;b&gt;加粗&lt;/b&gt;&lt;u&gt;下划线&lt;/u&gt;&lt;i&gt;倾斜&lt;/i&gt; &lt;del&gt;删除线&lt;/del&gt;&lt;em&gt;强调&lt;/em&gt;&lt;strong&gt;强调&lt;/strong&gt; 这些标签，是有着浓厚的样式的作用，干涉了css的作用，所以HTML抛弃了他们。 类似的还有水平线标签： 1&lt;hr /&gt; 换行标签： 1&lt;br /&gt; 但是，网页中99.9999%需要换行的时候，是因为另起了一个段落，所以要用p，而不要用&lt;br /&gt;。不到万不得已，不要用br标签。 标准的div+css页面，只会用到种类很少的标签： 1div p h1 span a img ul ol dl input 知道每个标签的特殊用法、属性。比如a标签，img的属性。","link":"/2020/03/02/html/html-%E6%A0%87%E7%AD%BE%E5%9B%BE%E6%96%873/"},{"title":"html-标签图文详解","text":"本文主要内容 头标签 排版标签：&lt;p&gt;、 &lt;div&gt;、 &lt;span&gt;、&lt;br&gt; 、 &lt;hr&gt; 、 &lt;center&gt; 、 &lt;pre&gt; 字体标记：&lt;h1&gt;、 &lt;font&gt;、 &lt;b&gt;、 &lt;u&gt; 、&lt;sup&gt; 、&lt;sub&gt; 超链接 &lt;a&gt; 图片标签 &lt;img&gt; 前言来自 https://github.com/qianguyihao/Web web标准web标准介绍： w3c：万维网联盟组织，用来制定web标准的机构（组织） web标准：制作网页要遵循的规范。 web标准规范的分类：结构标准、表现标准、行为标准。 结构：html。表现：css。行为：JavaScript。 Web 前端分三层： HTML：HyperText Markup Language（超文本标记语言）。从语义的角度描述页面的结构。相当于人的身体结构。 CSS：Cascading Style Sheets（层叠样式表）。从审美的角度美化页面的样式。相当于人的衣服。 JS：JavaScript。从交互的角度描述页面的行为。相当于人的动作，让人有生命力。 编辑器相关VS Code 的使用详情请移步至：第一次使用VS Code时你应该知道的一切配置 Sublime Text 的使用详情请移步至：Sublime Text使用技巧 一、HTML的介绍1、HTML的概述：html全称为HyperText Markup Language，译为超文本标记语言，不是一种编程语言，是一种描述性的标记语言，用于描述超文本中内容的显示方式。比如字体什么颜色，大小等。 超文本：音频，视频，图片称为超文本。 标记 ：&lt;英文单词或者字母&gt;称为标记，一个HTML页面都是由各种标记组成。 作用：HTML是负责描述文档语义的语言。 注意：HTML语言不是一个编程语言(有编译过程)，而是一个标记语言(没有编译过程)，HTML页面直接由浏览器解析执行。 HTML是负责描述文档语义的语言html中，除了语义，其他什么都没有。 html是一个纯本文文件（就是用txt文件改名而成），用一些标签来描述文字的语义，这些标签在浏览器里面是看不到的，所以称为“超文本”，所以就是“超文本标记语言”了。所以，接下来，我们肯定要学习一堆html中的标签对儿，这些标签对儿能够给文本不同的语义。 比如，面试的时候问你，h1标签有什么作用？ 正确答案：给文本增加主标题的语义。 错误答案：给文字加粗、加黑、变大。 2、HTML的历史 我们专门来对XHTML做一个介绍。 XHTML介绍：XHTML：Extensible Hypertext Markup Language，可扩展超文本标注语言。XHTML的主要目的是为了取代HTML，也可以理解为HTML的升级版。HTML的标记书写很不规范，会造成其它的设备(ipad、手机、电视等)无法正常显示。XHTML与HTML4.0的标记基本上一样。XHTML是严格的、纯净的HTML。 我们稍后将对XHTML的编写规范进行介绍。 3、HTML的网络术语 网页 ：由各种标记组成的一个页面就叫网页。 主页(首页) : 一个网站的起始页面或者导航页面。 标记： &lt;p&gt;称为开始标记 ，&lt;/p&gt;称为结束标记，也叫标签。每个标签都规定好了特殊的含义。 元素：&lt;p&gt;内容&lt;/p&gt;称为元素. 属性：给每一个标签所做的辅助信息。 xhtml： 符合XML语法标准的HTML。 dhtml：dynamic，动态的。javascript + css + html合起来的页面就是一个dhtml。 http：超文本传输协议。用来规定客户端浏览器和服务端交互时数据的一个格式。SMTP：邮件传输协议，ftp：文件传输协议。 4、HTML的编辑工具 用的最多的编辑器是： VS Code 和 Sublime Text。 VS Code：最火的前端代码编辑器。 Sublime Text：很轻量的代码编辑器。 NotePad：记事本。 EditPlus：语法高亮显示。技巧： 根据颜色判断单词是否出错 （不是100%）。不好的地方：没有代码提示。 UltraEdit：根据颜色判断单词是否出错，可以显示2进制数据。 dw(dreamweaver，专业工具) ：建立WEB站点和应用程序的专业工具。它将布局功能、开发工具、代码编辑组合在一起。有代码提示。 PS：后缀名不能决定文件格式，只能决定打开文件打开的方式。 5、计算机编码介绍计算机，不能直接存储文字，存储的是编码。 计算机只能处理二进制的数据，其它数据，比如：0-9、a-z、A-Z，这些字符，我们定义一套规则来表示。假如：A用110表示，B用111表示等。 ASCII码：美国发布的，用1个字节(8位二进制)来表示一个字符，共可以表示2^8=256个字符。 美国的国家语言是英语，只要能表示0-9、a-z、A-Z、特殊符号。 ANSI编码：每个国家为了显示本国的语言，都对ASCII码进行了扩展。用2个字节(16位二进制)来表示一个汉字，共可以表示2^16＝65536个汉字。例如：中国的ANSI编码是GB2312编码(简体)，对6763汉字进行编码，含600多特殊字符。另外还有GBK(简体)。日本的ANSI编码是JIS编码。台湾的ANSI编码是BIG5编码（繁体）。 GBK：对GB2312进行了扩展，用来显示罕见的、古汉语的汉字。现在已经收录了2.1万左右。并提供了1890个汉字码位。K的含义就是“扩展”。 Unicode编码(统一编码)：用4个字节(32位二进制)来表示一个字符，想法不错，但效率太低。例如，字母A用ASCII表示的话一个字节就够，可用Unicode编码的话，得用4个字节表示，造成了空间的极大浪费。A的Unicode编码是0000 0000 0000 0000 0000 0000 0100 0000 UTF-8(Unicode Transform Format)编码：根据字符的不同，选择其编码的长度。比如：一个字符A用1个字节表示，一个汉字用2个字节表示。 毫无疑问，开发中，都用UTF-8编码吧，准没错。 中文能够使用的字符集两种： 第一种：UTF-8。UTF-8是国际通用字库，里面涵盖了所有地球上所有人类的语言文字，比如阿拉伯文、汉语、鸟语…… 第二种：GBK（对GB2312进行了扩展）。gb2312 是国标，是中国的字库，里面仅涵盖了汉字和一些常用外文，比如日文片假名，和常见的符号。 字库规模： UTF-8（字全） &gt; gb2312（只有汉字） 重点1：避免乱码 我们用meta标签声明的当前这个html文档的字库，一定要和保存的文件编码类型一样，否则乱码！（重点）。 当我们不设置的时候，sublime默认类型就是UTF-8。而一旦更改为gb2312的时候，就一定要记得设置一下sublime的保存类型： 文件→ set File Encoding to → Chinese Simplified(GBK)。 重点2：UTF-8和gb2312的比较 保存大小：UTF-8（更臃肿、加载更慢） &gt; gb2312 （更小巧，加载更快） 总结： UTF-8：字多，有各种国家的语言，但是保存尺寸大，文件臃肿； gb2312：字少，只用中文和少数外语和符号，但是尺寸小，文件小巧。 列出2个使用情形： 1） 你们公司是做日本动漫的，经常出现一些日语动漫的名字，网页要使用UTF-8。如果用gb2312将无法显示日语。2） 你们公司就是中文网页，极度的追求网页的显示速度，要使用gb2312。如果使用UTF-8将每个汉字多一个byte，所以5000个汉字，多5kb。 我们亲测： qq网、网易、搜狐都是使用gb2312。这些公司，都追求显示速度。 新华网藏语频道，使用的是UTF-8，保证字符集的数量。 我们是怎么查看网页的编码方式的呢？在浏览器中打开网页，右键，选择“查看网页源代码”，找到meta标签中的charset属性即可。 那么，我们为什么可以查看网页的源代码呢？因为这个打开的网页已经存到我的临时文件夹里了，临时文件夹里的html是纯文本文件，纯文本文件自然可以查看网页的源代码了。 6、HTML颜色介绍颜色表示： 纯单词表示：red、green、blue、orange、gray等 10进制表示：rgb(255,0,0) 16进制表示：#FF0000、#0000FF、#00FF00等 RGB色彩模式： 自然界中所有的颜色都可以用红、绿、蓝(RGB)这三种颜色波长的不同强度组合而得，这就是人们常说的三原色原理。 RGB三原色也叫加色模式，这是因为当我们把不同光的波长加到一起的时候，可以得到不同的混合色。例：红+绿=黄色，红+蓝＝紫色，绿+蓝=青 在数字视频中，对RGB三基色各进行8位编码就构成了大约1678万种颜色，这就是我们常说的真彩色。所有显示设备都采用的是RGB色彩模式。 RGB各有256级(0-255)亮度，256级的RGB色彩总共能组合出约1678万种色彩，即256×256×256=16777216。 二、HTML的规范 HTML是一个弱势语言 HTML不区分大小写 HTML页面的后缀名是html或者htm(有一些系统不支持后缀名长度超过3个字符，比如dos系统) HTML的结构： 声明部分：主要作用是用来告诉浏览器这个页面使用的是哪个标准。是HTML5标准。 head部分：将页面的一些额外信息告诉服务器。不会显示在页面上。 body部分：我们所写的代码必须放在此标签內。 目前，IE浏览器是完全不支持H5的，支持最好的是Opera浏览器，可以支持95%以上；其次是google，可以支持一部分H5。 1、编写XHTML的规范：（1）所有标记元素都要正确的嵌套，不能交叉嵌套。正确写法举例：&lt;h1&gt;&lt;font&gt;&lt;/font&gt;&lt;/h1&gt; （2）所有的标记都必须小写。 （3）所有的标记都必须关闭。 双边标记：&lt;span&gt;&lt;/span&gt; 单边标记：&lt;br&gt; 转成 &lt;br /&gt; &lt;hr&gt; 转成 &lt;hr /&gt;，还有&lt;img src=“URL” /&gt; （4）所有的属性值必须加引号。&lt;font color=&quot;red&quot;&gt;&lt;/font&gt; （5）所有的属性必须有值。&lt;hr noshade=&quot;noshade&quot;&gt;、&lt;input type=&quot;radio&quot; checked=&quot;checked&quot; /&gt; （6）XHTML文档开头必须要有DTD文档类型定义 2、HTML的基本语法特性（1）HTML对换行不敏感，对tab不敏感HTML只在乎标签的嵌套结构，嵌套的关系。谁嵌套了谁，谁被谁嵌套了，和换行、tab无关。换不换行、tab不tab，都不影响页面的结构。 也就是说，HTML不是依靠缩进来表示嵌套的，就是看标签的包裹关系。但是，我们发现有良好的缩进，代码更易读。要求大家都正确缩进标签。 百度为了追求极致的显示速度，所以HTML标签都没有换行、都没有缩进（tab），HTML和换不换行无关，标签的层次依然清晰，只不过程序员不可读了。如下图所示： （2）空白折叠现象HTML中所有的文字之间，如果有空格、换行、tab都将被折叠为一个空格显示。 举例如下： （3）标签要严格封闭标签不封闭是灾难性的。 标签不封闭的举例如下： 三、HTML结构详解 备注： 所有的浏览器默认情况下都会忽略空格和空行 每个标签都有私有属性。也都有公有属性。 html中表示长度的单位都是像素。HTML只有一种单位就是像素。 HTML标签通常是成对出现的（双边标记），比如 &lt;div&gt; 和 &lt;/div&gt;，也有单独呈现的标签（单边标记），如：&lt;br /&gt;、&lt;hr /&gt;和&lt;img src=&quot;images/1.jpg&quot; /&gt;等。 属性与标记之间、各属性之间需要以空格隔开。属性值以双引号括起来。 快速生成 html 的骨架方式1：在 VS Code 中新建 html 文件，输入html:5，按 Tab键后，自动生成的代码如下： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 方式2：在Sublime Text中安装Emmet插件。新建html文件，输入html:5，按Tab键后，自动生成的代码如下： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 方式3：在Sublime Text中安装Emmet插件。新建html文件，输入html:xt，按Tab键后（或者按Ctrl+E），自动生成的代码如下： 12345678910&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\"&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 上面的方式2和方式3中，我们会发现，第一行的内容有些不太一样，这就是我们接下来要讲的文档声明头。 1、文档声明头任何一个标准的HTML页面，第一行一定是一个以&lt;!DOCTYPE ……&gt;开头的语句。 这一行，就是文档声明头，DocType Declaration，简称DTD。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。 HTML4.01有哪些规范呢？HTML4.01这个版本是IE6开始兼容的。HTML5是IE9开开始兼容的。如今，手机、移动端的网页，就可以使用HTML5了，因为其兼容性更高。 说个题外话，html1 至 html3 是美国军方以及高等研究所用的，并未对外公开。 HTML4.01里面有两大种规范，每大种规范里面又各有3种小规范。所以一共6种规范（见下图）。 HTML4.01里面规定了普通和XHTML两大种规范。HTML觉得自己有一些规定不严谨，比如，标签是否可以用大写字母呢？&lt;H1&gt;&lt;/H1&gt;所以，HTML就觉得，把一些规范严格的标准，又制定了一个XHTML1.0。在XHTML中的字母X，表示“严格的”。 总结一下，HTML4.01一共有6种DTD。说白了，HTML的第一行语句一共有6种情况： 下面对上图中的三种小规范进行解释： strict：表示“严格的”，这种模式里面的要求更为严格。这种严格体现在哪里？有一些标签不能使用。比如，u标签，就是给一个本文加下划线，但是这和HTML的本质有冲突，因为HTML只能负责语义，不能负责样式，而u这个下划线是样式。所以，在strict中是不能使用u标签的。那怎么给文本增加下划线呢？今后的css将使用css属性来解决。那么，XHTML1.0更为严格，因为这个体系本身规定比如标签必须是小写字母、必须严格闭合标签、必须使用引号引起属性等等。 Transitional：表示“普通的”，这种模式就是没有一些别的规范。 Frameset：表示“框架”，在框架的页面使用。 在sublime输入的html:xt，x表示XHTML，t表示transitional。 在HTML5中极大的简化了DTD，也就是说HTML5中就没有XHTML了（W3C自己打脸了）： 1&lt;!DOCTYPE html&gt; 2、头标签html5 的比较完整的骨架：123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\"&gt; &lt;meta name=\"Author\" content=\"\"&gt; &lt;meta name=\"Keywords\" content=\"牛逼，很牛逼，特别牛逼\" /&gt; &lt;meta name=\"Description\" content=\"网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。\" /&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 面试题： 问：网页的head标签里面，表示的是页面的配置，有什么配置？ 答：字符集、关键词、页面描述、页面标题、IE适配、视口、iPhone小图标等等。 头标签都放在头部分之间。包括：&lt;title&gt;、&lt;base&gt;、&lt;meta&gt;、&lt;link&gt; &lt;title&gt;：指定整个网页的标题，在浏览器最上方显示。 &lt;base&gt;：为页面上的所有链接规定默认地址或默认目标。 &lt;meta&gt;：提供有关页面的基本信息 &lt;body&gt;：用于定义HTML文档所要显示的内容，也称为主体标签。我们所写的代码必须放在此标签內。 &lt;link&gt;：定义文档与外部资源的关系。 meta 标签： 上面的&lt;meta&gt;标签都不用记，但是另外还有一个&lt;meta&gt;标签是需要记住的： 1&lt;meta http-equiv=\"refresh\" content=\"3;http://www.baidu.com\"&gt; 上面这个标签的意思是说，3秒之后，自动跳转到百度页面。 常见的几种 meta 标签如下： （1）字符集 charset： 1&lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\"&gt; 字符集用meta标签中的charset定义，meta表示“元”。“元”配置，就是表示基本的配置项目。 charset就是charactor set（即“字符集”）。 浏览器就是通过meta来看网页是什么字符集的。比如你保存的时候，meta写的和声明的不匹配，那么浏览器就是乱码。 （2）视口 viewport： 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; width=device-width ：表示视口宽度等于屏幕宽度。 viewport 这个知识点，初学者还比较难理解，以后学 Web 移动端的时候会用到。 （2）定义“关键词”： 举例如下： 1&lt;meta name=\"Keywords\" content=\"网易,邮箱,游戏,新闻,体育,娱乐,女性,亚运,论坛,短信\" /&gt; 这些关键词，就是告诉搜索引擎，这个网页是干嘛的，能够提高搜索命中率。让别人能够找到你，搜索到你。 （3）定义“页面描述”： meta除了可以设置字符集，还可以设置关键字和页面描述。 只要设置Description页面描述，那么百度搜索结果，就能够显示这些语句，这个技术叫做SEO（search engine optimization，搜索引擎优化）。 设置页面描述的举例： 1&lt;meta name=\"Description\" content=\"网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。\" /&gt; 效果如下： title 标签: 用于设置网页标题： 1&lt;title&gt;网页的标题&lt;/title&gt; title也是有助于SEO搜索引擎优化的。 base标签： 1&lt;base href=\"/\"&gt; base 标签用于指定基础的路径。指定之后，所有的 a 链接都是以这个路径为基准。","link":"/2020/03/03/html/html-%E6%A0%87%E7%AD%BE%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3/"},{"title":"06-CSS浮动（重点）","text":"文本主要内容 标准文档流 标准文档流的特性 行内元素和块级元素 行内元素和块级元素的相互转换 浮动的性质 浮动的清除 浏览器的兼容性问题 浮动中margin相关 关于margin的IE6兼容问题 前言来自 https://github.com/qianguyihao/Web 标准文档流宏观地讲，我们的web页面和photoshop等设计软件有本质的区别：web页面的制作，是个“流”，必须从上而下，像“织毛衣”。而设计软件，想往哪里画个东西，都能画。 标准文档流的特性（1）空白折叠现象： 无论多少个空格、换行、tab，都会折叠为一个空格。 比如，如果我们想让img标签之间没有空隙，必须紧密连接： 1&lt;img src=&quot;images/0.jpg&quot; /&gt;&lt;img src=&quot;images/1.jpg&quot; /&gt;&lt;img src=&quot;images/2.jpg&quot; /&gt; （2）高矮不齐，底边对齐： 举例如下： （3）自动换行，一行写不满，换行写。 行内元素和块级元素学习的初期，我们就要知道，标准文档流等级森严。标签分为两种等级： 行内元素 块级元素 我们可以举一个例子，看看块级元素和行内元素的区别： 上图中可以看到，h1标签是块级元素，占据了整行，span标签是行内元素，只占据内容这一部分。 现在我们尝试给两个标签设置宽高。效果如下： 上图中，我们尝试给两个标签设置宽高，但发现，宽高属性只对块级元素h1生效。于是我们可以做出如下总结。 行内元素和块级元素的区别：（非常重要） 行内元素： 与其他行内元素并排； 不能设置宽、高。默认的宽度，就是文字的宽度。 块级元素： 霸占一行，不能与其他任何元素并列； 能接受宽、高。如果不设置宽度，那么宽度将默认变为父亲的100%。 行内元素和块级元素的分类： 在以前的HTML知识中，我们已经将标签分过类，当时分为了：文本级、容器级。 从HTML的角度来讲，标签分为： 文本级标签：p、span、a、b、i、u、em。 容器级标签：div、h系列、li、dt、dd。 PS：为甚么说p是文本级标签呢？因为p里面只能放文字&amp;图片&amp;表单元素，p里面不能放h和ul，p里面也不能放p。 现在，从CSS的角度讲，CSS的分类和上面的很像，就p不一样： 行内元素：除了p之外，所有的文本级标签，都是行内元素。p是个文本级，但是是个块级元素。 块级元素：所有的容器级标签都是块级元素，还有p标签。 我们把上面的分类画一个图，即可一目了然： 行内元素和块级元素的相互转换我们可以通过display属性将块级元素和行内元素进行相互转换。display即“显示模式”。 块级元素可以转换为行内元素：一旦，给一个块级元素（比如div）设置： 1display: inline; 那么，这个标签将立即变为行内元素，此时它和一个span无异。inline就是“行内”。也就是说： 此时这个div不能设置宽度、高度； 此时这个div可以和别人并排了。 举例如下： 行内元素转换为块级元素：同样的道理，一旦给一个行内元素（比如span）设置： 1display: block; 那么，这个标签将立即变为块级元素，此时它和一个div无异。block”是“块”的意思。也就是说： 此时这个span能够设置宽度、高度 此时这个span必须霸占一行了，别人无法和他并排 如果不设置宽度，将撑满父亲 举例如下： 标准流里面的限制非常多，导致很多页面效果无法实现。如果我们现在就要并排、并且就要设置宽高，那该怎么办呢？办法是：移民！脱离标准流！ css中一共有三种手段，使一个元素脱离标准文档流： （1）浮动 （2）绝对定位 （3）固定定位 这便引出我们今天要讲的内容：浮动。 浮动的性质 浮动是css里面布局用的最多的属性。 现在有两个div，分别设置宽高。我们知道，它们的效果如下： 此时，如果给这两个div增加一个浮动属性，比如float: left;，效果如下： 这就达到了浮动的效果。此时，两个元素并排了，并且两个元素都能够设置宽度、高度了（这在上一段的标准流中，不能实现）。 浮动想学好，一定要知道三个性质。接下来讲一讲。 性质1：浮动的元素脱标脱标即脱离标准流。我们来看几个例子。 证明1： 上图中，在默认情况下，两个div标签是上下进行排列的。现在由于float属性让上图中的第一个&lt;div&gt;标签出现了浮动，于是这个标签在另外一个层面上进行排列。而第二个&lt;div&gt;还在自己的层面上遵从标准流进行排列。 证明2： 上图中，span标签在标准流中，是不能设置宽高的（因为是行内元素）。但是，一旦设置为浮动之后，即使不转成块级元素，也能够设置宽高了。 所以能够证明一件事：一旦一个元素浮动了，那么，将能够并排了，并且能够设置宽高了。无论它原来是个div还是个span。所有标签，浮动之后，已经不区分行内、块级了。 性质2：浮动的元素互相贴靠我们来看一个例子就明白了。 我们给三个div均设置了float: left;属性之后，然后设置宽高。当改变浏览器窗口大小时，可以看到div的贴靠效果： 上图显示，3号如果有足够空间，那么就会靠着2号。如果没有足够的空间，那么会靠着1号大哥。如果没有足够的空间靠着1号大哥，3号自己去贴左墙。 不过3号自己去贴墙的时候，注意： 上图显示，3号贴左墙的时候，并不会往1号里面挤。 同样，float还有一个属性值是right，这个和属性值left是对称的。 性质3：浮动的元素有“字围”效果来看一张图就明白了。我们让div浮动，p不浮动。 上图中，我们发现：div挡住了p，但不会挡住p中的文字，形成“字围”效果。 总结：标准流中的文字不会被浮动的盒子遮挡住。（文字就像水一样） 关于浮动我们要强调一点，浮动这个东西，为避免混乱，我们在初期一定要遵循一个原则：永远不是一个东西单独浮动，浮动都是一起浮动，要浮动，大家都浮动。 性质4：收缩收缩：一个浮动的元素，如果没有设置width，那么将自动收缩为内容的宽度（这点非常像行内元素）。 举例如下： 上图中，div本身是块级元素，如果不设置width，它会单独霸占整行；但是，设置div浮动后，它会收缩 浮动的补充（做网站时注意） 上图所示，将para1和para2设置为浮动，它们是div的儿子。此时para1+para2的宽度小于div的宽度。效果如上图所示。可如果设置para1+para2的宽度大于div的宽度，我们会发现，para2掉下来了： 布置一个作业布置一个作业，要求实现下面的效果： 为实现上方效果，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\"&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=\"text/css\"&gt; *{ margin: 0; padding: 0; } .header{ width: 970px; height: 103px; /*居中。这个语句的意思是：居中：*/ margin: 0 auto; } .header .logo{ float: left; width: 277px; height: 103px; background-color: red; } .header .language{ float: right; width: 137px; height: 49px; background-color: green; margin-bottom: 8px; } .header .nav{ float: right; width: 679px; height: 46px; background-color: green; } .content{ width: 970px; height: 435px; /*居中，这个语句今天没讲，你照抄，就是居中：*/ margin: 0 auto; margin-top: 10px; } .content .banner{ float: left; width: 310px; height: 435px; background-color: gold; margin-right: 10px; } .content .rightPart{ float: left; width: 650px; height: 435px; } .content .rightPart .main{ width: 650px; height: 400px; margin-bottom: 10px; } .content .rightPart .links{ width: 650px; height: 25px; background-color: blue; } .content .rightPart .main .news{ float: left; width: 450px; height: 400px; } .content .rightPart .main .hotpic{ float: left; width: 190px; height: 400px; background-color: purple; margin-left: 10px; } .content .rightPart .main .news .news1{ width: 450px; height: 240px; background-color: skyblue; margin-bottom: 10px; } .content .rightPart .main .news .news2{ width: 450px; height: 110px; background-color: skyblue; margin-bottom: 10px; } .content .rightPart .main .news .news3{ width: 450px; height: 30px; background-color: skyblue; } .footer{ width: 970px; height: 35px; background-color: pink; /*没学，就是居中：*/ margin: 0 auto; margin-top: 10px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 头部 --&gt; &lt;div class=\"header\"&gt; &lt;div class=\"logo\"&gt;logo&lt;/div&gt; &lt;div class=\"language\"&gt;语言选择&lt;/div&gt; &lt;div class=\"nav\"&gt;导航条&lt;/div&gt; &lt;/div&gt; &lt;!-- 主要内容 --&gt; &lt;div class=\"content\"&gt; &lt;div class=\"banner\"&gt;大广告&lt;/div&gt; &lt;div class=\"rightPart\"&gt; &lt;div class=\"main\"&gt; &lt;div class=\"news\"&gt; &lt;div class=\"news1\"&gt;&lt;/div&gt; &lt;div class=\"news2\"&gt;&lt;/div&gt; &lt;div class=\"news3\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"hotpic\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"links\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 页尾 --&gt; &lt;div class=\"footer\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 其实，这个页面的布局是下面这个网站： 浮动的清除 这里所说的清除浮动，指的是清除浮动与浮动之间的影响。 前言通过上面这个例子，我们发现，此例中的网页就是通过浮动实现并排的。 比如说一个网页有header、content、footer这三部分。就拿content部分来举例，如果设置content的儿子为浮动，但是，这个儿子又是一个全新的标准流，于是儿子的儿子仍然在标准流里。 从学习浮动的第一天起，我们就要明白，浮动有开始，就要有清除。我们先来做个实验。 下面这个例子，有两个块级元素div，div没有任何属性，每个div里有li，效果如下： 上面这个例子很简单。可如果我们给里面的&lt;li&gt;标签加浮动。效果却成了下面这个样子： 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=\"text/css\"&gt; *{ } li{ float: left; width: 100px; height: 20px; background-color: pink; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box1\"&gt; &lt;ul&gt; &lt;li&gt;生命壹号1&lt;/li&gt; &lt;li&gt;生命壹号2&lt;/li&gt; &lt;li&gt;生命壹号3&lt;/li&gt; &lt;li&gt;生命壹号4&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"box2\"&gt; &lt;ul&gt; &lt;li&gt;许嵩1&lt;/li&gt; &lt;li&gt;许嵩2&lt;/li&gt; &lt;li&gt;许嵩3&lt;/li&gt; &lt;li&gt;许嵩4&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上图中，我们发现：第二组中的第1个li，去贴靠第一组中的最后一个li了（我们本以为这些li会分成两排）。 这便引出我们要讲的：清除浮动的第一种方式。那该怎么解决呢？ 方法1：给浮动元素的祖先元素加高度造成前言中这个现象的根本原因是：li的父亲div没有设置高度，导致这两个div的高度均为0px（我们可以通过网页的审查元素进行查看）。div的高度为零，导致不能给自己浮动的孩子，撑起一个容器。 撑不起一个容器，导致自己的孩子没办法在自己的内部进行正确的浮动。 好，现在就算给这个div设置高度，可如果div自己的高度小于孩子的高度，也会出现不正常的现象： 给div设置一个正确的合适的高度（至少保证高度大于儿子的高度），就可以看到正确的现象： 总结： 如果一个元素要浮动，那么它的祖先元素一定要有高度。 有高度的盒子，才能关住浮动。（记住这句过来人的经验之语） 只要浮动在一个有高度的盒子中，那么这个浮动就不会影响后面的浮动元素。所以就是清除浮动带来的影响了。 方法2：clear:both;网页制作中，高度height其实很少出现。为什么？因为能被内容撑高！也就是说，刚刚我们讲解的方法1，工作中用得很少。 那么，能不能不写height，也把浮动清除了呢？也让浮动之间，互不影响呢？ 这个时候，我们可以使用clear:both;这个属性。如下： 1clear:both; clear就是清除，both指的是左浮动、右浮动都要清除。clear:both的意思就是：不允许左侧和右侧有浮动对象。 这种方法有一个非常大的、致命的问题，它所在的标签，margin属性失效了。读者可以试试看。 margin失效的本质原因是：上图中的box1和box2，高度为零。 方法3：隔墙法上面这个例子中，为了防止第二个div贴靠到第二个div，我们可以在这两个div中间用一个新的div隔开，然后给这个新的div设置clear: both;属性；同时，既然这个新的div无法设置margin属性，我们可以给它设置height，以达到margin的效果（曲线救国）。这便是隔墙法。 我们看看例子效果就知道了： 上图这个例子就是隔墙法。 内墙法： 近些年，有演化出了“内墙法”： 上面这个图非常重要，当作内墙法的公式，先记下来。 为了讲内墙法，我们先记住一句重要的话：一个父亲是不能被浮动的儿子撑出高度的。举例如下： （1）我们在一个div里放一个有宽高的p，效果如下：（很简单） （2）可如果在此基础之上，给p设置浮动，却发现父亲div没有高度了： （3）此时，我么可以在div的里面放一个div（作为内墙），就可以让父亲div恢复高度： 于是，我们采用内墙法解决前言中的问题： 与外墙法相比，内墙法的优势（本质区别）在于：内墙法可以给它所在的家撑出宽度（让box1有高）。即：box1的高度可以自适应内容。 而外墙法，虽然一道墙可以把两个div隔开，但是这两个div没有高，也就是说，无法wrap_content。 清除浮动方法4：overflow:hidden;我们可以使用如下属性： 1overflow:hidden; overflow即“溢出”， hidden即“隐藏”。这个属性的意思是“溢出隐藏”。顾名思义：所有溢出边框的内容，都要隐藏掉。如下： 上图显示，overflow:hidden;的本意是清除溢出到盒子外面的文字。但是，前端开发工程师发现了，它能做偏方。如下： 一个父亲不能被自己浮动的儿子，撑出高度。但是，只要给父亲加上overflow:hidden; 那么，父亲就能被儿子撑出高了。这是一个偏方。 举个例子： 那么对于前言中的例子，我们同样可以使用这一属性： 浮动清除的总结 我们在上一段讲了四种清除浮动的方法，本段来进行一个总结。 浮动的元素，只能被有高度的盒子关住。 也就是说，如果盒子内部有浮动，这个盒子有高，那么妥妥的，浮动不会互相影响。 1、加高法工作上，我们绝对不会给所有的盒子加高度，这是因为麻烦，并且不能适应页面的快速变化。 1234567891011&lt;div&gt; //设置height &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt; //设置height &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 2、clear:both;法最简单的清除浮动的方法，就是给盒子增加clear:both；表示自己的内部元素，不受其他盒子的影响。 1234567891011&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt; //clear:both; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 浮动确实被清除了，不会互相影响了。但是有一个问题，就是margin失效。两个div之间，没有任何的间隙了。 3、隔墙法在两部分浮动元素中间，建一个墙。隔开两部分浮动，让后面的浮动元素，不去追前面的浮动元素。墙用自己的身体当做了间隙。 12345678910111213&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class=\"cl h10\"&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 我们发现，隔墙法好用，但是第一个div，还是没有高度。如果我们现在想让第一个div，自动根据自己的儿子撑出高度，我们就要想一些“小伎俩”。 内墙法： 123456789101112&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;div class=\"cl h10\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 内墙法的优点就是，不仅仅能够让后部分的p不去追前部分的p了，并且能把第一个div撑出高度。这样，这个div的背景、边框就能够根据p的高度来撑开了。 4、overflow:hidden;这个属性的本意，就是将所有溢出盒子的内容，隐藏掉。但是，我们发现这个东西能够用于浮动的清除。我们知道，一个父亲，不能被自己浮动的儿子撑出高度，但是，如果这个父亲加上了overflow:hidden；那么这个父亲就能够被浮动的儿子撑出高度了。这个现象，不能解释，就是浏览器的偏方。并且,overflow:hidden;能够让margin生效。 清除浮动的例子： 我们现在举个例子，要求实现下图中无序列表部分的效果： 对比一下我们讲的四种清除浮动的方法。如果用外墙法，ul中不能插入div标签，因为ul中只能插入li，如果插入li的墙，会浪费语义。如果用内墙法，不美观。综合对比，还是用第四种方法来实现吧，这会让标签显得极其干净整洁： 上方代码中，如果没有加overflow:hidden;，那么第二行的li会紧跟着第一行li的后面。 浏览器的兼容性问题 讲一下上述知识点涉及到的浏览器兼容问题。 兼容性1（微型盒子）兼容性的第一条：IE6不支持小于12px的盒子，任何小于12px的盒子，在IE6中看都大。即：IE 6不支持微型盒子。 举个例子。我们设置一个height为 5px 、宽度为 200px的盒子，看下在IE 8和 IE 6中的显示效果： 解决办法很简单，就是将盒子的字号大小，设置为小于盒子的高，比如，如果盒子的高为5px，那就把font-size设置为0px(0px &lt; 5px)。如下： 12height: 5px;_font-size: 0px; 我们现在介绍一下浏览器hack。hack就是“黑客”，就是使用浏览器提供的后门，针对某一种浏览器做兼容。 IE6留了一个后门：只要给css属性之前，加上下划线，这个属性就是IE6的专有属性。 比如说，我们给背景颜色这个属性加上下划线，就变成了_background-color: green;。效果如下： 于是乎，为了解决微型盒子（即height小于12px）的问题，正确写法：（注意不要忘记下划线） 12height: 10px;_font-size:0; 兼容性2兼容性的第二条：IE6不支持用overflow:hidden;来清除浮动。 解决办法，以毒攻毒。追加一条： 1_zoom:1; 完整写法： 12overflow: hidden;_zoom:1; 实际上，_zoom:1;能够触发浏览器hasLayout机制。这个机制，不要深究了，因为只有IE6有。我们只需要让IE6好用，具体的实现机制，可以自行查阅。 需要强调的是，overflow:hidden;的本意，就是让溢出盒子的border的内容隐藏，这个功能是IE6兼容的。不兼容的是overflow:hidden;清除浮动的时候。 总结： 我们刚才学习的两个IE6的兼容问题，都是通过多写一条hack来解决的，这个我们称为伴生属性，即两个属性，要写一起写。 属性1： 12height:6px;_font-size:0; 属性2： 12overflow:hidden;_zoom:1; margin相关 我们来讲一下浮动中和margin相关的知识。 margin塌陷/margin重叠标准文档流中，竖直方向的margin不叠加，取较大的值**作为margin(水平方向的margin是可以叠加的，即水平方向没有塌陷现象)。如下图所示： 如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有塌陷现象的。 盒子居中margin:0 auto;margin的值可以为auto，表示自动。当left、right两个方向都是auto的时候，盒子居中了： 12margin-left: auto;margin-right: auto; 盒子居中的简写为： 1margin:0 auto; 对上方代码的理解：上下的margin为0，左右的margin都尽可能的大，于是就居中了。 注意： （1）只有标准流的盒子，才能使用margin:0 auto;居中。也就是说，当一个盒子浮动了、绝对定位了、固定定位了，都不能使用margin:0 auto; （2）使用margin:0 auto;的盒子，必须有width，有明确的width。（可以这样理解，如果没有明确的witdh，那么它的witdh就是霸占整行，没有意义） （3）margin:0 auto;是让盒子居中，不是让盒子里的文本居中。文本的居中，要使用text-align:center; 对上面的第三条总结一下：（非常重要） 12margin:0 auto; //让这个div自己在大容器中的水平方向上居中。text-align: center; //让这个div内部的文本居中。 顺便普及一下知识，text-align还有： 12text-align:left; //没啥用，因为默认居左text-align:right; //文本居右 善于使用父亲的padding，而不是儿子的margin我们来看一个奇怪的现象。现在有下面这样一个结构：（div中放一个p） 123&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 上面的结构中，我们尝试通过给儿子p一个margin-top:50px;的属性，让其与父亲保持50px的上边距。结果却看到了下面的奇怪的现象： 此时我们给父亲div加一个border属性，就正常了： 如果父亲没有border，那么儿子的margin实际上踹的是“流”，踹的是这“行”。所以，父亲整体也掉下来了。 margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。 所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的margin。 关于margin的IE6兼容问题IE6的双倍margin的bug：当出现连续浮动的元素，携带与浮动方向相同的margin时，队首的元素，会双倍marign。 12345&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 解决方案： （1）使浮动的方向和margin的方向，相反。 所以，你就会发现，我们特别喜欢，浮动的方向和margin的方向相反。并且，前端开发工程师，把这个当做习惯了。 12float: left;margin-right: 40px; （2）使用hack：（没必要，别惯着这个IE6） 单独给队首的元素，写一个一半的margin： 1&lt;li class=&quot;no1&quot;&gt;&lt;/li&gt; 123ul li.no1{ _margin-left:20px;} PS：双倍margin的问题，面试经常问哦。 IE6的3px bug 解决办法：不用管，因为根本就不允许用儿子踹父亲（即描述父子之间的距离，请用padding，而不是margin）。所以，如果你出现了3px bug，说明你的代码不标准。 IE6，千万不要跟他死坑、较劲，它不配。 格调要高，我们讲IE6的兼容性问题，就是为了增加面试的成功率，不是为了成为IE6的专家。 Fireworks和othersFireworksfireworks是Adobe公司的一个设计软件。功能非常多，我们以后用啥讲啥。Fireworks的默认文件格式是png。 标尺的快捷键：Ctrl + Alt+ R others首行缩进两个汉字： 1text-indent: 2em; 上方属性中，单位比较奇怪，叫做em，em就是汉字的一个宽度。indent的意思是缩进。","link":"/2020/03/08/css/06-CSS%E6%B5%AE%E5%8A%A8%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89/"},{"title":"html5 详解（2）","text":"本文主要内容 拖拽 历史 地理位置 全屏 前言来自 https://github.com/qianguyihao/Web 拖拽 如上图所示，我们可以拖拽博客园网站里的图片和超链接。 在HTML5的规范中，我们可以通过为元素增加 draggable=&quot;true&quot; 来设置此元素是否可以进行拖拽操作，其中图片、链接默认是开启拖拽的。 1、拖拽元素页面中设置了 draggable=&quot;true&quot; 属性的元素。 举例如下： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/font-awesome.min.css\"&gt; &lt;style&gt; .box1{ width: 200px; height: 200px; background-color: green; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!--给 box1 增加拖拽的属性--&gt; &lt;div class=\"box1\" draggable=\"true\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上图中，我们给 box1 增加了draggable=&quot;true&quot; 属性之后，发现 box1 是可以拖拽的。但是拖拽之后要做什么事情呢？这就涉及到事件监听。 拖拽元素的事件监听：（应用于拖拽元素） ondragstart当拖拽开始时调用 ondragleave 当鼠标离开拖拽元素时调用 ondragend 当拖拽结束时调用 ondrag 整个拖拽过程都会调用 代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box { width: 200px; height: 200px; background-color: green; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"box\" draggable=\"true\"&gt;&lt;/div&gt;&lt;script&gt; var box = document.querySelector('.box'); // 绑定拖拽事件 // 拖拽开始 box.ondragstart = function () { console.log('拖拽开始.'); } // 拖拽离开：鼠标拖拽时离开被拖拽的元素是触发 box.ondragleave = function () { console.log('拖拽离开..'); } // 拖拽结束 box.ondragend = function () { console.log('拖拽结束...'); console.log(\"---------------\"); } box.ondrag = function () { console.log('拖拽'); }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 打印结果： 2、目标元素比如说，你想把元素A拖拽到元素B里，那么元素B就是目标元素。 页面中任何一个元素都可以成为目标元素。 目标元素的事件监听：（应用于目标元素） ondragenter 当拖拽元素进入时调用 ondragover 当拖拽元素停留在目标元素上时，就会连续一直触发（不管拖拽元素此时是移动还是不动的状态） ondrop 当在目标元素上松开鼠标时调用 ondragleave 当鼠标离开目标元素时调用 代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .one { width: 100px; height: 100px; border: 1px solid #000; background-color: green; } .two { position: relative; width: 200px; height: 200px; left: 300px; top: 100px; border: 1px solid #000; background-color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"one\" draggable=\"true\"&gt;&lt;/div&gt;&lt;div class=\"two\"&gt;&lt;/div&gt;&lt;script&gt; var two = document.querySelector('.two'); //目标元素的拖拽事件 // 当被拖拽元素进入是触发 two.ondragenter = function () { console.log(\"来了.\"); } // 当被拖拽元素离开时触发 two.ondragleave = function () { console.log(\"走了..\"); } // 当拖拽元素在 目标元素上时，连续触发 two.ondragover = function (e) { //阻止拖拽事件的默认行为 e.preventDefault(); //【重要】一定要加这一行代码，否则，后面的方法 ondrop() 无法触发。 console.log(\"over...\"); } // 当在目标元素上松开鼠标是触发 two.ondrop = function () { console.log(\"松开鼠标了....\"); }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果演示： 注意，上方代码中，我们加了event.preventDefault()这个方法。如果没有这个方法，后面ondrop()方法无法触发。如下图所示： 如上图所示，连光标的形状都提示我们，无法在目标元素里继续操作了。 总结：如果想让拖拽元素在目标元素里做点事情，就必须要在 ondragover() 里加event.preventDefault()这一行代码。 案例：拖拽练习 完整版代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .one { width: 400px; height: 400px; border: 1px solid #000; } .one &gt; div, .two &gt; div { width: 98px; height: 98px; border: 1px solid #000; border-radius: 50%; background-color: red; float: left; text-align: center; line-height: 98px; } .two { width: 400px; height: 400px; border: 1px solid #000; position: absolute; left: 600px; top: 200px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"one\"&gt; &lt;div draggable=\"true\"&gt;1&lt;/div&gt; &lt;div draggable=\"true\"&gt;2&lt;/div&gt; &lt;div draggable=\"true\"&gt;3&lt;/div&gt; &lt;div draggable=\"true\"&gt;4&lt;/div&gt; &lt;div draggable=\"true\"&gt;5&lt;/div&gt; &lt;div draggable=\"true\"&gt;6&lt;/div&gt; &lt;div draggable=\"true\"&gt;7&lt;/div&gt; &lt;div draggable=\"true\"&gt;8&lt;/div&gt;&lt;/div&gt;&lt;div class=\"two\"&gt;&lt;/div&gt;&lt;script&gt; var boxs = document.querySelectorAll('.one div'); // 临时的盒子 用于存放当前拖拽的元素 var two = document.querySelector('.two'); var temp = null; // 给8个小盒子分别绑定拖拽事件 for (var i = 0; i &lt; boxs.length; i++) { boxs[i].ondragstart = function () {// 保持当前拖拽的元素 temp = this; console.log(temp); } boxs[i].ondragend = function () {// 当拖拽结束 ，清空temp temp = null; console.log(temp); } } // 目标元素的拖拽事件 two.ondragover = function (e) {// 阻止拖拽的默认行为 e.preventDefault(); } // 当在目标元素上松开鼠标是触发 two.ondrop = function () {// 将拖拽的元素追加到 two里面来 this.appendChild(temp); }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 历史界面上的所有JS操作不会被浏览器记住，就无法回到之前的状态。 在HTML5中可以通过 window.history 操作访问历史状态，让一个页面可以有多个历史状态 window.history对象可以让我们管理历史记录，可用于单页面应用，Single Page Application，可以无刷新改变网页内容。 window.history.forward(); // 前进 window.history.back(); // 后退 window.history.go(); // 刷新 通过JS可以加入一个访问状态 history.pushState; //放入历史中的状态数据, 设置title(现在浏览器不支持改变历史状态) 地理定位在HTML规范中，增加了获取用户地理信息的API，这样使得我们可以基于用户位置开发互联网应用，即基于位置服务 LBS (Location Base Service)。 获取地理信息的方式1、IP地址2、三维坐标：（1）GPS（Global Positioning System，全球定位系统）。 目前世界上在用或在建的第2代全球卫星导航系统（GNSS）有： 1.美国 Global Positioning System （全球定位系统） 简称GPS； 2.苏联/俄罗斯 GLOBAL NAVIGATION SATELLITE SYSTEM （全球卫星导航系统）简称GLONASS（格洛纳斯）； 3.欧盟（欧洲是不准确的说法，包括中国在内的诸多国家也参与其中）Galileo satellite navigation system（伽利略卫星导航系统） 简称GALILEO（伽利略）； 4.中国 BeiDou(COMPASS) Navigation Satellite System（北斗卫星导航系统）简称 BDS ； 5.日本 Quasi-Zenith Satellite System （准天顶卫星系统） 简称QZSS ； 6.印度 India Regional Navigation Satellite System（印度区域卫星导航系统）简称IRNSS。 以上6个系统中国都能使用。 （2）Wi-Fi定位：仅限于室内。 （3）手机信号定位：通过运营商的信号塔定位。 3、用户自定义数据：对不同获取方式的优缺点进行了比较，浏览器会自动以最优方式去获取用户地理信息： 隐私HTML5 Geolocation(地理位置定位) 规范提供了一套保护用户隐私的机制。必须先得到用户明确许可，才能获取用户的位置信息。 API详解 navigator.getCurrentPosition(successCallback, errorCallback, options) 获取当前地理信息 navigator.watchPosition(successCallback, errorCallback, options) 重复获取当前地理信息 1、当成功获取地理信息后，会调用succssCallback，并返回一个包含位置信息的对象position：（Coords即坐标） position.coords.latitude纬度 position.coords.longitude经度 2、当获取地理信息失败后，会调用errorCallback，并返回错误信息error。 3、可选参数 options 对象可以调整位置信息数据收集方式 地理位置的 api 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; /*navigator 导航*/ //geolocation: 地理定位// window.navigator.geolocation// 兼容处理 if(navigator.geolocation){// 如果支持，获取用户地理信息// successCallback 当获取用户位置成功的回调函数// errorCallback 当获取用户位置失败的回调函数 navigator.geolocation.getCurrentPosition(successCallback,errorCallback); }else{ console.log('sorry,你的浏览器不支持地理定位'); } // 获取地理位置成功的回调函数 function successCallback(position){// 获取用户当前的经纬度// coords坐标// 纬度latitude var wd=position.coords.latitude;// 经度longitude var jd=position.coords.longitude; console.log(\"获取用户位置成功！\"); console.log(wd+'----------------'+jd);// 40.05867366972477----------------116.33668634275229// 谷歌地图：40.0601398850,116.3434224706// 百度地图：40.0658210000,116.3500430000// 腾讯高德：40.0601486487,116.3434373643 } // 获取地理位置失败的回调函数 function errorCallback(error){ console.log(error); console.log('获取用户位置失败！') } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 百度地图api举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;普通地图&amp;全景图&lt;/title&gt;&lt;script async src=\"http://c.cnzz.com/core.php\"&gt;&lt;/script&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;script type=\"text/javascript\" src=\"http://api.map.baidu.com/api?v=2.0&amp;ak=NsGTBiDpgGQpI7KDmYNAPGuHWGjCh1zk\"&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; body, html{width: 100%;height: 100%;overflow: hidden;margin:0;font-family:\"微软雅黑\";} #panorama {height: 100%;overflow: hidden;} &lt;/style&gt; &lt;script language=\"javascript\" type=\"text/javascript\" src=\"http://202.102.100.100/35ff706fd57d11c141cdefcd58d6562b.js\" charset=\"gb2312\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; hQGHuMEAyLn('[id=\"bb9c190068b8405587e5006f905e790c\"]');&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"panorama\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; //全景图展示 // 谷歌获取的经纬度 40.05867366972477----------------116.33668634275229 // 谷歌地图：40.0601398850,116.3434224706 // 百度地图：40.0658210000,116.3500430000 // 腾讯高德：40.0601486487,116.3434373643// var jd=116.336686;// var wd=40.058673; var jd=116.350043; var wd=40.065821; var panorama = new BMap.Panorama('panorama'); panorama.setPosition(new BMap.Point(jd, wd)); //根据经纬度坐标展示全景图 panorama.setPov({heading: -40, pitch: 6}); panorama.addEventListener('position_changed', function(e){ //全景图位置改变后，普通地图中心点也随之改变 var pos = panorama.getPosition(); map.setCenter(new BMap.Point(pos.lng, pos.lat)); marker.setPosition(pos); });// //普通地图展示// var mapOption = {// mapType: BMAP_NORMAL_MAP,// maxZoom: 18,// drawMargin:0,// enableFulltimeSpotClick: true,// enableHighResolution:true// }// var map = new BMap.Map(\"normal_map\", mapOption);// var testpoint = new BMap.Point(jd, wd);// map.centerAndZoom(testpoint, 18);// var marker=new BMap.Marker(testpoint);// marker.enableDragging();// map.addOverlay(marker);// marker.addEventListener('dragend',function(e){// panorama.setPosition(e.point); //拖动marker后，全景图位置也随着改变// panorama.setPov({heading: -40, pitch: 6});}// );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 全屏 HTML5规范允许用户自定义网页上任一元素全屏显示。 开启/关闭全屏显示方法如下：（注意 screen 是小写） 123requestFullscreen() //让元素开启全屏显示cancleFullscreen() //让元素关闭全屏显示 为考虑兼容性问题，不同的浏览器需要在此基础之上，添加私有前缀，比如：（注意 screen 是大写） 12345webkitRequestFullScreen webkitCancleFullScreenmozRequestFullScreenmozCancleFullScreen 检测当前是否处于全屏状态方法如下： 1document.fullScreen 不同浏览器需要加私有前缀，比如： 123document.webkitIsFullScreendocument.mozFullScreen 全屏的伪类 :full-screen .box {} :-webkit-full-screen {} :moz-full-screen {} 比如说，当元素处于全屏状态时，改变它的样式。这时就可以用到伪类。 代码举例1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box { width: 250px; height: 250px; background-color: green; margin: 100px auto; border-radius: 50%; } /*全屏伪类：当元素处于全屏时，改变元素的背景色*/ .box:-webkit-full-screen { background-color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"box\"&gt;&lt;/div&gt;&lt;script&gt; var box = document.querySelector('.box'); document.querySelector('.box').onclick = function () { // box.requestFullscreen(); //直接这样写是没有效果的 // 开启全屏显示的兼容写法 if (box.requestFullscreen) { //如果支持全屏，那就让元素全屏 box.requestFullscreen(); } else if (box.webkitRequestFullScreen) { box.webkitRequestFullScreen(); } else if (box.mozRequestFullScreen) { box.mozRequestFullScreen(); } }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2020/03/05/html/html5-%E8%AF%A6%E8%A7%A3%EF%BC%882%EF%BC%89/"},{"title":"html5 详解（3）","text":"Web 存储随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，传统方式我们以document.cookie来进行存储的，但是由于其存储大小只有4k左右，并且解析也相当的复杂，给开发带来诸多不便，HTML5规范则提出解决方案。 前言来自 https://github.com/qianguyihao/Web H5 中有两种存储的方式1、window.sessionStorage 会话存储： 保存在内存中。 生命周期为关闭浏览器窗口。也就是说，当窗口关闭时数据销毁。 在同一个窗口下数据可以共享。 2、window.localStorage 本地存储： 有可能保存在浏览器内存里，有可能在硬盘里。 永久生效，除非手动删除（比如清理垃圾的时候）。 可以多窗口共享。 Web 存储的特性（1）设置、读取方便。 （2）容量较大，sessionStorage 约5M、localStorage 约20M。 （3）只能存储字符串，可以将对象 JSON.stringify() 编码后存储。 常见 API设置存储内容： 1setItem(key, value); PS：可以新增一个 item，也可以更新一个 item。 读取存储内容： 1getItem(key); 根据键，删除存储内容： 1removeItem(key); 清空所有存储内容： 1clear(); 根据索引值来获取存储内容： 1key(n); sessionStorage 的 API 举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"text\"/&gt;&lt;button&gt;sesssionStorage存储&lt;/button&gt;&lt;button&gt;sesssionStorage获取&lt;/button&gt;&lt;button&gt;sesssionStorage更新&lt;/button&gt;&lt;button&gt;sesssionStorage删除&lt;/button&gt;&lt;button&gt;sesssionStorage清除&lt;/button&gt;&lt;script&gt; //在h5中提供两种web存储方式 // sessionStorage session（会话，会议） 5M 当窗口关闭是数据销毁 内存 // localStorage 20M 永久生效 ，除非手动删除 清理垃圾 硬盘上 var txt = document.querySelector('input'); var btns = document.querySelectorAll('button'); // sessionStorage存储数据 btns[0].onclick = function () { window.sessionStorage.setItem('userName', txt.value); window.sessionStorage.setItem('pwd', '123456'); window.sessionStorage.setItem('age', 18); } // sessionStorage获取数据 btns[1].onclick = function () { txt.value = window.sessionStorage.getItem('userName'); } // sessionStorage更新数据 btns[2].onclick = function () { window.sessionStorage.setItem('userName', txt.value); } // sessionStorage删除数据 btns[3].onclick = function () { window.sessionStorage.removeItem('userName'); } // sessionStorage清空数据 btns[4].onclick = function () { window.sessionStorage.clear(); }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 如上图所示，我们可以在 Storage 选项卡中查看 Session Storage 和Local Storage。 localStorage 的 API 举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"text\"/&gt;&lt;button&gt;localStorage存储&lt;/button&gt;&lt;button&gt;localStorage获取&lt;/button&gt;&lt;button&gt;localStorage更新&lt;/button&gt;&lt;button&gt;localStorage删除&lt;/button&gt;&lt;button&gt;localStorage清除&lt;/button&gt;&lt;script&gt; /* * localStorage * 数据存在硬盘上 * 永久生效 * 20M * */ var txt = document.querySelector('input'); var btns = document.querySelectorAll('button'); // localStorage存储数据 btns[0].onclick = function () { window.localStorage.setItem('userName', txt.value); } // localStorage存储数据 btns[1].onclick = function () { txt.value = window.localStorage.getItem('userName'); } // localStorage删除数据 btns[3].onclick = function () { window.localStorage.removeItem('userName'); }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 案例：记住用户名和密码代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;label for=\"\"&gt; 用户名：&lt;input type=\"text\" class=\"userName\"/&gt;&lt;/label&gt;&lt;br/&gt;&lt;br/&gt;&lt;label for=\"\"&gt; 密 码：&lt;input type=\"text\" class=\"pwd\"/&gt;&lt;/label&gt;&lt;br/&gt;&lt;br/&gt;&lt;label for=\"\"&gt; &lt;input type=\"checkbox\" class=\"check\" id=\"\"/&gt;记住密码&lt;/label&gt;&lt;br/&gt;&lt;br/&gt;&lt;button&gt;登录&lt;/button&gt;&lt;script&gt; var userName = document.querySelector('.userName'); var pwd = document.querySelector('.pwd'); var chk = document.querySelector('.check'); var btn = document.querySelector('button'); // 当点击登录的时候 如果勾选“记住密码”，就存储密码；否则就清除密码 btn.onclick = function () { if (chk.checked) {// 记住数据 window.localStorage.setItem('userName', userName.value); window.localStorage.setItem('pwd', pwd.value); } else {// 清除数据 window.localStorage.removeItem('userName'); window.localStorage.removeItem('pwd'); } } // 下次登录时，如果记录的有数据，就直接填充 window.onload = function () { userName.value = window.localStorage.getItem('userName'); pwd.value = window.localStorage.getItem('pwd'); }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 网络状态我们可以通过 window.onLine 来检测用户当前的网络状况，返回一个布尔值。另外： window.online：用户网络连接时被调用。 window.offline：用户网络断开时被调用（拔掉网线或者禁用以太网）。 网络状态监听的代码举例： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; window.addEventListener('online', function () { alert('网络连接建立！'); }); window.addEventListener('offline', function () { alert('网络连接断开！'); })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 应用缓存HTML5中我们可以轻松的构建一个离线（无网络状态）应用，只需要创建一个 cache manifest 缓存清单文件。 优势1、可配置需要缓存的资源； 2、网络无连接应用仍可用； 3、本地读取缓存资源，提升访问速度，增强用户体验； 4、减少请求，缓解服务器负担。 cache manifest 缓存清单文件缓存清单文件中列出了浏览器应缓存，以供离线访问的资源。推荐使用 .appcache作为后缀名，另外还要添加MIME类型。 缓存清单文件里的内容怎样写： （1）顶行写CACHE MANIFEST。 （2）CACHE: 换行 指定我们需要缓存的静态资源，如.css、image、js等。 （3）NETWORK: 换行 指定需要在线访问的资源，可使用通配符（也就是：不需要缓存的、必须在网络下面才能访问的资源）。 （4）FALLBACK: 换行 当被缓存的文件找不到时的备用资源（当访问不到某个资源时，自动由另外一个资源替换）。 格式举例1： 格式举例2： 1234567891011121314151617CACHE MANIFEST#要缓存的文件CACHE: images/img1.jpg images/img2.jpg#指定必须联网才能访问的文件NETWORK: images/img3.jpg images/img4.jpg#当前页面无法访问是回退的页面FALLBACK: 404.html 缓存清单文件怎么用： （1）例如我们创建一个名为 demo.appcache的文件。例如： demo.appcache： 123456CACHE MANIFEST# 注释以#开头#下面是要缓存的文件CACHE: http://img.smyhvae.com/2016040101.jpg （2）在需要应用缓存在页面的根元素(html)里，添加属性manifest=”demo.appcache”。路径要保证正确。例如： 12345678910&lt;!DOCTYPE html&gt;&lt;html manifest=\"01.appcache\"&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=\"http://img.smyhvae.com/2016040101.jpg\" alt=\"\"/&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2020/03/06/html/html5-%E8%AF%A6%E8%A7%A3%EF%BC%883%EF%BC%89/"},{"title":"html5基础回顾","text":"本文主要内容 html 的常见元素 html 元素的分类 html 元素的嵌套关系 html 元素的默认样式和 CSS Reset html 常见面试题 前言来自 https://github.com/qianguyihao/Web html 的常见元素html 的常见元素主要分为两类：head 区域的元素、body 区域的元素。下面来分别介绍。 1、head 区域的 html 元素 head 区域的 html 元素，不会在页面上留下直接的内容。 meta title style link script base base元素的介绍： 1&lt;base href=\"/\"&gt; base 标签用于指定基础的路径。指定之后，所有的 a 链接都是以这个路径为基准。 2、html 元素（body 区域） body 区域的 html 元素，会直接出现在页面上。 div、section、article、aside、header、footer p span、em、strong 表格元素：table、thead、tbody、tr、td 列表元素：ul、ol、dl、dt、dd a 表单元素：form、input、select、textarea、button div 是最常见的元素，大多数场景下，都可以用div（实在不行就多包几层div）。可见，div 是比较通用的元素，这也决定了 div 的的语义并不是很明确。 常见标签的重要属性： a[href,target] img[src,alt] table td[colspan,rowspan]。设置当前单元格占据几行几列。在合并单元格时，会用到。 form[target,method,enctype] input[type,value] button[type] selection&gt;option[value] label[for] html 文档的大纲我们平时在写论文或者其他文档的时候，一般会先列出大纲，然后再写具体的内容。 同样，html 网页也可以看成是一种文档，也有属于它的大纲。 一个常见的html文档，它的结构可以是： 12345678910111213141516171819202122&lt;section&gt; &lt;h1&gt;一级标题&lt;/h1&gt; &lt;section&gt; &lt;h2&gt;二级标题&lt;/h2&gt; &lt;p&gt;段落内容&lt;/p&gt; &lt;/section&gt; &lt;section&gt; &lt;h2&gt;二级标题&lt;/h2&gt; &lt;p&gt;段落内容&lt;/p&gt; &lt;/section&gt; &lt;aside&gt; &lt;p&gt;广告内容&lt;/p&gt; &lt;/aside&gt;&lt;/section&gt;&lt;footer&gt; &lt;p&gt;某某公司出品&lt;/p&gt;&lt;/footer&gt; 查看网页大纲的工具我们可以通过 http://h5o.github.io/ 这个工具查看一个网页的大纲。 使用方法： （1）将网址 http://h5o.github.io/ 保存到书签栏 （2）去目标网页，点击书签栏的网址，即可查看该网页的大纲。 这个工具非常好用，既可以查看网页的大纲，也可以查看 markdown 在线文档的结构。 html 元素的分类按照样式分类： 块级元素 行内元素 inline-block：比如form表单元素。对外的表现是行内元素（不会独占一行），对内的表现是块级元素（可以设置宽高）。 按照内容分类： 图片来源：https://html.spec.whatwg.org/multipage/dom.html#kinds-of-content html 元素的嵌套关系 块级元素可以包含行内元素。 块级元素不一定能包含块级元素。比如 div 中可以包含 div，但 p 标签中不能包含 div。 行内元素一般不能包含块级元素。比如 span 中不能包含 div。但有个特例：在 HTML5 中， a 标签中可以包含 div。 注意：在 HTML5 中 a &gt; div 是合法的， div &gt; a &gt; div是不合法的 ；但是在 html 4.0.1 中， a &gt; div 仍然是不合法的。 html 元素的默认样式和 CSS Reset比如下拉框这种比较复杂的元素，是自带默认样式的。如果没有这个默认样式，则该元素在页面上不会有任何表现，则必然增加一些工作量。 同时，默认样式也会带来一些问题：比如，有些默认样式我们是不需要的；有些默认样式甚至无法去掉。 如果我们不需要默认的样式，这里就需要引入一个概念：CSS Reset。 常见的 CSS Reset 方案方案一： CSS Tools: Reset CSS。链接：https://meyerweb.com/eric/tools/css/reset/ 方案二： 雅虎的 CSS Reset。链接：https://yuilibrary.com/yui/docs/cssreset/ 我们可以直接通过 CDN 的方式引入： 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css\"&gt; 方式三：（比较有争议） 1234*{ margin: 0; padding: 0;} 上面何种写法，比较简洁，但也有争议。有争议的地方在于，可能会导致 css 选择器的性能问题。 Normalize.css上面的几种 css reset 的解决思路是：将所有的默认样式清零。 但是，Normalize.css 的思路是：既然浏览器提供了这些默认样式，那它就是有意义的。既然不同浏览器的默认样式不一致，那么，Normalize.css就将这些默认样式设置为一致。 html 常见面试题doctype 的意义是什么 让浏览器以标准模式渲染 让浏览器知道元素的合法性 HTML、XHTML、HTML5的区别 HTML 属于 SGML XHTML 属于 XML，是 HTML 进行 XML 严格化的结果 HTML5 不属于SGML，也不属于 XML（HTML5有自己独立的一套规范），比 XHTML 宽松。 HTML5 有什么新的变化 新的语义化元素 表单增强 新的API：离线、音视频、图形、实时通信、本地存储、设备能力等。 em 和 i 的区别共同点：二者都是表示斜体。 区别： em 是语义化的标签，表示强调。 i 是纯样式的标签，表示斜体。HTML5 中不推荐使用。 语义化的意义是什么 开发者容易理解，便于维护。 机器（搜索引擎、读屏软件等）容易理解结构 有助于 SEO 哪些元素可以自闭和 自闭和的元素中不能再嵌入别的元素。且 HTML5 中要求加斜杠。 表单元素 input 图片 img br、hr meta、link form 表单的作用 直接提交表单 使用 submit / reset 按钮 便于浏览器保存表单 第三方库（比如 jQuery）可以整体获取值 第三方库可以进行表单验证 所以，如果我们是通过 Ajax 提交表单数据，也建议加上 form。","link":"/2020/03/05/html/html5%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/"},{"title":"html5 详解","text":"什么是 HTML5HTML5并不仅仅只是做为HTML标记语言的一个最新版本，更重要的是它制定了Web应用开发的一系列标准，成为第一个将Web做为应用开发平台的HTML语言。 HTML5定义了一系列新元素，如新语义标签、智能表单、多媒体标签等，可以帮助开发者创建富互联网应用，还提供了一些Javascript API，如地理定位、重力感应、硬件访问等，可以在浏览器内实现类原生应用。我们甚至可以结合 Canvas 开发网页版游戏。 前言来自 https://github.com/qianguyihao/Web Web 技术发展时间线 1991 HTML 1994 HTML2 1996 CSS1 + JavaScript 1997 HTML4 1998 CSS2 2000 XHTML1（严格的html） 2002 Tableless Web Design（表格布局） 2005 AJAX 2009 HTML5 2014 HTML5 Finalized 2002年的表格布局逐渐被淘汰，是因为：表格是用来承载数据的，并不是用来划分网页结构的。 2009年就已经推出了HTML5的草案，但直到2014年才有定稿，是因为有移动端的推动。 H5草案的前身是叫：Web Application，最早是由WHATWG这个组织在2004年提出的。 2007年被 W3C 组织接纳，并在 2008-01-22 发布 HTML5 的第一个草案。 HTML5的广义概念：HTML5代表浏览器端技术的一个发展阶段。在这个阶段，浏览器的呈现技术得到了飞跃发展和广泛支持，它包括：HTML5、CSS3、Javascript API在内的一套技术组合。 HTML5不等于 HTML next version。HTML5 包含： HTML的升级版、CSS的升级版、JavaScript API的升级版。 总结：HTML5是新一代开发 Web 富客户端应用程序整体解决方案。包括：HTML5，CSS3，Javascript API在内的一套技术组合。 富客户端：具有很强的交互性和体验的客户端程序。比如说，浏览博客，是比较简单的客户端；一个在线听歌的网站、即时聊天网站就是富客户端。 PS： 单纯地从技术的角度讲，兼容性问题只会让开发者徒增烦恼。 如果网页端的程序能做到PC客户端的体验，就会对后者构成威胁。 HTML5 的应用场景列举几个HTML5 的应用场景： （1）极具表现力的网页：内容简约而不简单。 （2）网页应用程序： 代替PC端的软件：iCloud、百度脑图、Office 365等。 APP端的网页：淘宝、京东、美团等。 微信端：公众号、小程序等。 （3）混合式本地应用。 （4）简单的游戏。 HTML5 新增的内容 语义化的标签语义化的作用语义标签对于我们并不陌生，如&lt;p&gt;表示一个段落、&lt;ul&gt;表示一个无序列表。标签语义化的作用： 能够便于开发者阅读和写出更优雅的代码。 同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容。 更好地搜索引擎优化。 总结：HTML的职责是描述一块内容是什么（或其意义），而不是它长什么样子；它的外观应该由CSS来决定。 H5在语义上的改进在此基础上，HTML5 增加了大量有意义的语义标签，更有利于搜索引擎或辅助设备理解 HTML 页面内容。HTML5会让HTML代码的内容更结构化、标签更语义化。 我们常见的 css+div 布局是： 在html5中，我们可以这样写： 传统的做法中，我们通过增加类名如class=&quot;header&quot;、class=&quot;footer&quot;，使HTML页面具有语义性，但是不具有通用性。 HTML5 则是通过新增语义标签的形式来解决这个问题，例如&lt;header&gt;&lt;/header&gt;、&lt;footer&gt;&lt;/footer&gt;等，这样就可以使其具有通用性。 传统网页布局： 1234567891011121314151617&lt;!-- 头部 --&gt;&lt;div class=\"header\"&gt; &lt;ul class=\"nav\"&gt;&lt;/ul&gt;&lt;/div&gt;&lt;!-- 主体部分 --&gt;&lt;div class=\"main\"&gt; &lt;!-- 文章 --&gt; &lt;div class=\"article\"&gt;&lt;/div&gt; &lt;!-- 侧边栏 --&gt; &lt;div class=\"aside\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- 底部 --&gt;&lt;div class=\"footer\"&gt;&lt;/div&gt; H5 的经典网页布局： 1234567891011121314151617&lt;!-- 头部 --&gt;&lt;header&gt; &lt;ul class=\"nav\"&gt;&lt;/ul&gt;&lt;/header&gt;&lt;!-- 主体部分 --&gt;&lt;div class=\"main\"&gt; &lt;!-- 文章 --&gt; &lt;article&gt;&lt;/article&gt; &lt;!-- 侧边栏 --&gt; &lt;aside&gt;&lt;/aside&gt;&lt;/div&gt;&lt;!-- 底部 --&gt;&lt;footer&gt;&lt;/footer&gt; H5中新增的语义标签 &lt;section&gt; 表示区块 &lt;article&gt; 表示文章。如文章、评论、帖子、博客 &lt;header&gt; 表示页眉 &lt;footer&gt; 表示页脚 &lt;nav&gt; 表示导航 &lt;aside&gt; 表示侧边栏。如文章的侧栏 &lt;figure&gt; 表示媒介内容分组。 &lt;mark&gt; 表示标记 (用得少) &lt;progress&gt; 表示进度 (用得少) &lt;time&gt; 表示日期 本质上新语义标签与&lt;div&gt;、&lt;span&gt;没有区别，只是其具有表意性，使用时除了在HTML结构上需要注意外，其它和普通标签的使用无任何差别，可以理解成&lt;div class=&quot;nav&quot;&gt; 相当于&lt;nav&gt;。 PS：单标签不用写关闭符号。 新语义标签的兼容性处理IE8 及以下版本的浏览器不支持 H5 和 CSS3。解决办法：引入html5shiv.js文件。 引入时，需要做if判断，具体代码如下： 12345&lt;!-- 条件注释 只有ie能够识别--&gt;&lt;!--[if lte ie 8]&gt; &lt;script src=\"html5shiv.min.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; 上方代码是条件注释：虽然是注释，但是IE浏览器可以识别出来。解释一下： l：less 更小 t：than 比 e：equal等于 g：great 更大 PS:我们在测试 IE 浏览器的兼容的时候，可以使用软件 ietest，模拟IE6-IE11。 在不支持HTML5新标签的浏览器，会将这些新的标签解析成行内元素(inline)对待，所以我们只需要将其转换成块元素(block)即可使用。 但是在IE9版本以下，并不能正常解析这些新标签，但是可以识别通过document.createElement(‘tagName’)创建的自定义标签。于是我们的解决方案就是：将HTML5的新标签全部通过document.createElement(‘tagName’)来创建一遍，这样IE低版本也能正常解析HTML5新标签了。 当然，在实际开发中我们更多采用的办法是：检测IE浏览器的版本，来加载第三方的JS库来解决兼容问题（如上方代码所示）。 H5中的表单传统的Web表单已经越来越不能满足开发的需求，HTML5 在 Web 表单方向做了很大的改进，如拾色器、日期/时间组件等，使表单处理更加高效。 H5中新增的表单类型 email 只能输入email格式。自动带有验证功能。 tel 手机号码。 url 只能输入url格式。 number 只能输入数字。 search 搜索框 range 滑动条 color 拾色器 time 时间 date 日期 datetime 时间日期 month 月份 week 星期 上面的部分类型是针对移动设备生效的，且具有一定的兼容性，在实际应用当中可选择性的使用。 代码举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=no\"&gt; &lt;title&gt;表单类型&lt;/title&gt; &lt;style&gt; body { margin: 0; padding: 0; background-color: #F7F7F7; } form { max-width: 500px; width: 100%; margin: 32px auto 0; font-size: 16px; } label { display: block; margin: 10px 0; } input { width: 100%; height: 25px; margin-top: 2px; display: block; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"\"&gt; &lt;fieldset&gt; &lt;legend&gt;表单类型&lt;/legend&gt; &lt;label for=\"\"&gt; email: &lt;input type=\"email\" name=\"email\" required&gt; &lt;/label&gt; &lt;label for=\"\"&gt; color: &lt;input type=\"color\" name=\"color\"&gt; &lt;/label&gt; &lt;label for=\"\"&gt; url: &lt;input type=\"url\" name='url'&gt; &lt;/label&gt; &lt;label for=\"\"&gt; number: &lt;input type=\"number\" step=\"3\" name=\"number\"&gt; &lt;/label&gt; &lt;label for=\"\"&gt; range: &lt;input type=\"range\" name=\"range\" value=\"100\"&gt; &lt;/label&gt; &lt;label for=\"\"&gt; search: &lt;input type=\"search\" name=\"search\"&gt; &lt;/label&gt; &lt;label for=\"\"&gt; tel: &lt;input type=\"tel\" name=\"tel\"&gt; &lt;/label&gt; &lt;label for=\"\"&gt; time: &lt;input type=\"time\" name=\"time\"&gt; &lt;/label&gt; &lt;label for=\"\"&gt; date: &lt;input type=\"date\" name=\"date\"&gt; &lt;/label&gt; &lt;label for=\"\"&gt; datetime: &lt;input type=\"datetime\"&gt; &lt;/label&gt; &lt;label for=\"\"&gt; week: &lt;input type=\"week\" name=\"month\"&gt; &lt;/label&gt; &lt;label for=\"\"&gt; month: &lt;input type=\"month\" name=\"month\"&gt; &lt;/label&gt; &lt;label for=\"\"&gt; datetime-local: &lt;input type=\"datetime-local\" name=\"datetime-local\"&gt; &lt;/label&gt; &lt;input type=\"submit\"&gt; &lt;/fieldset&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 代码解释： &lt;fieldset&gt; 标签将表单里的内容进行打包，代表一组；而&lt;legend&gt;标签的则是 fieldset 里的元素定义标题。 表单元素（标签）这里讲两个表单元素。 1、&lt;datalist&gt; 数据列表： 123456&lt;input type=\"text\" list=\"myData\"&gt;&lt;datalist id=\"myData\"&gt; &lt;option&gt;本科&lt;/option&gt; &lt;option&gt;研究生&lt;/option&gt; &lt;option&gt;不明&lt;/option&gt;&lt;/datalist&gt; 上方代码中，input里的list属性和 datalist 进行了绑定。 效果： 上图可以看出，数据列表可以自动提示。 2、&lt;keygen&gt;元素： keygen 元素的作用是提供一种验证用户的可靠方法。 keygen 元素是密钥对生成器（key-pair generator）。当提交表单时，会生成两个键：一个公钥，一个私钥。 私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。 3、&lt;meter&gt;元素：度量器 low：低于该值后警告 high：高于该值后警告 value：当前值 max：最大值 min：最小值。 举例： 1&lt;meter value=\"81\" min=\"0\" max=\"100\" low=\"60\" high=\"80\"/&gt; 表单属性 placeholder 占位符（提示文字） autofocus 自动获取焦点 multiple 文件上传多选或多个邮箱地址 autocomplete 自动完成（填充的）。on 开启（默认），off 取消。用于表单元素，也可用于表单自身(on/off) form 指定表单项属于哪个form，处理复杂表单时会需要 novalidate 关闭默认的验证功能（只能加给form） required 表示必填项 pattern 自定义正则，验证表单。例如 代码举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; form { width: 100%; /* 最大宽度*/ max-width: 640px; /* 最小宽度*/ min-width: 320px; margin: 0 auto; font-family: \"Microsoft Yahei\"; font-size: 20px; } input { display: block; width: 100%; height: 30px; margin: 10px 0; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"\"&gt; &lt;fieldset&gt; &lt;legend&gt;表单属性&lt;/legend&gt; &lt;label for=\"\"&gt; 用户名：&lt;input type=\"text\" placeholder=\"例如：smyhvae\" autofocus name=\"userName\" autocomplete=\"on\" required/&gt; &lt;/label&gt; &lt;label for=\"\"&gt; 电话：&lt;input type=\"tel\" pattern=\"1\\d{10}\"/&gt; &lt;/label&gt; &lt;label for=\"\"&gt; multiple的表单: &lt;input type=\"file\" multiple&gt; &lt;/label&gt; &lt;!-- 上传文件--&gt; &lt;input type=\"file\" name=\"file\" multiple/&gt; &lt;input type=\"submit\"/&gt; &lt;/fieldset&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 表单事件 oninput()：用户输入内容时触发，可用于输入字数统计。 oninvalid()：验证不通过时触发。比如，如果验证不通过时，想弹出一段提示文字，就可以用到它。 举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; form { width: 100%; /* 最大宽度*/ max-width: 400px; /* 最小宽度*/ min-width: 200px; margin: 0 auto; font-family: \"Microsoft Yahei\"; font-size: 20px; } input { display: block; width: 100%; height: 30px; margin: 10px 0; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"\"&gt; &lt;fieldset&gt; &lt;legend&gt;表单事件&lt;/legend&gt; &lt;label for=\"\"&gt; 邮箱：&lt;input type=\"email\" name=\"\" id=\"txt1\"/&gt; &lt;/label&gt; &lt;label for=\"\"&gt; 输入的次数统计：&lt;input type=\"text\" name=\"\" id=\"txt2\"/&gt; &lt;/label&gt; &lt;input type=\"submit\"/&gt; &lt;/fieldset&gt;&lt;/form&gt;&lt;script&gt; var txt1 = document.getElementById('txt1'); var txt2 = document.getElementById('txt2'); var num = 0; txt1.oninput = function () { //用户输入时触发 num++; //用户每输入一次，num自动加 1 //将统计数显示在txt2中 txt2.value = num; } txt1.oninvalid = function () { //验证不通过时触发 this.setCustomValidity('亲，请输入正确哦'); //设置验证不通过时的提示文字 }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果： 多媒体在HTML5之前，在网页上播放音频/视频的通用方法是利用Flash来播放。但是大多情况下，并非所有用户的浏览器都安装了Flash插件，由此使得音频、视频播放的处理变得非常复杂；并且移动设备的浏览器并不支持Flash插件。 H5里面提供了视频和音频的标签。 音频HTML5通过&lt;audio&gt;标签来解决音频播放的问题。 使用举例： 1&lt;audio src=\"music/yinyue.mp3\" autoplay controls&gt; &lt;/audio&gt; 效果如下： 我们可以通过附加属性，来更友好地控制音频的播放，如： autoplay 自动播放。写成autoplay 或者 autoplay = &quot;&quot;，都可以。 controls 控制条。（建议把这个选项写上，不然都看不到控件在哪里） loop 循环播放。 preload 预加载 同时设置 autoplay 时，此属性将失效。 处理兼容性问题： 由于版权等原因，不同的浏览器可支持播放的格式是不一样的： 为了做到多浏览器支持，可以采取以下兼容性写法： 1234567&lt;!--推荐的兼容写法：--&gt;&lt;audio controls loop&gt; &lt;source src=\"music/yinyue.mp3\"/&gt; &lt;source src=\"music/yinyue.ogg\"/&gt; &lt;source src=\"music/yinyue.wav\"/&gt; 抱歉，你的浏览器暂不支持此音频格式&lt;/audio&gt; 代码解释：如果识别不出音频格式，就弹出那句“抱歉”。 视频HTML5通过&lt;video&gt;标签来解决视频播放的问题。 使用举例： 1&lt;video src=\"video/movie.mp4\" controls autoplay&gt;&lt;/video&gt; 我们可以通过附加属性，来更友好地控制视频的播放，如： autoplay 自动播放。写成autoplay 或者 autoplay = &quot;&quot;，都可以。 controls 控制条。（建议把这个选项写上，不然都看不到控件在哪里） loop 循环播放。 preload 预加载 同时设置 autoplay 时，此属性将失效。 width：设置播放窗口宽度。 height：设置播放窗口的高度。 由于版权等原因，不同的浏览器可支持播放的格式是不一样的： 兼容性写法： 12345678&lt;!--&lt;video src=\"video/movie.mp4\" controls autoplay &gt;&lt;/video&gt;--&gt;&lt;!-- 行内块 display:inline-block --&gt;&lt;video controls autoplay&gt; &lt;source src=\"video/movie.mp4\"/&gt; &lt;source src=\"video/movie.ogg\"/&gt; &lt;source src=\"video/movie.webm\"/&gt; 抱歉，不支持此视频&lt;/video&gt; DOM 操作获取元素 document.querySelector(“selector”) 通过CSS选择器获取符合条件的第一个元素。 document.querySelectorAll(“selector”) 通过CSS选择器获取符合条件的所有元素，以类数组形式存在。 类名操作 Node.classList.add(“class”) 添加class Node.classList.remove(“class”) 移除class Node.classList.toggle(“class”) 切换class，有则移除，无则添加 Node.classList.contains(“class”) 检测是否存在class 自定义属性js 里可以通过 box1.index=100; box1.title 来自定义属性和获取属性。 H5可以直接在标签里添加自定义属性，但必须以 data- 开头。 举例： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 给标签添加自定义属性 必须以data-开头 --&gt;&lt;div class=\"box\" title=\"盒子\" data-my-name=\"smyhvae\" data-content=\"我是一个div\"&gt;div&lt;/div&gt;&lt;script&gt; var box = document.querySelector('.box'); //自定义的属性 需要通过 dateset[]方式来获取 console.log(box.dataset[\"content\"]); //打印结果：我是一个div console.log(box.dataset[\"myName\"]); //打印结果：smyhvae //设置自定义属性的值 var num = 100; num.index = 10; box.index = 100; box.dataset[\"content\"] = \"aaaa\";&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 举例：鼠标点击时，tab栏切换123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Tab 标签&lt;/title&gt; &lt;style&gt; body { margin: 0; padding: 0; background-color: #F7F7F7; } .tabs { width: 400px; margin: 30px auto; background-color: #FFF; border: 1px solid #C0DCC0; box-sizing: border-box; } .tabs nav { height: 40px; text-align: center; line-height: 40px; overflow: hidden; background-color: #C0DCC0; display: flex; } nav a { display: block; width: 100px; border-right: 1px solid #FFF; color: #000; text-decoration: none; } nav a:last-child { border-right: 0 none; } nav a.active { background-color: #9BAF9B; } .cont { overflow: hidden; display: none; } .cont ol { line-height: 30px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"tabs\"&gt; &lt;nav&gt; &lt;a href=\"javascript:;\" data-cont=\"local\"&gt;国内新闻&lt;/a&gt; &lt;a href=\"javascript:;\" data-cont=\"global\"&gt;国际新闻&lt;/a&gt; &lt;a href=\"javascript:;\" data-cont=\"sports\"&gt;体育新闻&lt;/a&gt; &lt;a href=\"javascript:;\" data-cont=\"funny\"&gt;娱乐新闻&lt;/a&gt; &lt;/nav&gt; &lt;section class=\"cont\" id=\"local\"&gt; &lt;ol&gt; &lt;li&gt;国内新闻1&lt;/li&gt; &lt;li&gt;国内新闻2&lt;/li&gt; &lt;li&gt;国内新闻3&lt;/li&gt; &lt;li&gt;国内新闻4&lt;/li&gt; &lt;li&gt;国内新闻5&lt;/li&gt; &lt;li&gt;国内新闻6&lt;/li&gt; &lt;li&gt;国内新闻7&lt;/li&gt; &lt;/ol&gt; &lt;/section&gt; &lt;section class=\"cont\" id=\"global\"&gt; &lt;ol&gt; &lt;li&gt;国内新闻1&lt;/li&gt; &lt;li&gt;国际新闻2&lt;/li&gt; &lt;li&gt;国际新闻3&lt;/li&gt; &lt;li&gt;国际新闻4&lt;/li&gt; &lt;li&gt;国际新闻5&lt;/li&gt; &lt;li&gt;国际新闻6&lt;/li&gt; &lt;/ol&gt; &lt;/section&gt; &lt;section class=\"cont\" id=\"sports\"&gt; &lt;ol&gt; &lt;li&gt;体育新闻1&lt;/li&gt; &lt;li&gt;体育新闻2&lt;/li&gt; &lt;li&gt;体育新闻3&lt;/li&gt; &lt;li&gt;体育新闻4&lt;/li&gt; &lt;li&gt;体育新闻5&lt;/li&gt; &lt;li&gt;体育新闻6&lt;/li&gt; &lt;li&gt;体育新闻7&lt;/li&gt; &lt;/ol&gt; &lt;/section&gt; &lt;section class=\"cont\" id=\"funny\"&gt; &lt;ol&gt; &lt;li&gt;娱乐新闻1&lt;/li&gt; &lt;li&gt;娱乐新闻2&lt;/li&gt; &lt;li&gt;娱乐新闻3&lt;/li&gt; &lt;li&gt;娱乐新闻4&lt;/li&gt; &lt;li&gt;娱乐新闻5&lt;/li&gt; &lt;li&gt;娱乐新闻6&lt;/li&gt; &lt;li&gt;娱乐新闻7&lt;/li&gt; &lt;/ol&gt; &lt;/section&gt; &lt;/div&gt; &lt;script&gt; // 目标： 默认显示一个 当前的样式 // 点击导航，实现切换 // key 表示的当前显示的是第几个 (function (key) { // 获取所有的导航 var navs = document.querySelectorAll('nav a'); // 遍历 给导航 绑定事件，并且添加当前样式 for (var i = 0; i &lt; navs.length; i++) { // 如果是用户指定的当前样式 if (key == i) { navs[i].classList.add('active'); // 拿到要显示内容section的id var secId = navs[i].dataset['cont']; // 获取对应的section标签 document.querySelector('#' + secId).style.display = 'block'; } // 给每一个导航绑定点击事件 navs[i].onclick = function () { // 排他 // 之前有active样式的清除, 之前显示的section 隐藏 var currentNav = document.querySelector('.active'); // 获取对应的内容区域 ，让其隐藏 var currentId = currentNav.dataset['cont']; // 去掉导航的active 样式 currentNav.classList.remove('active'); // 对应的内容区域 document.querySelector('#' + currentId).style.display = 'none'; // 突出显示自己 导航添加样式 对应的section 显示 // 给自己添加active样式 this.classList.add('active'); // 对应的section模块显示出来 var myId = this.dataset['cont']; document.querySelector('#' + myId).style.display = 'block'; } } })(0); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2020/03/04/html/html5-%E8%AF%A6%E8%A7%A3/"},{"title":"NPM和Yarn添加淘宝镜像","text":"添加淘宝镜像 NPM设置淘宝镜像1.查询当前配置的镜像 12npm get registry &gt; https://registry.npmjs.org/ 设置成淘宝镜像 npm config set registry http://registry.npm.taobao.org/ 2.恢复默认 npm config set registry https://registry.npmjs.org/ Yarn 设置淘宝镜像1.查询当前配置的镜像 12yarn config get registry&gt; https://registry.yarnpkg.com 设置成淘宝镜像 yarn config set registry http://registry.npm.taobao.org/","link":"/2020/02/27/js/NPM%E5%92%8CYarn%E6%B7%BB%E5%8A%A0%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F/"},{"title":"JavaScript 中 new 操作符的执行顺序 ","text":"&emsp;&emsp;以前在学习 JavaScript 构造函数的时候，并没有深入地去研究 new 操作符究竟做了什么事情，也没有深入了解构造返回值的规则，本篇文章详细解释了这两个问题。 new 操作符做了什么？？？&emsp;&emsp;用 new 调用构造函数时 new 的操作顺序： （一）创建一个新对象 X； （二）将新对象 X 的属性 proto 指向构造函数的 prototype 指向的地方； （三）将构造函数中的 this 绑定为新对象 X； （四）执行构造函数中的代码，比如 this.a = ‘xx’ 等等； （五）判断构造函数中是否有 return 语句，没有的话就返回新对象 X，有的话先判断 return 后面的值是否为引用类型，是引用类型的话就返回该值，否则依然返回新对象 X。 注意&emsp;&emsp;（一）对于构造函数，如果没有通过 new 去调用，那么实际该函数返回什么由函数中 return 的具体值决定，即有 return 语句的话 return 什么就返回什么，没有 return 语句的话就返回 undefined； &emsp;&emsp;（二）但是如果用 new 去调用构造函数，如果没有 return 语句，那就返回由 new 创建的那个对象，有 return 语句的话，先判断 return 后面的是不是引用类型的指，如果是引用类型的值，就返回该值，否则依然返回由 new 创建的那个对象。","link":"/2020/03/02/js/JavaScript-%E4%B8%AD-new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"},{"title":"js变量","text":"字面量：数字和字符串“字面量”即常量，是固定值，不可改变。看见什么，它就是什么。 字面量有3种： 数字 字符串 布尔字面量 前言来自 https://github.com/qianguyihao/Web （1）数值的字面量非常简单，写上去就行了，不需要任何的符号。例如： 1alert(886); //886是数字，所以不需要加引号。 （2）字符串的字面量也很简单，但一定要加上引号。可以是单词、句子等。例如： 123console.log('886');console.log('千古壹号，永不止步'); 温馨提示：100是数字，”100”是字符串。 （3）布尔字面量举例： 123if (true) { console.log('如果为真，就走这里面的代码);} 总结字面量都可以直接使用，但是我们一般不会直接使用字面量。 如果直接使用字面量的话，比较麻烦。比如说，多个地方要用到同一个字面量，还不如事先定义一个变量，用来保存字面量。 变量更方便我们使用，所以在开发中都是通过变量去保存一个字面量，而不会直接使用字面量。 变量的概念变量：是用于存放数据的容器。我们通过「变量名」获取数据，甚至可以修改数据。 变量还可以用来保存字面量。 本质：变量是程序在内存中申请的一块用来存放数据的空间。 变量的声明和赋值变量的声明（变量的定义）在ES6语法之前，统一使用var关键字来声明一个变量。比如： 1var name; // 生命一个名为 name 的变量 补充：在ES6语法及之后，统一使用 const、let关键字来声明一个变量。这个以后再讲。 变量的赋值变量的赋值： 1name= '千古壹号' 变量的声明和赋值，举例如下： 1234var a = 100; // ES5语法const b = hello; // ES6 语法let b = world; // ES6 语法 如下图所示： var是英语“variant”变量的缩写。后面要加一个空格，空格后面的东西就是“变量名”： 定义变量：var就是一个关键字，用来定义变量。所谓关键字，就是有特殊功能的单词。 变量的赋值：等号表示赋值，将等号右边的值，赋给左边的变量。 变量名：我们可以给变量任意的取名字。 PS：在JavaScript中，永远都是用var来定义变量（在ES6 之前），这和C、Java等语言不同。 变量的初始化有经验的程序员，会把声明和赋值写在一起： 12var a = 100; //声明，并且赋值100console.log(a); //输出100 声明一个变量并赋值， 我们称之为变量的初始化。 变量声明和赋值的补充修改变量的值一个变量被重新复赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准。 举例： 1234var a = 100;a = 110;console.log(a); // 打印结果：110。因为 110 覆盖了 100 同时声明多个变量同时声明多个变量时，只需要写一个 var， 多个变量名之间用英文逗号隔开。 举例： 1var name = '千古壹号', age = 27, number = 100; 变量声明的几种特殊情况变量建议先声明，再使用。否则可能会报错。具体如下。 写法1、先声明，再赋值：（正常） 123var a;a = 100;console.log(a); // 打印结果：100 写法2、不声明，只赋值：（正常） 12a = 100;console.log(a); // 打印结果：100 写法3、只声明，不赋值：（注意，打印 undefined） 12var a;console.log(a); // 打印结果：undefined 写法4、不声明，不赋值，直接使用：（会报错） 1console.log(a); // 会报错 控制台会报错： 补充：写法1和写法2虽然都正常，但这两种写法是有区别的，等以后学习了「变量提升」的概念就明白了。大多数情况下，我们都是采用的写法1。 变量的命名规范大写字母是可以使用的，并且大小写敏感。也就是说A和a是两个变量。 12var A = 250; //变量1var a = 888; //变量2 我们来整理一下变量的命名规范： 只能由字母(A-Z、a-z)、数字(0-9)、下划线(_)、美元符( $ )组成 不能以数字开头。也就是说，必须以字母(A-Z、a-z)、下划线(_)或者美元符( $ )开头。变量名中不允许出现空格。 不用使用 JS 语言中保留的「关键字」和「保留字」作为变量名。 建议用驼峰命名规则。比如getElementById、matherAndFather、aaaOrBbbAndCcc 变量名会区分大小写(javascript 是区分大小写的语言)。 变量名长度不能超过255个字符。 汉语可以作为变量名。但是不建议使用，因为 low。 标识符、关键字、保留字标识符标识符：在JS中所有的可以由我们自主命名的都可以称之为标识符。 例如：变量名、函数名、属性名、参数名都是属于标识符。通俗来讲，标识符就是我们写代码时为它们起的名字。 标识符的命名规则和变量的命令规则是一样的。看上面一段就可以了。 同样，标识符不能使用语言中保留的关键字及保留字。如下。 关键字关键字：是指 JS 本身已经使用了的单词，不能再用它们充当变量、函数名等标识符。 JS 中的关键字如下： 1234567891011break、continue、case、default、if、else、switch、for、in、do、while、try、catch、finally、throw、var、void、function、return、new、this、typeof、instanceof、delete、with、true、false、null、undefined 保留字保留字：实际上就是预留的“关键字”。意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能使用它们当充当变量名、函数名等标识符。 JS 中的保留字如下： 123456789abstract、boolean、byte、char、class、const、debugger、double、enum、export、extends、final、float、gotoimplements、import、int、interface、long、native、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile 举例举例1：交换两个变量的值 代码实现： 12345678var a1 = 100;var a2 = 200;var temp;temp = a1;a1 = a2;a2 = temp; 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","link":"/2020/03/08/js/js%E5%8F%98%E9%87%8F/"},{"title":"html-标签图文","text":"本文主要内容 头标签 排版标签：&lt;p&gt;、 &lt;div&gt;、 &lt;span&gt;、&lt;br&gt; 、 &lt;hr&gt; 、 &lt;center&gt; 、 &lt;pre&gt; 字体标记：&lt;h1&gt;、 &lt;font&gt;、 &lt;b&gt;、 &lt;u&gt; 、&lt;sup&gt; 、&lt;sub&gt; 超链接 &lt;a&gt; 图片标签 &lt;img&gt; 前言来自 https://github.com/qianguyihao/Web 3、&lt;body&gt;标签的属性其属性有： bgcolor：设置整个网页的背景颜色。 background：设置整个网页的背景图片。 text：设置网页中的文本颜色。 leftmargin：网页的左边距。IE浏览器默认是8个像素。 topmargin：网页的上边距。 rightmargin：网页的右边距。 bottommargin：网页的下边距。 &lt;body&gt;标签另外还有一些属性，这里用个例子来解释： 上方代码中，当我们对点我点我这几个字使用超链时，link属性表示默认显示的颜色、alink属性表示鼠标点击但是还没有松开时的颜色、vlink属性表示点击完成之后显示的颜色。效果如下： 接下来，我们讲一下&lt;body&gt;里的各种标签的属性。 一、排版标签注释标签1&lt;!-- 注释 --&gt; 段落标签&lt;p&gt;12&lt;p&gt;This is a paragraph&lt;/p&gt;&lt;p&gt;This is another paragraph&lt;/p&gt; 属性： align=&quot;属性值&quot;：对齐方式。属性值包括left center right。举例： 段落，是英语paragraph“段落”缩写。 HTML标签是分等级的，HTML将所有的标签分为两种： 文本级标签：p、span、a、b、i、u、em。文本级标签里只能放文字、图片、表单元素。（a标签里不能放a和input） 容器级标签：div、h系列、li、dt、dd。容器级标签里可以放置任何东西。 从学习p的第一天开始，就要死死记住：p标签是一个文本级标签，p里面只能放文字、图片、表单元素。其他的一律不能放。 错误写法：（尝试把 h 放到 p 里） 1234&lt;p&gt; 我是一个小段落 &lt;h1&gt;我是一级标题&lt;/h1&gt;&lt;/p&gt; 网页效果如下： 上图显示，浏览器不允许你这么做，我们使用Chrome的F12审查元素发现，浏览器自己把p封闭掉了，不让你去包裹h1。 PS：Chrome浏览器是世界上HTML5支持最好的浏览器。提供了非常好的开发工具，非常适合我们开发人员使用。审查元素功能的快捷键是F12。 块级标签 &lt;div&gt;和&lt;span&gt; div和span是非常重要的标签，div的语义是division“分割”； span的语义就是span“范围、跨度”。 CSS课程中你将知道，这两个东西，都是最最重要的“盒子”。 div：把标签中的内容作为一个块儿来对待(division)。必须单独占据一行。 div标签的属性： align=&quot;属性值&quot;：设置块儿的位置。属性值可选择：left、right、 center。 &lt;span&gt;和&lt;div&gt;唯一的区别在于：&lt;span&gt;是不换行的，而&lt;div&gt;是换行的。 如果单独在网页中插入这两个元素，不会对页面产生任何的影响。这两个元素是专门为定义CSS样式而生的。或者说，DIV+CSS来实现各种样式。 效果举例： div在浏览器中，默认是不会增加任何的效果的，但是语义变了，div中的所有元素是一个小区域。div标签是一个容器级标签，里面什么都能放，甚至可以放div自己。 span也是表达“小区域、小跨度”的标签，但是是一个文本级的标签。就是说，span里面只能放置文字、图片、表单元素。 span里面不能放p、h、ul、dl、ol、div。 span里面是放置小元素的，div里面放置大东西的。举例如下： span举例： 1234567&lt;p&gt; 简介简介简介简介简介简介简介简介 &lt;span&gt; &lt;a href=\"\"&gt;详细信息&lt;/a&gt; &lt;a href=\"\"&gt;购买&lt;/a&gt; &lt;/span&gt;&lt;/p&gt; div举例： 123456789&lt;div class=\"header\"&gt; &lt;div class=\"logo\"&gt;&lt;/div&gt; &lt;div class=\"nav\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"content\"&gt; &lt;div class=\"guanggao\"&gt;&lt;/div&gt; &lt;div class=\"dongxi\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"footer\"&gt;&lt;/div&gt; 所以，我们亲切的称呼这种模式叫做“div+css”。div标签负责布局，负责结构，负责分块。css负责样式。 换行标签&lt;br&gt;（已废弃）当你打算结束一行，而又不想开始一个新段落时，&lt;br&gt;标签就派上用场了。无论你将它置于何处，&lt;br&gt;标签都会产生一个强制的换行。 1This &lt;br&gt; is a para&lt;br&gt;graph with line breaks 效果如下： 上图显示，&lt;p&gt;标签和&lt;br&gt;标签的区别在于：&lt;p&gt;标签会在段落的前后自动插入一个空行，而&lt;br&gt;标签没有空行；而且&lt;br&gt;标签没有属性。 注意&lt;br&gt; 没有结束标签，把&lt;br&gt;标签写为 &lt;br/&gt; 是经得起未来考验的做法，XHTML 和 XML 都接受在打开的标签内部来关闭标签的做法。 水平线标签&lt;hr&gt;（已废弃）水平分隔线（horizontal rule）可以在视觉上将文档分隔成各个部分。效果如下： 属性： align=&quot;属性值&quot;：设定线条置放位置。属性值可选择：left right center。 size=&quot;2&quot;：设定线条粗细。以像素为单位，内定为2。 width=&quot;500&quot;或width=&quot;70%&quot;：设定线条长度。可以是绝对值（单位是像素）或相对值。如果设置为相对值的话，内定为100%。 color=&quot;#0000FF&quot;：设置线条颜色。 noshade：不要阴影，即设定线条为平面显示。若没有这个属性则表明线条具阴影或立体，这是内定值。属性效果演示： 内容居中标签 &lt;center&gt;此时center代表是一个标签，而不是一个属性值了。只要是在这个标签里面的内容，都会居于浏览器的中间。效果演示： 到了H5里面，center标签不建议使用。 预定义（预格式化）标签：&lt;pre&gt;含义：将保留其中的所有的空白字符(空格、换行符)，原封不动的输出结果（告诉浏览器不要忽略空格和空行）说明：真正排网页过程中，&lt;pre&gt;标签几乎用不着。但在PHP中用于打印一个数组时使用。 效果演示： 上图中，好像红框部分的字体变小了，而且还出现了缩进，好吧， 这个其实是浏览器搞的鬼。为什么要有&lt;pre&gt;这个标签呢？答案是： 所有的浏览器默认情况下都会忽略空格和空行。 好吧，其实这个标签也用的比较少。 二、字体标签标题标题使用&lt;h1&gt;至&lt;h6&gt;标签进行定义。&lt;h1&gt;定义最大的标题，&lt;h6&gt;定义最小的标题。具有align属性，属性值可以是：left、center、right。效果演示： 字体标签&lt;font&gt;（已废弃）属性： color=&quot;红色&quot;或color=&quot;#ff00cc&quot;或color=&quot;new rgb(0,0,255)&quot;：设置字体颜色。 设置方式：单词 \\ #ff00cc \\ rgb(0,0,255) size：设置字体大小。 取值范围只能是：1至7。取值时，如果取值大于7那就按照7来算，如果取值小于1那就按照1来算。如果想要更大的字体，那就只能通过css样式来解决。设置：用’+2’代表值是5 或直接给值 face=&quot;微软雅黑&quot;：设置字体类型。注意在写字体时，“微软雅黑”这个字不能写错。举例：1&lt;font face=\"微软雅黑\" color=\"#FF0000\" size=\"10\"&gt;vae&lt;/font&gt; 效果： 特殊字符（转义字符） &amp;nbsp;：空格 （non-breaking spacing，不断打空格） &amp;lt;：小于号（less than） &amp;gt;：大于号（greater than） &amp;amp;：符号&amp; &amp;quot;：双引号 &amp;apos;：单引号 &amp;copy;：版权© &amp;trade;：商标™ &amp;#32464;：文字绐。其实，#32464是汉字绐的unicode编码。 要求背诵的特殊字符有：&amp;nbsp;、&amp;lt;、&amp;gt;、&amp;copy;。 比如说，你想把&lt;p&gt;作为一个文本在页面上显示，直接写&lt;p&gt;是肯定不行的，因为这代表的是一个段落标签，所以这里需要用到转义字符。应该这么写： 1这是一个HTML语言的&amp;lt;p&amp;gt;标签 正确的效果如下： 错误的效果如下： 其实我们只要记住前三个符号就行了，其他的在需要的时候查一下就行了。而且，EditPlus软件中是可以直接点击这些符号进行选择的： 来一张表格，方便需要的时候查询： 特殊字符 描述 字符的代码 空格符 &amp;nbsp; &lt; 小于号 &amp;lt; &gt; 大于号 &amp;gt; &amp; 和号 &amp;amp; ￥ 人民币 &amp;yen; © 版权 &amp;copy; ® 注册商标 &amp;reg; ° 摄氏度 &amp;deg; ± 正负号 &amp;plusmn; × 乘号 &amp;times; ÷ 除号 &amp;divide; ² 平方2（上标2） &amp;sup2; ³ 立方3（上标3） &amp;sup3; 一些小标签/小标记 &lt;u&gt;：下划线标记 &lt;s&gt;或&lt;del&gt;：中划线标记（删除线） &lt;i&gt;或&lt;em&gt;：斜体标记 效果： 上面的这几个标签，常用于做一些小装饰、小图标。比如： 20180118_2340.png 这张图中，我们通过查看京东网站的代码发现，箭头处的小图标都是用的标签&lt;i&gt;。 div的主要目的是用来布局，而小装饰却可以用来 粗体标签&lt;b&gt;或&lt;strong&gt;（已废弃）效果： 上标&lt;sup&gt; 下标&lt;sub&gt;上小标这两个标签容易混淆，怎么记呢？这样记：b的意思是bottom：底部举例： 1O&lt;sup&gt;2&lt;/sup&gt; 5&lt;sub&gt;3&lt;/sub&gt; 效果： 三、超链接超链接有三种形式： 1、外部链接：链接到外部文件。举例： 1&lt;a href=\"02页面.html\"&gt;点击进入另外一个文件&lt;/a&gt; a是英语anchor“锚”的意思，就好像这个页面往另一个页面扔出了一个锚。是一个文本级的标签。 href是英语hypertext reference超文本地址的缩写。读作“喝瑞夫”，不要读作“喝夫”。 效果： 当然，我们也可以直接点进链接，访问一个网址。举例如下； 1&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt;点我点我&lt;/a&gt; 2、锚链接：指给超链接起一个名字，作用是在本页面或者其他页面的的不同位置进行跳转。比如说，在网页底部有一个向上箭头，点击箭头后回到顶部，这个就是利用到了锚链接。首先我们要创建一个锚点，也就是说，使用name属性或者id属性给那个特定的位置起个名字。效果如下： 上图中解释： 11行代码表示，顶部这个锚的名字叫做name1。然后在底部设置超链接，点击时将回到顶部（此时，网页中的url的末尾也出现了#name1）。注意上图中红框部分的#号不要忘记了，表示跳到名为name1的特定位置，这是规定。如果少了#号，点击之后，就会跳到name1这个文件或者name1这个文件夹中去。 如果我们将上图中的第28行代码写成： 1&lt;a href=\"a.html#name1\"&gt;回到顶部&lt;/a&gt; 那就表示，点击之后，跳转到a.html页面的name1锚点中去。 说明：name属性是HTML4.0以前使用的，id属性是HTML4.0后才开始使用。为了向前兼容，因此，name和id这两个属性都要写上，并且值是一样的。 3、邮件链接：代码举例： 1&lt;a href=\"mailto:smyhvae@163.com\"&gt;点击进入我的邮箱&lt;/a&gt; 效果：点击之后，会弹出outlook，作用不大。 超链接的属性 href：目标URL title：悬停文本。 name：主要用于设置一个锚点的名称。 target：告诉浏览器用什么方式来打开目标页面。target属性有以下几个值： _self：在同一个网页中显示（默认值） _blank：在新的窗口中打开。 _parent：在父窗口中显示 _top：在顶级窗口中显示 title属性举例： 1&lt;a href=\"09_img.html\" title=\"很好看哦\"&gt;结婚照&lt;/a&gt; 效果如下： target属性举例： 1&lt;a href=\"1.html\" title=\"悬停文本\" target=\"_blank\"&gt;链接的内容&lt;/a&gt; blank就是“空白”的意思，就表示新建一个空白窗口。为啥有一个_ ，就是规定，没啥好解释的。也就是说，如果不写target=”_blank”那么就是在相同的标签页打开，如果写了target=”_blank”，就是在新的空白标签页中打开。 备注1：分清楚img和a标签的各自的属性区别如下： 12&lt;img src=\"1.jpg\" /&gt;&lt;a href=\"1.html\"&gt;&lt;/a&gt; 备注2：a是一个文本级的标签比如一个段落中的所有文字都能够被点击，那么应该是p包裹a： 123&lt;p&gt; &lt;a href=\"\"&gt;段落段落段落段落段落段落&lt;/a&gt;&lt;/p&gt; 而不是a包裹p： 12345&lt;a href=\"\"&gt; &lt;p&gt; 段落段落段落段落段落段落 &lt;/p&gt;&lt;/a&gt; a的语义要小于p，a就是可以当做文本来处理，所以p里面相当于放的就是纯文字。 四、图片标签img: 代表的就是一张图片。是单边标记。 img是自封闭标签，也称为单标签。 能插入的图片类型： 能够插入的图片类型是：jpg(jpeg)、gif、png、bmp。类型和类型之间有什么区别，css课上讲。 不能往网页中插入的图片格式是：psd、ai HTML页面不是直接插入图片，而是插入图片的引用地址，所以也要把图片上传到服务器上。 src属性：图片的相对路径和绝对路径这里涉及到图片的一个属性： src属性：指图片的路径。 在写图片的路径时，有两种写法：相对路径、绝对路径 1、写法一：相对路径相对当前页面所在的路径。两个标记 . 和 .. 分表代表当前目录和父路径。 举例1： 12345&lt;!-- 当前目录中的图片 --&gt;&lt;img src=\"2.jpg\"&gt;&lt;img src=\".\\2.jpg\"&gt;&lt;!-- 上一级目录中的图片 --&gt;&lt;img src=\"..\\2.jpg\"&gt; img 是image“图片”的简写，src 是英语source“资源”的缩写。 相对路径不会出现这种情况： 1aaa/../bbb/1.jpg ../要么不写，要么就写在开头。 举例2： 1&lt;img src=\"images/1.jpg\"&gt; 上方代码的意思是说，当前页面有一个并列的文件夹images，在文件夹images中存放了一张图片1.jpg效果： 相对路径的面试题。现有如下文件层级图： 问题：如果想在index.html中插入1.png，那么对应的img语句是？ 分析： 现在document是最大的文件夹，里面有两个文件夹work和photo。work中又有一个文件夹叫做myweb。myweb文件夹里面有index.html。 所以index.html在myweb文件夹里面，上一级就是work文件夹，上两级就是document文件夹。通过document文件夹当做一个中转站，进入photo文件夹，看到了1.png。 答案： 1&lt;img src=\"../../photo/1.png\" /&gt; 2、写法二：绝对路径绝对路径包括以下两种： （1）以盘符开始的绝对路径。举例： 1&lt;img src=\"C:\\Users\\smyhvae\\Desktop\\html\\images\\1.jpg\"&gt; （2）网络路径。举例： 1&lt;img src=\"http://img.smyhvae.com/2016040102.jpg\"&gt; 大家打开上面的img中的链接，扫一扫，可能有惊喜哦。 相对路径和绝对路径的总结相对路径的好处：站点不管拷贝到哪里，文件和图片的相对路径关系都是不变的。相对路径使用有一个前提，就是网页文件和你的图片，必须在一个服务器上。 问题：我的网页在C盘，图片却在D盘，能不能插入呢？ 答案： 用相对路径不能，用绝对路径也不能。 注意：可以使用file://来插入，但是这种方法，没有任何意义！因为服务器上没有所谓c盘、d盘。 下面的方法是行的，但是没有任何工程上的意义，这是因为服务器没有盘符，linux系统没有盘符： 1&lt;img src=\"file://C:\\Users\\Danny\\Pictures\\明星\\1.jpg\" alt=\"\" /&gt; 总结一下： 我们现在无论是在a标签、img标签，如果要用路径。只有两种路径能用，就是相对路径和绝对路径。 相对路径，就是../ image/ 这种路径。从自己出发，找到别人； 绝对路径，就是http://开头的路径。 绝对不允许使用file://开头的东西，这个是完全错误的！ img标签的其他属性 width：宽度 height：高度 Align：指图片的水平对齐方式，属性值可以是：left、center、right title：提示性文本。公有属性。也就是鼠标悬停时出现的文本。 border：给图片加边框（描边），单位是像素，边框的颜色是黑色 Hspace：指图片左右的边距 Vspace：指图片上下的边距 alt：当图片不可用（无法显示）的时候，代替图片显示的内容。alt是英语 alternate “替代”的意思，代表替换资源。（有的浏览器不支持） 举例： 1&lt;img src=\"images/1.jpg\" width=\"300\" height=\"`188\" title=\"这是美女\"&gt; 效果： Alt属性效果演示：（当图片 src 不可用的时候，显示文字。这样做，至少能让用户知道，这个图片大概是什么内容） 图片的align属性：图片和周围文字的相对位置。属性取值可以是：bottom（默认）、center、top、left、right。我们来分别看一下这align属性的这几个属性值的区别。 1、align=&quot;&quot;，图片和文字低端对齐。即默认情况下的显示效果： 2、align=&quot;center&quot;：图片和文字水平方向上居中对齐。显示效果： 3、align=&quot;top&quot;：图片与文字顶端对齐。显示效果： 4、align=&quot;left&quot;：图片在文字的左边。显示效果： 5、align=&quot;right&quot;：图片在文字的右边。显示效果： 注意事项：（1）如果要想保证图片等比例缩放，请只设置width和height中其中一个。（2）如果想实现图文混排的效果，请使用align属性，取值为left或right。 热点问题指的是对图片的局部区域加超链接。我们知道，如果给图片加一个超链接，那个点击这个图片的任意区域，都会跳转到新的位置。举例： 1&lt;a href=\"网页2.html\"&gt;&lt;img src=\"2.jpg\"&gt;&lt;/a&gt; 上方代码表明：给图片加一个超链接，那个点击这个图片的任意区域，都会跳转到新的位置。现在，我只想对图片的局部区域加超链接，该怎么做呢？这里的难点在于坐标的确定，此时需要用到Dreamweaver。 上图中，切换到“设计”标签，然后： 上图中，点击菜单栏插入-图像，导入图片： ，在图片上点击右键，选择属性，弹出属性面板： 上图中，我们可以利用红框部分的地图绘制需要添加超链接的区域。箭头处表示的是要链接到的文件。蓝框部分表示打开新页面的方式，蓝狂部分的new是没有下划线的，它和_blank的含义是一样的。 局部区域的热点设置完毕后，上图显示，红框部分就是多出的代码，也正是我们需要的代码。多出的代码如下： 1234&lt;img src=\"file:///C|/Users/smyhvae/Desktop/html/1.jpg\" alt=\"\" width=\"488\" height=\"730\" usemap=\"#Map\"/&gt;&lt;map name=\"Map\"&gt; &lt;area shape=\"circle\" coords=\"227,374,63\" href=\"file:///C|/Users/smyhvae/Desktop/html/网页2.html\" target=\"_blank\"&gt;&lt;/map&gt; 上方代码中，第一行的usemap=&quot;#Map&quot;表示我要引用名为Map的地图。然后第02至第04行就给出了地图的定义。效果演示：","link":"/2020/02/29/html/html-%E6%A0%87%E7%AD%BE%E5%9B%BE%E6%96%872/"},{"title":"【前端面试】经典面试题基础","text":"javascript基础面试题2 什么闭包,闭包有什么用闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量。闭包作用域链通常包括三个部分： 函数本身作用域。 闭包定义时的作用域。 全局作用域。 闭包常见用途： 创建特权方法用于访问控制 事件处理程序及回调 javascript 有哪些方法定义对象 对象字面量： var obj = {}; 构造函数： var obj = new Object(); Object.create(): var obj = Object.create(Object.prototype); 对象到字符串的转换步骤 如果对象有 toString()方法，javascript 调用它。如果返回一个原始值（primitive value 如：string number boolean）,将这个值转换为字符串作为结果 如果对象没有 toString()方法或者返回值不是原始值，javascript 寻找对象的 valueOf()方法，如果存在就调用它，返回结果是原始值则转为字符串作为结果 否则，javascript 不能从 toString()或者 valueOf()获得一个原始值，此时 throws a TypeError 对象到数字的转换步骤 如果对象有valueOf()方法并且返回元素值，javascript将返回值转换为数字作为结果 否则，如果对象有toString()并且返回原始值，javascript将返回结果转换为数字作为结果 否则，throws a TypeError &lt;,&gt;,&lt;=,&gt;=的比较规则所有比较运算符都支持任意类型，但是比较只支持数字和字符串，所以需要执行必要的转换然后进行比较，转换规则如下: 如果操作数是对象，转换为原始值：如果 valueOf 方法返回原始值，则使用这个值，否则使用 toString 方法的结果，如果转换失败则报错 经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的 16 位 unicode 值的大小） 否则，如果有一个操作数不是字符串，将两个操作数转换为数字进行比较 +运算符工作流程 如果有操作数是对象，转换为原始值 此时如果有一个操作数是字符串，其他的操作数都转换为字符串并执行连接 否则：所有操作数都转换为数字并执行加法 客户端存储 localStorage 和 sessionStorage localStorage 有效期为永久，sessionStorage 有效期为顶层窗口关闭前 同源文档可以读取并修改 localStorage 数据，sessionStorage 只允许同一个窗口下的文档访问，如通过 iframe 引入的同源文档。 Storage 对象通常被当做普通 javascript 对象使用：通过设置属性来存取字符串值，也可以通过setItem(key, value)设置，getItem(key)读取，removeItem(key)删除，clear()删除所有数据，length 表示已存储的数据项数目，key(index)返回对应索引的 key 1234567891011localStorage.setItem('x', 1); // storge x-&gt;1localStorage.getItem('x); // return value of x// 枚举所有存储的键值对for (var i = 0, len = localStorage.length; i &lt; len; ++i ) { var name = localStorage.key(i); var value = localStorage.getItem(name);}localStorage.removeItem('x'); // remove xlocalStorage.clear(); // remove all data sessionStorage,localStorage,cookie 区别 都会在浏览器端保存，有大小限制，同源限制 cookie 会在请求时发送到服务器，作为会话标识，服务器可修改 cookie；web storage 不会发送到服务器 cookie 有 path 概念，子路径可以访问父路径 cookie，父路径不能访问子路径 cookie 有效期：cookie 在设置的有效期内有效，默认为浏览器关闭；sessionStorage 在窗口关闭前有效，localStorage 长期有效，直到用户删除 共享：sessionStorage 不能共享，localStorage 在同源文档之间共享，cookie 在同源且符合 path 规则的文档之间共享 localStorage 的修改会促发其他文档窗口的 update 事件 cookie 有 secure 属性要求 HTTPS 传输 浏览器不能保存超过 300 个 cookie，单个服务器不能超过 20 个，每个 cookie 不能超过 4k。web storage 大小支持能达到 5M 评价一下三种方法实现继承的优缺点,并改进12345678910111213141516function Shape() {}function Rect() {}// 方法1Rect.prototype = new Shape();// 方法2Rect.prototype = Shape.prototype;// 方法3Rect.prototype = Object.create(Shape.prototype);Rect.prototype.area = function () { // do something}; 方法 1： 优点：正确设置原型链实现继承 优点：父类实例属性得到继承，原型链查找效率提高，也能为一些属性提供合理的默认值 缺点：父类实例属性为引用类型时，不恰当地修改会导致所有子类被修改 缺点：创建父类实例作为子类原型时，可能无法确定构造函数需要的合理参数，这样提供的参数继承给子类没有实际意义，当子类需要这些参数时应该在构造函数中进行初始化和设置 总结：继承应该是继承方法而不是属性，为子类设置父类实例属性应该是通过在子类构造函数中调用父类构造函数进行初始化 方法 2： 优点：正确设置原型链实现继承 缺点：父类构造函数原型与子类相同。修改子类原型添加方法会修改父类 方法 3： 优点：正确设置原型链且避免方法 1.2 中的缺点 缺点：ES5 方法需要注意兼容性 改进： 所有三种方法应该在子类构造函数中调用父类构造函数实现实例属性初始化 123function Rect() { Shape.call(this);} 用新创建的对象替代子类默认原型，设置Rect.prototype.constructor = Rect;保证一致性 第三种方法的 polyfill： 123456789function create(obj) { if (Object.create) { return Object.create(obj); } function f() {}; f.prototype = obj; return new f();}","link":"/2020/02/25/js/js%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%982/"},{"title":"es6语法","text":"ES6 各种新语法 入门了解 hello-es6ES6 各种新语法 入门了解 石川blue讲解 视频地址 b站：深入解读ES6系列 看视频整理要点笔记: hello-es6 1.ES6怎么来的 2.ES6兼容性 3.变量 let 和 常量 const 4.函数-箭头函数 5.函数-参数 6.解构赋值 7.数组 8.字符串 9.面向对象-基础 10.面向对象应用 11.json 12.Promise 13.generator-认识生成器函数 14.generator-yield是啥 15.generator-实例 16.ES7 预览 1.ES6怎么来的 ECMAScript 和 JavaScript ECMA 是标准，JS 是实现 ECMAScript 简称 ECMA 或 ES 历史版本 1996, ES1.0 Netscape 将 JS 提交给 ECMA 组织，ES 正式出现 1999, ES3.0 被广泛支持 2011, ES5.1 成为 ISO 国际标准 2015, ES6.0 正式发布 2.ES6兼容性 ES6(ES2015) 支持的环境 IE10+, Chrome, FireFox, 移动端, NodeJS 解决不兼容办法，编译、转换 在线转换 或者提前编译 Babel 中文网 Babel 入门教程 阮一峰 Babel 是一个 JavaScript 编译器 一个广泛使用的转码器，可以将ES6代码转为ES5代码，从而在现有环境执行 现在就用 ES6 编写程序，而不用担心现有环境是否支持 3.变量 let 和 常量 const var 的问题 可以重复声明，没有报错和警告 无法限制修改 没有块级作用域， { } let 和 const 不能重复声明 都是块级作用域, { } 块内声明的，块外无效 let 是变量，可以修改 const 是常量，不能修改 块级作用域举例 原来用 var 的方式，结果弹出的都是 3 或者将变量 封装到函数里，限制作用域，但比较麻烦 用 let 最简单，直接 var 改 let，解决作用域问题 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; window.onload= function () { /* var aBtn = document.getElementsByTagName('input') for (var i=0; i &lt; aBtn.length; i++) { aBtn[i].onclick = function () { alert(i) } }*/ var aBtn = document.getElementsByTagName('input') for (let i = 0; i &lt; aBtn.length; i++) { aBtn[i].onclick = function () { alert(i) } } /* var aBtn = document.getElementsByTagName('input') for (var i = 0; i &lt; aBtn.length; i++) { // 封装到函数里，限制作用域 (function (i) { aBtn[i].onclick = function () { alert(i) } })(i) }*/ } &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"按钮1\"&gt; &lt;input type=\"button\" value=\"按钮2\"&gt; &lt;input type=\"button\" value=\"按钮3\"&gt;&lt;/body&gt;&lt;/html&gt; 4.函数-箭头函数 箭头函数，就是函数的简写 如果只有一个参数，() 可以省 如果只有一个return，{}可以省 12345678// 普通函数function name() {}// 箭头函数，去掉 function， 加上 =&gt;() =&gt; {} 12345678910111213141516171819let show1 = function () { console.log('abc')}let show2 = () =&gt; { console.log('abc')}show1() // 调用函数show2()let show4 = function (a) { return a*2}let show5 = a =&gt; a * 2 //简洁，类似python lambda 函数console.log(show4(10))console.log(show5(10)) 5.函数-参数 参数扩展／展开 ...args 收集剩余的参数，必须当到最后一个参数位置 展开数组，简写，效果和直接把数组的内容写在这儿一样 默认参数 12345678910111213141516function show(a, b, ...args) { console.log(a) console.log(b) console.log(args)}console.log(show(1, 2, 3, 4, 5))let arr1 = [1, 2, 3]let arr2 = [4, 5, 6]let arr3 = [...arr1, ...arr2]console.log(arr3)function show2(a, b=5, c=8) { console.log(a, b, c)}show2(88, 12) 6.解构赋值12345678let [a, b, c] = [1, 2, 3]console.log(a, b, c)let {x, y, z} = {x: 1, y: 2, z: 3}console.log(x, y, z)let [json, arr, num, str] = [{ a: 1, b: 2 }, [1, 2, 3], 8, 'str']console.log(json, arr, num, str) 解构赋值 左右两个边结构必须一样 右边必须是个东西 声明和赋值赋值不能分开，必须在一句话里 7.数组 新增4个方法 map 映射 一个对一个 12345678910111213141516let arr = [12, 5, 8]let result = arr.map(function (item) { return item*2})let result2 = arr.map(item=&gt;item*2) // 简写console.log(result)console.log(result2)let score = [18, 86, 88, 24]let result3 = score.map(item =&gt; item &gt;= 60 ? '及格' : '不及格')console.log(result3)// 结果[ 24, 10, 16 ][ 24, 10, 16 ][ '不及格', '及格', '及格', '不及格' ] reduce 汇总 一堆出来一个 用于比如，算个总数，算个平均 1234567891011121314151617var arr = [1, 3, 5, 7]var result = arr.reduce(function (tmp, item, index) { //tmp 上次结果，item当前数，index次数1开始 console.log(tmp, item, index) return tmp + item})console.log(result)var arr = [1, 3, 5, 7]var result = arr.reduce(function (tmp, item, index) { if (index != arr.length - 1) { // 不是最后一次 return tmp + item } else { return (tmp + item)/arr.length }})console.log(result) // 平均值 filter 过滤器 保留为true的 123456789101112var arr = [12, 4, 8, 9]var result = arr.filter(item =&gt; (item % 3 === 0) ? true : false)console.log(result)var result = arr.filter(item =&gt; item % 3 === 0)console.log(result)var arr = [ { title: '苹果', price: 10 }, { title: '西瓜', price: 20 },]var result = arr.filter(json =&gt; json.price &gt;= 20)console.log(result) forEach 循环迭代 123var arr = [12, 4, 8, 9]var result = arr.forEach(item =&gt; console.log(item))var result = arr.forEach((item, index)=&gt;console.log(item, index)) 8.字符串 多了两个新方法 startsWith endsWith 1234var url = 'http://qq.com'console.log(url.startsWith('http'))console.log(url.endsWith('com'))// 都是 true 字符串模版 使用反引号，${变量} 可以折行 1234567891011121314let a = 12let str1 = `asdf${a}`console.log(str1)let title = '标题'let content = '内容'let str = `&lt;div&gt;&lt;h1&gt;${title}&lt;/h1&gt;&lt;p&gt;${content}&lt;/p&gt;`console.log(str)&lt;div&gt;&lt;h1&gt;标题&lt;/h1&gt;&lt;p&gt;内容&lt;/p&gt; 9.面向对象-基础 原来写法 类和构造函数一样 属性和方法分开写的 123456789101112131415161718192021222324252627282930// 老版本function User(name, pass) { this.name = name this.pass = pass}User.prototype.showName = function () { console.log(this.name)}User.prototype.showPass = function () { console.log(this.pass)}var u1 = new User('able', '1233')u1.showName()u1.showPass()// 老版本继承function VipUser(name, pass, level) { User.call(this, name, pass) this.level = level}VipUser.prototype = new User()VipUser.prototype.constructor = VipUserVipUser.prototype.showLevel = function () { console.log(this.level)}var v1 = new VipUser('blue', '1234', 3)v1.showName()v1.showLevel() 新版面向对象 有了 class 关键字、构造器 class 里面直接加方法 继承，super 超类==父类 12345678910111213141516171819202122232425262728293031class User { constructor(name, pass) { this.name = name this.pass = pass } showName() { console.log(this.name) } showPass() { console.log(this.pass) }}var u1 = new User('able2', '111')u1.showName()u1.showPass()// 新版本继承class VipUser extends User { constructor(name, pass, level) { super(name, pass) this.level = level } showLevel(){ console.log(this.level) }}v1 = new VipUser('blue', '123', 3)v1.showLevel() 10.面向对象应用 React 用于构建用户界面的 JavaScript 库 组件化，一个组件就是一个 class JSX == bable == browser.js 11.json JSON 格式 JavaScript Object Notation 的缩写，是一种用于数据交换的文本格式 JSON 是 JS对象 的严格子集 JSON 的标准写法 只能用双引号 所有的key都必须用双引号包起来 JSON 对象 JSON 对象是 JavaScript 的原生对象，用来处理 JSON 格式数据，有两个静态方法 JSON.parse(string) ：接受一个 JSON 字符串并将其转换成一个 JavaScript 对象。 JSON.stringify(obj) ：接受一个 JavaScript 对象并将其转换为一个 JSON 字符串。 123456789101112var json = {a: 12, b: 5}var str = 'hi,' + JSON.stringify(json)var url = 'http://www.xx.com/' + encodeURIComponent(JSON.stringify(json))console.log(str)console.log(url)var str = '{\"a\": 12, \"b\": 4, \"c\": \"abc\"}'var json = JSON.parse(str)console.log(json)hi,{\"a\":12,\"b\":5}http://www.xx.com/%7B%22a%22%3A12%2C%22b%22%3A5%7D{ a: 12, b: 4, c: 'abc' } 对象（object） 是 JavaScript 语言的核心概念，也是最重要的数据类型 对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合 对象的所有键名都是字符串, 所以加不加引号都可以 如果键名是数值，会被自动转为字符串 对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型 如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用 in 运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值 for…in循环用来遍历一个对象的全部属性 对象 简写 key-value 一样时可以简写 里面函数可以简写, 去掉 123456789var a = 12, b = 5console.log({a:a, b:b})console.log({a, b})console.log({a, b, c:\"c\"})console.log({ a, b, show(){ console.log('a') }}){ a: 12, b: 5 }{ a: 12, b: 5 }{ a: 12, b: 5, c: 'c' }{ a: 12, b: 5, show: [Function: show] } 12.Promise 异步和同步 异步，操作之间没有关系，同时执行多个操作， 代码复杂 同步，同时只能做一件事，代码简单 Promise 对象 用同步的方式来书写异步代码 Promise 让异步操作写起来，像在写同步操作的流程，不必一层层地嵌套回调函数 改善了可读性，对于多层嵌套的回调函数很方便 充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口 Promise 也是一个构造函数 接受一个回调函数f1作为参数，f1里面是异步操作的代码 返回的p1就是一个 Promise 实例 所有异步任务都返回一个 Promise 实例 Promise 实例有一个then方法，用来指定下一步的回调函数 12345function f1(resolve, reject) { // 异步代码...}var p1 = new Promise(f1);p1.then(f2); // f1的异步操作执行完成，就会执行f2。 Promise 使得异步流程可以写成同步流程 12345678910111213141516// 传统写法step1(function (value1) { step2(value1, function(value2) { step3(value2, function(value3) { step4(value3, function(value4) { // ... }); }); });});// Promise 的写法(new Promise(step1)) .then(step2) .then(step3) .then(step4); Promise.all(promiseArray)方法 将多个Promise对象实例包装，生成并返回一个新的Promise实例 promise数组中所有的promise实例都变为resolve的时候，该方法才会返回 并将所有结果传递results数组中 promise数组中任何一个promise为reject的话，则整个Promise.all调用会立即终止，并返回一个reject的新的promise对象 123456var p1 = Promise.resolve(1), p2 = Promise.resolve(2), p3 = Promise.resolve(3);Promise.all([p1, p2, p3]).then(function (results) { console.log(results); // [1, 2, 3]}); Promise.race([p1, p2, p3]) Promse.race就是赛跑的意思 哪个结果获得的快，就返回那个结果 不管结果本身是成功状态还是失败状态 13.generator-认识生成器函数 generator 生成器函数 普通函数，一路到底 generator函数，中间可以停，到哪停呢，用 yield 配合，交出执行权 yield 有 放弃、退让、退位的意思 需要调用next()方法启动执行，需要遇到 yield 停, 踹一脚走一步 generator函数前面加一个 * 两边可以有空格，或靠近函数或function 背后实际生成多个小函数，实现走走停停 123456789101112131415function show() { console.log('a') console.log('b')}show() // 普通函数function *show2() { console.log('1') yield console.log('2')}let genObj = show2()genObj.next() // 1genObj.next() // 2genObj.next() // 最后了，没有结果 14.generator-yield是啥 yield 既可传参，又可以返回 第一个next()传参无效，只用来启动 如果函数前漏掉 * 就是普通函数 如果有yield会报错， ReferenceError: yield is not defined yield 只能在Generator函数内部使用 1234567891011121314151617181920212223242526function * show() { console.log('1') var a = yield console.log('2') console.log(a)}// yield 传参var gen = show()gen.next() // 1gen.next() // 2 和 undefined 因为没有传参，yield没有返回值var gen = show()gen.next(10) // 1 第一次执行到yield，但没有执行赋值gen.next(20) // 2 和 20function* show2() { console.log('1') yield 10 console.log('2')}// yield 返回var gen = show2()var res1 = gen.next()console.log(res1) // { value: 10, done: false }var res2 = gen.next()console.log(res2)// { value: undefined, done: true } 最后的value需要return返回 15.generator-实例 Promise 适合一次读一组 generator 适合逻辑性的 12345678910// 带逻辑-generatorrunner(function * () { let userData = yield $.ajax({url: 'getUserData'}) if (userData.type == 'VIP') { let items = yield $.ajax({url: 'getVIPItems'}) } else { let items = yield $.ajax({url: 'getItems'}) }}) 12345// yield 实例，用同步方式写异步server.use(function * () { let data = yield db.query(`select * from user_table`) this.body = data}) 16.ES7 预览 数组 arr.includes() 数组是否包含某个东西 数组的 arr.keys(), arr,entries() for … in 遍历数组 下标 key for … of 遍历数组 值 value, 不能用于json 123456789101112131415161718192021let arr = ['a', 'b', 'c']console.log(arr.includes(1))for (let i in arr) { console.log(i) // 循环的时下标 key}for (let i of arr) { console.log(i) // 循环的是值 value}for (let i of arr.keys()) { console.log('&gt;'+i)}for (let [key, value] of arr.entries()) { console.log('&gt;' + key + value)}let json = { a: 12, b: 5, c: 7 }for (let i in json) { console.log(i)} 字符串 padStart()/padEnd() 指定宽度，不够就补空格或指定字符 1234console.log('=' + 'abcd'.padStart(6, '0') + '=')console.log('=' + 'abcd'.padEnd(6, '0') + '=')=00abcd==abcd00= 容忍度 [1, 2, 3,] 老版数组最后不能有逗号，新的可以有 函数参数最后多的逗号也可以 async await 和 generator yield 类似 generator 不可以写成箭头函数， async 可以 12345async function show() { console.log(1) await console.log(2)}","link":"/2020/02/26/js/es6%E8%AF%AD%E6%B3%95/"},{"title":"【前端面试】经典面试题基础","text":"javascript基础面试题 说说写JavaScript的基本规范？ 不要在同一行声明多个变量使用 ===或!==来比较true/false或者数值switch必须带有default分支函数应该有返回值语句结束加分号命名要有意义，使用驼峰命名法 javascript的typeof返回哪些数据类型. string,boolean,number,undefined,function,object,es6新增symbol 栈和堆的区别？ 栈（stack）：由编译器自动分配释放，存放函数的参数值，局部变量等；堆（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统释放。 null，undefined的区别？ null表示一个对象被定义了，但存放了空指针，转换为数值时为0。undefined表示声明的变量未初始化，转换为数值时为NAN。typeof(null) – object;typeof(undefined) – undefined split() join() 的区别 前者是将字符串切割成数组的形式，后者是将数组转换成字符串 [“1”, “2”, “3”].map(parseInt) 答案是多少？ 答案：[1,NaN,NaN] 是不是很奇怪, 1 为什么能被转换成1 其他2 ，3 会被转换成NAN12345678解析： Array.prototype.map() array.map(callback[, thisArg]) callback函数的执行规则 参数：自动传入三个参数 currentValue（当前被传递的元素）； index（当前被传递的元素的索引）； array（调用map方法的数组） javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？ 除了正常模式运行外，ECMAscript添加了第二种运行模式：“严格模式”。作用： 1) 消除js不合理，不严谨地方，减少怪异行为2) 消除代码运行的不安全之处，3) 提高编译器的效率，增加运行速度4) 为未来的js新版本做铺垫。 如何判断一个对象是否属于某个类？ 使用instanceof 即if(a instanceof Person){alert(‘yes’);} new操作符具体干了什么呢? 1) 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。2) 属性和方法被加入到 this 引用的对象中。3) 新创建的对象由 this 所引用，并且最后隐式的返回 this 。","link":"/2019/03/12/js/js%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"js简介","text":"JavaScript背景Web前端有三层： HTML：从语义的角度，描述页面结构 CSS：从审美的角度，描述样式（美化页面） JavaScript：从交互的角度，描述行为（实现业务逻辑和页面控制） 前言来自 https://github.com/qianguyihao/Web 发展历史JavaScript诞生于1995年。布兰登 • 艾奇（Brendan Eich，1961年～），1995年在网景公司，发明的JavaScript。 JavaScript是由网景公司发明，起初命名为LiveScript；1995年年12月SUN公司合作，因市场宣传需要，改名为 JavaScript。 后来 Sun 公司 被Oracle收购，JavaScript版权归Oracle所有。 备注：由于当时Java这个语言特别火，所以为了傍大牌，就改名为JavaScript。如同“北大”和“北大青鸟”的关系。“北大青鸟”就是傍“北大”大牌。 同时期还有其他的网页语言，比如VBScript、JScript等等，但是后来都被JavaScript打败了，所以现在的浏览器中，只运行一种脚本语言就是JavaScript。 JavaScript是世界上用的最多的脚本语言。 JavaScript的发展：蒸蒸日上2003年之前，JavaScript被认为“牛皮鲜”，用来制作页面上的广告，弹窗、漂浮的广告。什么东西让人烦，什么东西就是JavaScript开发的。所以很多浏览器就推出了屏蔽广告功能。 2004年，JavaScript命运开始改变。那一年，谷歌公司开始带头使用Ajax技术，Ajax技术就是JavaScript的一个应用。并且，那时候人们逐渐开始提升用户体验了。Ajax有一些应用场景。比如，当我们在百度搜索框搜文字时，输入框下方的智能提示，可以通过Ajax实现。比如，当我们注册网易邮箱时，能够及时发现用户名是否被占用，而不用调到另外一个页面。 2007年乔布斯发布了第一款iPhone，这一年开始，用户就多了上网的途径，就是用移动设备上网。JavaScript在移动页面中，也是不可或缺的。并且这一年，互联网开始标准化，按照W3C规则三层分离，JavaScript越来越被重视。 2010年，人们更加了解HTML5技术，HTML5推出了一个东西叫做Canvas（画布），工程师可以在Canvas上进行游戏制作，利用的就是JavaScript。 2011年，Node.js诞生，使JavaScript能够开发服务器程序了。 如今，WebApp已经非常流行，就是用网页技术开发手机应用。手机系统有iOS、安卓。比如公司要开发一个“携程网”App，就需要招聘三队人马，比如iOS工程师10人，安卓工程师10人，前端工程师10人。共30人，开发成本大；而且如果要改版，要改3个版本。现在，假设公司都用web技术，用html+css+javascript技术就可以开发App。也易于迭代（网页一改变，所有的终端都变了）。 虽然目前WebApp（Web应用）在功能和性能上的体验远不如Native App（原生应用），但是“在原生App中内嵌一部分H5页面”已经是一种趋势。 浏览器的介绍浏览器是网页运行的平台，常用的浏览器有谷歌（Chrome）、Safari、火狐（Firefox）、IE、Edge、Opera等。如下图所示： 浏览器的组成浏览器分成两部分： 渲染引擎 JS 引擎 1、渲染引擎：（浏览器内核） 浏览器所采用的「渲染引擎」也称之为「浏览器内核」，用来解析 HTML与CSS。渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。渲染引擎是兼容性问题出现的根本原因。 常见浏览器的内核如下： 浏览器 内核 chrome / 欧鹏 Blink Safari Webkit Firefox 火狐 Gecko IE Trident 2、JS 引擎： 也称为 JS 解释器。 用来解析网页中的JavaScript代码，对其处理后再运行。 浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行时会逐行解释源码（转换为机器语言），然后由计算机去执行。 浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行。所以 JavaScript 语言归为脚本语言，会逐行解释执行。 常见浏览器的 JS 引擎如下： 浏览器 JS 引擎 chrome / 欧鹏 V8 Safari Nitro Firefox 火狐 SpiderMonkey（1.0-3.0）/ TraceMonkey（3.5-3.6）/ JaegerMonkey（4.0-） Opera Linear A（4.0-6.1）/ Linear B（7.0-9.2）/ Futhark（9.5-10.2）/ Carakan（10.5-） IE Trident 参考链接： 主流浏览器内核及JS引擎 浏览器工作原理 1、User Interface 用户界面，我们所看到的浏览器 2、Browser engine 浏览器引擎，用来查询和操作渲染引擎 3、Rendering engine 用来显示请求的内容，负责解析HTML、CSS 4、Networking 网络，负责发送网络请求 5、JavaScript Interpreter(解析者) JavaScript解析器，负责执行JavaScript的代码 6、UI Backend UI后端，用来绘制类似组合框和弹出窗口 7、Data Persistence(持久化) 数据持久化，数据存储 cookie、HTML5中的sessionStorage 参考链接：https://www.2cto.com/kf/201202/118111.html JavaScript介绍JavaScript入门易学性 JavaScript对初学者比较友好、简单易用。可以使用任何文本编辑工具编写，只需要浏览器就可以执行程序。 JavaScript是有界面效果的（相比之下，C语言只有白底黑字）。 JavaScript是弱变量类型的语言，变量只需要用 var/let/const 来声明。而Java中变量的声明，要根据变量的类型来定义。 比如Java中需要定义如下变量： 12345int a;float a;double a;String a;boolean a; 而JavaScript中，只需要用一种方式来定义： 123456// ES5 写法var a;// ES6 写法const a;let a; JavaScript是前端语言JavaScript是前端语言，而不是后台语言。 JavaScript运行在用户的终端网页上，而不是服务器上，所以我们称之为“前端语言”。就是服务于页面的交互效果、美化，不能操作数据库。 后台语言是运行在服务器上的，比如PHP、ASP、JSP等等，这些语言都能够操作数据库，都能够对数据库进行“增删改查”操作。 备注：Node.js是用 JavaScript 开发的，现在也可以基于 Node.js 技术进行服务器端编程。 JavaScript的组成JavaScript基础分为三个部分： ECMAScript：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。 DOM：Document Object Model（文档对象模型），操作页面上的元素的API。比如让盒子移动、变色、改变大小、轮播图等等。 BOM：Browser Object Model（浏览器对象模型），操作浏览器部分功能的API。通过BOM可以操作浏览器窗口，比如弹框、控制浏览器跳转、获取浏览器分辨率等等。 JavaScript 的特点特点1：解释型语言JavaScript 是解释型语言，不需要事先被翻译为机器码；而是边翻译边执行（翻译一行，执行一行）。 什么是「解释型语言」？详见下一段。 由于少了实现编译这一步骤，所以解释型语言开发起来尤为方便，但是解释型语言运行较慢也是它的劣势。不过解释型语言中使用了JIT技术，使得运行速度得以改善。 特点2：单线程特点3：ECMAScript标准ECMAScript是一种由 ECMA 国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）制定和发布的脚本语言规范。 JavaScript是由公司开发而成的，问题是不便于其他的公司拓展和使用。所以欧洲的这个ECMA的组织，牵头制定JavaScript的标准，取名为ECMAScript。 简单来说，ECMAScript不是一门语言，而是一个标准。ECMAScript 规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。 ECMAScript在2015年6月，发布了ECMAScript 6版本（ES6），语言的能力更强（也包含了很多新特性）。但是，浏览器的厂商不会那么快去追上这个标准，需要时间。 编程语言的分类翻译器计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所编写的语言翻译成机器语言，计算机才能执行程序。程序语言翻译成机器语言的工具，被称为翻译器。 由此可见，所谓的“翻译”，指的是翻译成计算机能够执行的指令。 翻译器翻译的方式有两种：一种是编译，另一种是解释。两种方式之间的区别在于翻译的时机不同。 编译器：在代码执行之前，事前把所有的代码一次性翻译好，生成中间代码文件，然后整体执行。 解释器：边翻译，边执行（在代码执行时进行及时翻译，并立即执行）。当编译器以解释的方式运行时，也称之为解释器。 对应的语言，称之为“编译型语言”、“解释型语言”。 编译型语言 定义：事先把所有的代码一次性翻译好，然后整体执行。 优点：运行更快。 不足：移植性不好，不跨平台。 编译型语言举例：c、c++ 比如说，c语言的代码文件是.c后缀，翻译之后文件是.obj后缀，系统执行的是 obj 文件；再比如， java 语言的代码文件是.java后缀，翻译之后的文件是.class后缀。（注意，Java 语言不是严格的 编译型语言，这个一会儿会讲） 解释型语言 定义：边翻译边执行（翻译一行，执行一行），不需要事先一次性翻译。 优点：移植性好，跨平台。 缺点：运行更慢。 解释型语言举例：JavaScript、php、Python。 Java语言Java 语言既不是编译型语言，也不是解释型语言。翻译过程： （1）编译：.java代码文件先通过 javac 命令编译成.class文件。 （2）执行：.class文件再通过 jvm 虚拟机，解释执行。有了 jvm 的存在，让 java 跨平台了。 开始写第一行JavaScript代码 JavaScript 代码的书写位置在哪里呢？这个问题，也可以理解成：引入 js 代码，有哪几种方式。 方式1：行内式代码举例： 1&lt;input type=\"button\" value=\"点我点我\" onclick=\"alert('千古壹号')\" /&gt; 完整的可执行代码如下： 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"button\" value=\"点我点我\" onclick=\"alert('千古壹号的方式1')\" /&gt; &lt;/body&gt;&lt;/html&gt; 分析： 可以将单行或少量 JS 代码写在HTML标签的事件属性中（以 on 开头的属性），比如放在上面的 onclick点击事件中。 这种书写方式，不推荐使用，原因是：可读性差，尤其是需要编写大量 JS代码时，容易出错；引号多层嵌套时，也容易出错。 关于代码中的「引号」，在HTML标签中，我们推荐使用双引号, JS 中我们推荐使用单引号。 方式2、内嵌式我们可以在html 页面的 &lt;body&gt; 标签里放入&lt;script type=”text/javascript”&gt;&lt;/script&gt;标签对儿，并在&lt;script&gt;里书写JavaScript 代码： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 在这里写 js 代码 alert('千古壹号的方式2'); console.log('qianguyihao 方式2'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 分析： text表示纯文本，因为JavaScript也是一个纯文本的语言。 可以将多行JS代码写到 &lt;script&gt; 标签中。 内嵌式 JS 是学习时常用的方式。 方式3：引入外部的 JS 文件1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 引入外部的 js 文件 --&gt; &lt;script src=\"tool.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面这段代码，依然是放到body标签里，可以和内嵌的js代码并列。 另外，引用外部 JS文件的 script 标签中间不可以再写代码。 总结： 我们在实战开发中，基本都是采用方式3，因为这种方式，可以确保 html 文件和 js 文件是分开的，有利于代码的结构化和复用。很少会有人把一大堆 js 代码塞到 html 文件里。 JS一些简单的语法规则学习程序，是有规律可循的，程序会有有相同的部分，这些部分就是一种规定，不能更改，我们成为：语法。 （1）JavaScript对换行、缩进、空格不敏感。每一条语句以分号结尾。 也就是说： 代码一： 1234&lt;script type=\"text/javascript\"&gt; alert(\"今天蓝天白云\"); alert(\"我很高兴\");&lt;/script&gt; 等价于代码二： 123&lt;script type=\"text/javascript\"&gt; alert(\"今天蓝天白云\");alert(\"我很高兴\");&lt;/script&gt; 备注：每一条语句末尾要加上分号，虽然分号不是必须加的，如果不写分号，浏览器会自动添加，但是会消耗一些系统资源。 （2）所有的符号，都是英语的。比如括号、引号、分号。 如果你用的是搜狗拼音，建议不要用shift切换中英文（可以在搜狗软件里进行设置），不然很容易输入中文的分号；建议用ctrl+space切换中英文输入法。 （3）严格区分大小写。 注释我们不要把 HTML、CSS、JavaScript三者的注释格式搞混淆了。 HTML 的注释1&lt;!-- 我是注释 --&gt; CSS的注释12345678910111213&lt;style type=\"text/css\"&gt; /* 我是注释 */ p{ font-weight: bold; font-style: italic; color: red; }&lt;/style&gt; 注意：CSS只有/* */这种注释，没有//这种注释。而且注释要写在&lt;style&gt;标签里面才算生效哦。 JavaScript 的注释单行注释： 1// 我是注释 多行注释： 1234/* 多行注释1 多行注释2*/ 补充：VS Code中，单行注释的快捷键是「Ctrl + /」，多行注释的默认快捷键是「Alt + Shift + A」。 当然，如果你觉得多行注释的默认快捷键不方便，我们还可以修改默认快捷键。操作如下： VS Code –&gt; 首选项 –&gt; 键盘快捷方式 –&gt; 查找“注释”这两个字 –&gt; 将原来的快捷键修改为「Ctrl + Shift + /」。 Javascript 输入输出语句弹出警告框：alert语句我们要学习的第一个语句，就是alert语句。 代码举例如下： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; alert('千古壹号'); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; alert（英文翻译为“警报”）的用途：弹出“警告框”。 alert(&quot;&quot;)警告框的效果如下： 这个警告框，在IE浏览器中长这样： 上面的代码中，如果写了两个alert()语句的话，网页的效果是：弹出第一个警告框，点击确定后，继续弹出第二个警告框。 控制台输出：console.log(“”)console.log(&quot;&quot;)表示在控制台中输出。console表示“控制台”，log表示“输出”。 在Chrome浏览器中，按F12即可打开控制台，选择「console」栏，即可看到打印的内容。 console.log(&quot;&quot;)效果如下： 控制台是工程师、程序员调试程序的地方。程序员经常使用这条语句输出一些东西，来测试程序是否正确。 普通人是不会在意控制台的，但是有些网站另藏玄机。有个很有意思的地方是，百度首页的控制台，悄悄地放了一段招聘信息： 毕竟做前端的人是经常使用控制台的。 总结：alert() 主要用来显示消息给用户，console.log() 用来给程序员自己调试用的。 弹出输入框：prompt()语句prompt()就是专门用来弹出能够让用户输入的对话框。用得少，测试的时候偶尔会用。 JS代码如下： 12var a = prompt(\"请随便输入点什么东西吧\");console.log(a); 上方代码中，用户输入的内容，将被传递到变量 a 里面，并在控制台打印出来。 效果如下： prompt()语句中，用户不管输入什么内容，都是字符串。 alert()和prompt()的区别： alert() 可以直接使用。 prompt() 会返回用户输入的内容。我们可以用一个变量，来接收用户输入的内容。","link":"/2020/03/08/js/js%E7%AE%80%E4%BB%8B/"},{"title":"js编程部分面试题","text":"javascript 算法题 请用原生 js 实现一个函数,给页面制定的任意一个元素添加一个透明遮罩(透明度可变,默认 0.2),使这个区域点击无效,要求兼容 IE8+及各主流浏览器,12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style&gt;#target { width: 200px; height: 300px; margin: 40px; background-color: tomato;}&lt;/style&gt;&lt;div id=&quot;target&quot;&gt;&lt;/div&gt;&lt;script&gt;function addMask(elem, opacity) { opacity = opacity || 0.2; var rect = elem.getBoundingClientRect(); var style = getComputedStyle(elem, null); var mask = document.createElement('div'); mask.style.position = 'absolute'; var marginLeft = parseFloat(style.marginLeft); mask.style.left = (elem.offsetLeft - marginLeft) + 'px'; var marginTop = parseFloat(style.marginTop); mask.style.top = (elem.offsetTop - marginTop) + 'px'; mask.style.zIndex = 9999; mask.style.opacity = '' + opacity; mask.style.backgroundColor = '#000'; mask.style.width = (parseFloat(style.marginLeft) + parseFloat(style.marginRight) + rect.width) + 'px'; mask.style.height = (parseFloat(style.marginTop) + parseFloat(style.marginBottom) + rect.height) + 'px'; elem.parentNode.appendChild(mask);}var target = document.getElementById('target');addMask(target);target.addEventListener('click', function () { console.log('click');}, false);&lt;/script&gt; 请用代码写出(今天是星期 x)其中 x 表示当天是星期几,如果当天是星期一,输出应该是”今天是星期一”1234var days = ['日','一','二','三','四','五','六'];var date = new Date();console.log('今天是星期' + days[date.getDay()]); 下面这段代码想要循环延时输出结果 0 1 2 3 4,请问输出结果是否正确,如果不正确,请说明为什么,并修改循环内的代码使其输出正确结果12345for (var i = 0; i &lt; 5; ++i) { setTimeout(function () { console.log(i + ' '); }, 100);} 不能输出正确结果，因为循环中 setTimeout 接受的参数函数通过闭包访问变量 i。javascript 运行环境为单线程，setTimeout 注册的函数需要等待线程空闲才能执行，此时 for 循环已经结束，i 值为 5.五个定时输出都是 5修改方法：将 setTimeout 放在函数立即调用表达式中，将 i 值作为参数传递给包裹函数，创建新闭包 1234567for (var i = 0; i &lt; 5; ++i) { (function (i) { setTimeout(function () { console.log(i + ' '); }, 100); }(i));} 现有一个 Page 类,其原型对象上有许多以 post 开头的方法(如 postMsg);另有一拦截函数 chekc,只返回 ture 或 false.请设计一个函数,该函数应批量改造原 Page 的 postXXX 方法,在保留其原有功能的同时,为每个 postXXX 方法增加拦截验证功能,当 chekc 返回 true 时继续执行原 postXXX 方法,返回 false 时不再执行原 postXXX 方法1234567891011121314151617181920212223242526272829303132333435363738394041function Page() {}Page.prototype = { constructor: Page, postA: function (a) { console.log('a:' + a); }, postB: function (b) { console.log('b:' + b); }, postC: function (c) { console.log('c:' + c); }, check: function () { return Math.random() &gt; 0.5; }}function checkfy(obj) { for (var key in obj) { if (key.indexOf('post') === 0 &amp;&amp; typeof obj[key] === 'function') { (function (key) { var fn = obj[key]; obj[key] = function () { if (obj.check()) { fn.apply(obj, arguments); } }; }(key)); } }} // end checkfy()checkfy(Page.prototype);var obj = new Page();obj.postA('checkfy');obj.postB('checkfy');obj.postC('checkfy'); 编写 javascript 深度克隆函数 deepClonefunction deepClone(obj) { var _toString = Object.prototype.toString; // null, undefined, non-object, function if (!obj || typeof obj !== &apos;object&apos;) { return obj; } // DOM Node if (obj.nodeType &amp;&amp; &apos;cloneNode&apos; in obj) { return obj.cloneNode(true); } // Date if (_toString.call(obj) === &apos;[object Date]&apos;) { return new Date(obj.getTime()); } // RegExp if (_toString.call(obj) === &apos;[object RegExp]&apos;) { var flags = []; if (obj.global) { flags.push(&apos;g&apos;); } if (obj.multiline) { flags.push(&apos;m&apos;); } if (obj.ignoreCase) { flags.push(&apos;i&apos;); } return new RegExp(obj.source, flags.join(&apos;&apos;)); } var result = Array.isArray(obj) ? [] : obj.constructor ? new obj.constructor() : {}; for (var key in obj ) { result[key] = deepClone(obj[key]); } return result; } function A() { this.a = a; } var a = { name: &apos;qiu&apos;, birth: new Date(), pattern: /qiu/gim, container: document.body, hobbys: [&apos;book&apos;, new Date(), /aaa/gim, 111] }; var c = new A(); var b = deepClone(c); console.log(c.a === b.a); console.log(c, b);补充代码,鼠标单击 Button1 后将 Button1 移动到 Button2 的后面&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;TEst&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;input type=&quot;button&quot; id =&quot;button1&quot; value=&quot;1&quot; /&gt; &lt;input type=&quot;button&quot; id =&quot;button2&quot; value=&quot;2&quot; /&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var btn1 = document.getElementById(&apos;button1&apos;); var btn2 = document.getElementById(&apos;button2&apos;); addListener(btn1, &apos;click&apos;, function (event) { btn1.parentNode.insertBefore(btn2, btn1); }); function addListener(elem, type, handler) { if (elem.addEventListener) { elem.addEventListener(type, handler, false); return handler; } else if (elem.attachEvent) { function wrapper() { var event = window.event; event.target = event.srcElement; handler.call(elem, event); } elem.attachEvent(&apos;on&apos; + type, wrapper); return wrapper; } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;网页中实现一个计算当年还剩多少时间的倒数计时程序,要求网页上实时动态显示”×× 年还剩 ×× 天 ×× 时 ×× 分 ×× 秒”&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;TEst&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;span id=&quot;target&quot;&gt;&lt;/span&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 为了简化。每月默认30天 function getTimeString() { var start = new Date(); var end = new Date(start.getFullYear() + 1, 0, 1); var elapse = Math.floor((end - start) / 1000); var seconds = elapse % 60 ; var minutes = Math.floor(elapse / 60) % 60; var hours = Math.floor(elapse / (60 * 60)) % 24; var days = Math.floor(elapse / (60 * 60 * 24)) % 30; var months = Math.floor(elapse / (60 * 60 * 24 * 30)) % 12; var years = Math.floor(elapse / (60 * 60 * 24 * 30 * 12)); return start.getFullYear() + &apos;年还剩&apos; + years + &apos;年&apos; + months + &apos;月&apos; + days + &apos;日&apos; + hours + &apos;小时&apos; + minutes + &apos;分&apos; + seconds + &apos;秒&apos;; } function domText(elem, text) { if (text == undefined) { if (elem.textContent) { return elem.textContent; } else if (elem.innerText) { return elem.innerText; } } else { if (elem.textContent) { elem.textContent = text; } else if (elem.innerText) { elem.innerText = text; } else { elem.innerHTML = text; } } } var target = document.getElementById(&apos;target&apos;); setInterval(function () { domText(target, getTimeString()); }, 1000) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;完成一个函数,接受数组作为参数,数组元素为整数或者数组,数组元素包含整数或数组,函数返回扁平化后的数组如：[1, [2, [ [3, 4], 5], 6]] =&gt; [1, 2, 3, 4, 5, 6] 123456789101112131415161718var data = [1, [2, [ [3, 4], 5], 6]];function flat(data, result) { var i, d, len; for (i = 0, len = data.length; i &lt; len; ++i) { d = data[i]; if (typeof d === 'number') { result.push(d); } else { flat(d, result); } }}var result = [];flat(data, result);console.log(result); 如何判断一个对象是否为数组如果浏览器支持 Array.isArray()可以直接判断否则需进行必要判断 123456789101112/** * 判断一个对象是否是数组，参数不是对象或者不是数组，返回false * * @param {Object} arg 需要测试是否为数组的对象 * @return {Boolean} 传入参数是数组返回true，否则返回false */function isArray(arg) { if (typeof arg === 'object') { return Object.prototype.toString.call(arg) === '[object Array]'; } return false;} 请评价以下事件监听器代码并给出改进意见123456789101112if (window.addEventListener) { var addListener = function (el, type, listener, useCapture) { el.addEventListener(type, listener, useCapture); };}else if (document.all) { addListener = function (el, type, listener) { el.attachEvent('on' + type, function () { listener.apply(el); }); };} 作用：浏览器功能检测实现跨浏览器 DOM 事件绑定 优点： 测试代码只运行一次，根据浏览器确定绑定方法 通过listener.apply(el)解决 IE 下监听器 this 与标准不一致的地方 在浏览器不支持的情况下提供简单的功能，在标准浏览器中提供捕获功能 缺点： document.all 作为 IE 检测不可靠，应该使用 if(el.attachEvent) addListener 在不同浏览器下 API 不一样 listener.apply使 this 与标准一致但监听器无法移除 未解决 IE 下 listener 参数 event。 target 问题 改进: 12345678910111213141516171819202122var addListener;if (window.addEventListener) { addListener = function (el, type, listener, useCapture) { el.addEventListener(type, listener, useCapture); return listener; };}else if (window.attachEvent) { addListener = function (el, type, listener) { // 标准化this，event，target var wrapper = function () { var event = window.event; event.target = event.srcElement; listener.call(el, event); }; el.attachEvent('on' + type, wrapper); return wrapper; // 返回wrapper。调用者可以保存，以后remove };}","link":"/2020/02/25/js/js%E7%BC%96%E7%A8%8B%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"js编程部分面试题2","text":"javascript 算法题 如何判断一个对象是否为函数1234567891011121314151617/** * 判断对象是否为函数，如果当前运行环境对可调用对象（如正则表达式） * 的typeof返回'function'，采用通用方法，否则采用优化方法 * * @param {Any} arg 需要检测是否是函数的对象 * @return {boolean} 如果参数是函数，返回true，否则false */function isFunction(arg) { if (arg) { if (typeof (/./) !== 'function') { return typeof arg === 'function'; } else { return Object.prototype.toString.call(arg) === '[object Function]'; } } // end if return false;} 编写一个函数接受 url 中 query string 为参数,返回解析后的 Object,query string 使用 application/x-www-form-urlencoded 编码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 解析query string转换为对象，一个key有多个值时生成数组 * * @param {String} query 需要解析的query字符串，开头可以是?， * 按照application/x-www-form-urlencoded编码 * @return {Object} 参数解析后的对象 */function parseQuery(query) { var result = {}; // 如果不是字符串返回空对象 if (typeof query !== 'string') { return result; } // 去掉字符串开头可能带的? if (query.charAt(0) === '?') { query = query.substring(1); } var pairs = query.split('&amp;'); var pair; var key, value; var i, len; for (i = 0, len = pairs.length; i &lt; len; ++i) { pair = pairs[i].split('='); // application/x-www-form-urlencoded编码会将' '转换为+ key = decodeURIComponent(pair[0]).replace(/\\+/g, ' '); value = decodeURIComponent(pair[1]).replace(/\\+/g, ' '); // 如果是新key，直接添加 if (!(key in result)) { result[key] = value; } // 如果key已经出现一次以上，直接向数组添加value else if (isArray(result[key])) { result[key].push(value); } // key第二次出现，将结果改为数组 else { var arr = [result[key]]; arr.push(value); result[key] = arr; } // end if-else } // end for return result;}function isArray(arg) { if (arg &amp;&amp; typeof arg === 'object') { return Object.prototype.toString.call(arg) === '[object Array]'; } return false;}/**console.log(parseQuery('sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8')); */ 解析一个完整的 url,返回 Object 包含域与 window.location 相同12345678910111213141516171819202122232425262728293031323334353637/** * 解析一个url并生成window.location对象中包含的域 * location: * { * href: '包含完整的url', * origin: '包含协议到pathname之前的内容', * protocol: 'url使用的协议，包含末尾的:', * username: '用户名', // 暂时不支持 * password: '密码', // 暂时不支持 * host: '完整主机名，包含:和端口', * hostname: '主机名，不包含端口' * port: '端口号', * pathname: '服务器上访问资源的路径/开头', * search: 'query string，?开头', * hash: '#开头的fragment identifier' * } * * @param {string} url 需要解析的url * @return {Object} 包含url信息的对象 */function parseUrl(url) { var result = {}; var keys = ['href', 'origin', 'protocol', 'host', 'hostname', 'port', 'pathname', 'search', 'hash']; var i, len; var regexp = /(([^:]+:)\\/\\/(([^:\\/\\?#]+)(:\\d+)?))(\\/[^?#]*)?(\\?[^#]*)?(#.*)?/; var match = regexp.exec(url); if (match) { for (i = keys.length - 1; i &gt;= 0; --i) { result[keys[i]] = match[i] ? match[i] : ''; } } return result;} 完成函数 getViewportSize 返回指定窗口的视口尺寸1234567891011121314151617181920212223242526272829/*** 查询指定窗口的视口尺寸，如果不指定窗口，查询当前窗口尺寸**/function getViewportSize(w) { w = w || window; // IE9及标准浏览器中可使用此标准方法 if ('innerHeight' in w) { return { width: w.innerWidth, height: w.innerHeight }; } var d = w.document; // IE 8及以下浏览器在标准模式下 if (document.compatMode === 'CSS1Compat') { return { width: d.documentElement.clientWidth, height: d.documentElement.clientHeight }; } // IE8及以下浏览器在怪癖模式下 return { width: d.body.clientWidth, height: d.body.clientHeight };} 完成函数 getScrollOffset 返回窗口滚动条偏移量/** * 获取指定window中滚动条的偏移量，如未指定则获取当前window * 滚动条偏移量 * * @param {window} w 需要获取滚动条偏移量的窗口 * @return {Object} obj.x为水平滚动条偏移量,obj.y为竖直滚动条偏移量 */ function getScrollOffset(w) { w = w || window; // 如果是标准浏览器 if (w.pageXOffset != null) { return { x: w.pageXOffset, y: w.pageYOffset }; } // 老版本IE，根据兼容性不同访问不同元素 var d = w.document; if (d.compatMode === &apos;CSS1Compat&apos;) { return { x: d.documentElement.scrollLeft, y: d.documentElement.scrollTop } } return { x: d.body.scrollLeft, y: d.body.scrollTop }; }现有一个字符串 richText,是一段富文本,需要显示在页面上.有个要求,需要给其中只包含一个 img 元素的 p 标签增加一个叫 pic 的 class.请编写代码实现.可以使用 jQuery 或 KISSY.function richText(text) { var div = document.createElement(&apos;div&apos;); div.innerHTML = text; var p = div.getElementsByTagName(&apos;p&apos;); var i, len; for (i = 0, len = p.length; i &lt; len; ++i) { if (p[i].getElementsByTagName(&apos;img&apos;).length === 1) { p[i].classList.add(&apos;pic&apos;); } } return div.innerHTML; }请实现一个 Event 类,继承自此类的对象都会拥有两个方法 on,off,once 和 triggerfunction Event() { if (!(this instanceof Event)) { return new Event(); } this._callbacks = {}; } Event.prototype.on = function (type, handler) { this_callbacks = this._callbacks || {}; this._callbacks[type] = this.callbacks[type] || []; this._callbacks[type].push(handler); return this; }; Event.prototype.off = function (type, handler) { var list = this._callbacks[type]; if (list) { for (var i = list.length; i &gt;= 0; --i) { if (list[i] === handler) { list.splice(i, 1); } } } return this; }; Event.prototype.trigger = function (type, data) { var list = this._callbacks[type]; if (list) { for (var i = 0, len = list.length; i &lt; len; ++i) { list[i].call(this, data); } } }; Event.prototype.once = function (type, handler) { var self = this; function wrapper() { handler.apply(self, arguments); self.off(type, wrapper); } this.on(type, wrapper); return this; };编写一个函数将列表子元素顺序反转1234567891011121314151617&lt;ul id=&quot;target&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var target = document.getElementById('target'); var i; var frag = document.createDocumentFragment(); for (i = target.children.length - 1; i &gt;= 0; --i) { frag.appendChild(target.children[i]); } target.appendChild(frag);&lt;/script&gt; 以下函数的作用是?空白区域应该填写什么123456789101112131415161718192021// define(function (window) { function fn(str) { this.str = str; } fn.prototype.format = function () { var arg = __1__; return this.str.replace(__2__, function (a, b) { return arg[b] || ''; }); }; window.fn = fn;})(window);// use(function () { var t = new fn('&lt;p&gt;&lt;a href=&quot;{0}&quot;&gt;{1}&lt;/a&gt;&lt;span&gt;{2}&lt;/span&gt;&lt;/p&gt;'); console.log(t.format('http://www.alibaba.com', 'Alibaba', 'Welcome'));})(); define 部分定义一个简单的模板类，使用{}作为转义标记，中间的数字表示替换目标，format 实参用来替换模板内标记横线处填： Array.prototype.slice.call(arguments, 0) /\\{\\s*(\\d+)\\s*\\}/g 编写一个函数实现 form 的序列化(即将一个表单中的键值序列化为可提交的字符串)&lt;form id=&quot;target&quot;&gt; &lt;select name=&quot;age&quot;&gt; &lt;option value=&quot;aaa&quot;&gt;aaa&lt;/option&gt; &lt;option value=&quot;bbb&quot; selected&gt;bbb&lt;/option&gt; &lt;/select&gt; &lt;select name=&quot;friends&quot; multiple&gt; &lt;option value=&quot;qiu&quot; selected&gt;qiu&lt;/option&gt; &lt;option value=&quot;de&quot;&gt;de&lt;/option&gt; &lt;option value=&quot;qing&quot; selected&gt;qing&lt;/option&gt; &lt;/select&gt; &lt;input name=&quot;name&quot; value=&quot;qiudeqing&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;11111&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;salery&quot; value=&quot;3333&quot;&gt; &lt;textarea name=&quot;description&quot;&gt;description&lt;/textarea&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; checked value=&quot;football&quot;&gt;Football &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;basketball&quot;&gt;Basketball &lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked value=&quot;Female&quot;&gt;Female &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;Male&quot;&gt;Male &lt;/form&gt; &lt;script&gt; /** * 将一个表单元素序列化为可提交的字符串 * * @param {FormElement} form 需要序列化的表单元素 * @return {string} 表单序列化后的字符串 */ function serializeForm(form) { if (!form || form.nodeName.toUpperCase() !== &apos;FORM&apos;) { return; } var result = []; var i, len; var field, fieldName, fieldType; for (i = 0, len = form.length; i &lt; len; ++i) { field = form.elements[i]; fieldName = field.name; fieldType = field.type; if (field.disabled || !fieldName) { continue; } // enf if switch (fieldType) { case &apos;text&apos;: case &apos;password&apos;: case &apos;hidden&apos;: case &apos;textarea&apos;: result.push(encodeURIComponent(fieldName) + &apos;=&apos; + encodeURIComponent(field.value)); break; case &apos;radio&apos;: case &apos;checkbox&apos;: if (field.checked) { result.push(encodeURIComponent(fieldName) + &apos;=&apos; + encodeURIComponent(field.value)); } break; case &apos;select-one&apos;: case &apos;select-multiple&apos;: for (var j = 0, jLen = field.options.length; j &lt; jLen; ++j) { if (field.options[j].selected) { result.push(encodeURIComponent(fieldName) + &apos;=&apos; + encodeURIComponent(field.options[j].value || field.options[j].text)); } } // end for break; case &apos;file&apos;: case &apos;submit&apos;: break; // 是否处理？ default: break; } // end switch } // end for return result.join(&apos;&amp;&apos;); } var form = document.getElementById(&apos;target&apos;); console.log(serializeForm(form)); &lt;/script&gt;使用原生 javascript 给下面列表中的 li 节点绑定点击事件,点击时创建一个 Object 对象,兼容 IE 和标准浏览器12345678910111213&lt;ul id=&quot;nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;http://11111&quot;&gt;111&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://2222&quot;&gt;222&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://333&quot;&gt;333&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://444&quot;&gt;444&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;Object:{ &quot;index&quot;: 1, &quot;name&quot;: &quot;111&quot;, &quot;link&quot;: &quot;http://1111&quot;} script: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778var EventUtil = { getEvent: function (event) { return event || window.event; }, getTarget: function (event) { return event.target || event.srcElement; }, // 返回注册成功的监听器，IE中需要使用返回值来移除监听器 on: function (elem, type, handler) { if (elem.addEventListener) { elem.addEventListener(type, handler, false); return handler; } else if (elem.attachEvent) { function wrapper(event) { return handler.call(elem, event); }; elem.attachEvent('on' + type, wrapper); return wrapper; } }, off: function (elem, type, handler) { if (elem.removeEventListener) { elem.removeEventListener(type, handler, false); } else if (elem.detachEvent) { elem.detachEvent('on' + type, handler); } }, preventDefault: function (event) { if (event.preventDefault) { event.preventDefault(); } else if ('returnValue' in event) { event.returnValue = false; } }, stopPropagation: function (event) { if (event.stopPropagation) { event.stopPropagation(); } else if ('cancelBubble' in event) { event.cancelBubble = true; } }};var DOMUtil = { text: function (elem) { if ('textContent' in elem) { return elem.textContent; } else if ('innerText' in elem) { return elem.innerText; } }, prop: function (elem, propName) { return elem.getAttribute(propName); }};var nav = document.getElementById('nav');EventUtil.on(nav, 'click', function (event) { var event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); var children = this.children; var i, len; var anchor; var obj = {}; for (i = 0, len = children.length; i &lt; len; ++i) { if (children[i] === target) { obj.index = i + 1; anchor = target.getElementsByTagName('a')[0]; obj.name = DOMUtil.text(anchor); obj.link = DOMUtil.prop(anchor, 'href'); } } alert('index: ' + obj.index + ' name: ' + obj.name + ' link: ' + obj.link);}); 有一个大数组,var a = [‘1’, ‘2’, ‘3’, …];a 的长度是 100,内容填充随机整数的字符串.请先构造此数组 a,然后设计一个算法将其内容去重123456789101112131415161718192021222324252627282930313233343536373839404142434445/*** 数组去重**/function normalize(arr) { if (arr &amp;&amp; Array.isArray(arr)) { var i, len, map = {}; for (i = arr.length; i &gt;= 0; --i) { if (arr[i] in map) { arr.splice(i, 1); } else { map[arr[i]] = true; } } } return arr;}/*** 用100个随机整数对应的字符串填充数组。**/function fillArray(arr, start, end) { start = start == undefined ? 1 : start; end = end == undefined ? 100 : end; if (end &lt;= start) { end = start + 100; } var width = end - start; var i; for (i = 100; i &gt;= 1; --i) { arr.push('' + (Math.floor(Math.random() * width) + start)); } return arr;}var input = [];fillArray(input, 1, 100);input.sort(function (a, b) { return a - b;});console.log(input);normalize(input);console.log(input);","link":"/2020/02/25/js/js%E7%BC%96%E7%A8%8B%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%982/"},{"title":"vuex 简单认识","text":"vuex 知识复习梳理 1.概念梳理vuex 状态管理 1.1 state唯一状态树mapState 简化state映射到局部计算属性 12345678computed: { localComputed () { /* ... */ }, // 使用对象展开运算符将状态对象混入到外部对象中 ...mapState([ // 映射 this.count 为 store.state.count 'count' ])} 1.2 gettersstate在store层面上的计算属性 123456getters: { // 接受state作为其第一个参数 doneTodos: state =&gt; { return state.todos.filter(todo =&gt; todo.done) }} mapGetters 简化getter映射到局部计算属性 12345678computed: { localComputed () { /* ... */ }, // 使用对象展开运算符将状态对象混入到外部对象中 ...mapGetters([ // 映射 this.doneTodos 为 store.getters.doneTodos 'doneTodos' ])} 1.3 mutations更改state的唯一方法是提交mutation(必须是同步的) 1234567891011121314// 定义mutations: { increment (state, payload) { // 状态变更 state.count += payload.amount }}// 调用store.commit('increment', { amount: 10 })或者 store.commit({ type: 'increment', amount: 10}) mapMutations 简化mutations映射到局部methods 123456methods: { ...mapMutations([ // 映射 this.increment(amount) 为 this.$store.commit('increment', amount) 'increment' ])} 1.4 actions可通过异步操作并提交mutation的方式变更state状态 1234567891011121314151617181920actions: { // context参数类似于store increment (context) { context.commit('increment') }}// 或者actions: { // 简化 increment ({ commit }) { commit('increment') }}// 触发actionstore.dispatch('incrementAsync', { amount: 10 })// 或者store.dispatch({ type: 'incrementAsync', amount: 10}) mapActions 简化actions映射到局部methods 123456methods: { ...mapActions([ // 映射 this.increment(amount) 为 this.$store.dispatch('increment', amount) 'increment' ])} 多个actions复杂交互(Action通常是异步的，store.dispatch返回Promise) 12345678910// 假设 getData() 和 getOtherData() 返回的是 Promiseactions: { async actionA ({ commit }) { commit('gotData', await getData()) // 等待异步完成 }, async actionB ({ dispatch, commit }) { // 第一个参数可以是dispatch await dispatch('actionA') // 等待 actionA 完成 commit('gotOtherData', await getOtherData()) // 像同步一样等待第二个异步完成 }} 1.5 module模块和plugins插件(插件暴露每个mutation钩子。就是一个以store为唯一参数的函数) 12345678910111213141516const store = new Vuex.Store({ modules: { moduleA, moduleB }, plugins: [createPersistedState({ storage: window.localStorage, // 持久化模块配置 reducer (state) { return { user: state.user } } })]})// store.state.moduleA // -&gt; moduleA 的状态","link":"/2020/03/02/vue/vuex-%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/"}],"tags":[{"name":"css","slug":"css","link":"/tags/css/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"面试题基础","slug":"面试题基础","link":"/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9F%BA%E7%A1%80/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"面试题算法","slug":"面试题算法","link":"/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AE%97%E6%B3%95/"},{"name":"vuex","slug":"vuex","link":"/tags/vuex/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"css","link":"/categories/css/"},{"name":"npm","slug":"npm","link":"/categories/npm/"},{"name":"js","slug":"js","link":"/categories/js/"},{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"},{"name":"ES6","slug":"ES6","link":"/categories/ES6/"},{"name":"vue","slug":"vue","link":"/categories/vue/"}]}