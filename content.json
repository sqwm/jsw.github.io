{"pages":[],"posts":[{"title":"【前端面试】经典面试题基础","text":"javascript基础面试题 说说写JavaScript的基本规范？ 不要在同一行声明多个变量使用 ===或!==来比较true/false或者数值switch必须带有default分支函数应该有返回值语句结束加分号命名要有意义，使用驼峰命名法 javascript的typeof返回哪些数据类型. string,boolean,number,undefined,function,object,es6新增symbol 栈和堆的区别？ 栈（stack）：由编译器自动分配释放，存放函数的参数值，局部变量等；堆（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统释放。 null，undefined的区别？ null表示一个对象被定义了，但存放了空指针，转换为数值时为0。undefined表示声明的变量未初始化，转换为数值时为NAN。typeof(null) – object;typeof(undefined) – undefined split() join() 的区别 前者是将字符串切割成数组的形式，后者是将数组转换成字符串 [“1”, “2”, “3”].map(parseInt) 答案是多少？ 答案：[1,NaN,NaN] 是不是很奇怪, 1 为什么能被转换成1 其他2 ，3 会被转换成NAN12345678解析： Array.prototype.map() array.map(callback[, thisArg]) callback函数的执行规则 参数：自动传入三个参数 currentValue（当前被传递的元素）； index（当前被传递的元素的索引）； array（调用map方法的数组） javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？ 除了正常模式运行外，ECMAscript添加了第二种运行模式：“严格模式”。作用： 1) 消除js不合理，不严谨地方，减少怪异行为2) 消除代码运行的不安全之处，3) 提高编译器的效率，增加运行速度4) 为未来的js新版本做铺垫。 如何判断一个对象是否属于某个类？ 使用instanceof 即if(a instanceof Person){alert(‘yes’);} new操作符具体干了什么呢? 1) 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。2) 属性和方法被加入到 this 引用的对象中。3) 新创建的对象由 this 所引用，并且最后隐式的返回 this 。","link":"/jsw.github.io/2019/03/12/js%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"js编程部分面试题","text":"javascript 算法题 请用原生 js 实现一个函数,给页面制定的任意一个元素添加一个透明遮罩(透明度可变,默认 0.2),使这个区域点击无效,要求兼容 IE8+及各主流浏览器,12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style&gt;#target { width: 200px; height: 300px; margin: 40px; background-color: tomato;}&lt;/style&gt;&lt;div id=&quot;target&quot;&gt;&lt;/div&gt;&lt;script&gt;function addMask(elem, opacity) { opacity = opacity || 0.2; var rect = elem.getBoundingClientRect(); var style = getComputedStyle(elem, null); var mask = document.createElement('div'); mask.style.position = 'absolute'; var marginLeft = parseFloat(style.marginLeft); mask.style.left = (elem.offsetLeft - marginLeft) + 'px'; var marginTop = parseFloat(style.marginTop); mask.style.top = (elem.offsetTop - marginTop) + 'px'; mask.style.zIndex = 9999; mask.style.opacity = '' + opacity; mask.style.backgroundColor = '#000'; mask.style.width = (parseFloat(style.marginLeft) + parseFloat(style.marginRight) + rect.width) + 'px'; mask.style.height = (parseFloat(style.marginTop) + parseFloat(style.marginBottom) + rect.height) + 'px'; elem.parentNode.appendChild(mask);}var target = document.getElementById('target');addMask(target);target.addEventListener('click', function () { console.log('click');}, false);&lt;/script&gt; 请用代码写出(今天是星期 x)其中 x 表示当天是星期几,如果当天是星期一,输出应该是”今天是星期一”1234var days = ['日','一','二','三','四','五','六'];var date = new Date();console.log('今天是星期' + days[date.getDay()]); 下面这段代码想要循环延时输出结果 0 1 2 3 4,请问输出结果是否正确,如果不正确,请说明为什么,并修改循环内的代码使其输出正确结果12345for (var i = 0; i &lt; 5; ++i) { setTimeout(function () { console.log(i + ' '); }, 100);} 不能输出正确结果，因为循环中 setTimeout 接受的参数函数通过闭包访问变量 i。javascript 运行环境为单线程，setTimeout 注册的函数需要等待线程空闲才能执行，此时 for 循环已经结束，i 值为 5.五个定时输出都是 5修改方法：将 setTimeout 放在函数立即调用表达式中，将 i 值作为参数传递给包裹函数，创建新闭包 1234567for (var i = 0; i &lt; 5; ++i) { (function (i) { setTimeout(function () { console.log(i + ' '); }, 100); }(i));} 现有一个 Page 类,其原型对象上有许多以 post 开头的方法(如 postMsg);另有一拦截函数 chekc,只返回 ture 或 false.请设计一个函数,该函数应批量改造原 Page 的 postXXX 方法,在保留其原有功能的同时,为每个 postXXX 方法增加拦截验证功能,当 chekc 返回 true 时继续执行原 postXXX 方法,返回 false 时不再执行原 postXXX 方法1234567891011121314151617181920212223242526272829303132333435363738394041function Page() {}Page.prototype = { constructor: Page, postA: function (a) { console.log('a:' + a); }, postB: function (b) { console.log('b:' + b); }, postC: function (c) { console.log('c:' + c); }, check: function () { return Math.random() &gt; 0.5; }}function checkfy(obj) { for (var key in obj) { if (key.indexOf('post') === 0 &amp;&amp; typeof obj[key] === 'function') { (function (key) { var fn = obj[key]; obj[key] = function () { if (obj.check()) { fn.apply(obj, arguments); } }; }(key)); } }} // end checkfy()checkfy(Page.prototype);var obj = new Page();obj.postA('checkfy');obj.postB('checkfy');obj.postC('checkfy'); 编写 javascript 深度克隆函数 deepClonefunction deepClone(obj) { var _toString = Object.prototype.toString; // null, undefined, non-object, function if (!obj || typeof obj !== &apos;object&apos;) { return obj; } // DOM Node if (obj.nodeType &amp;&amp; &apos;cloneNode&apos; in obj) { return obj.cloneNode(true); } // Date if (_toString.call(obj) === &apos;[object Date]&apos;) { return new Date(obj.getTime()); } // RegExp if (_toString.call(obj) === &apos;[object RegExp]&apos;) { var flags = []; if (obj.global) { flags.push(&apos;g&apos;); } if (obj.multiline) { flags.push(&apos;m&apos;); } if (obj.ignoreCase) { flags.push(&apos;i&apos;); } return new RegExp(obj.source, flags.join(&apos;&apos;)); } var result = Array.isArray(obj) ? [] : obj.constructor ? new obj.constructor() : {}; for (var key in obj ) { result[key] = deepClone(obj[key]); } return result; } function A() { this.a = a; } var a = { name: &apos;qiu&apos;, birth: new Date(), pattern: /qiu/gim, container: document.body, hobbys: [&apos;book&apos;, new Date(), /aaa/gim, 111] }; var c = new A(); var b = deepClone(c); console.log(c.a === b.a); console.log(c, b);补充代码,鼠标单击 Button1 后将 Button1 移动到 Button2 的后面&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;TEst&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;input type=&quot;button&quot; id =&quot;button1&quot; value=&quot;1&quot; /&gt; &lt;input type=&quot;button&quot; id =&quot;button2&quot; value=&quot;2&quot; /&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var btn1 = document.getElementById(&apos;button1&apos;); var btn2 = document.getElementById(&apos;button2&apos;); addListener(btn1, &apos;click&apos;, function (event) { btn1.parentNode.insertBefore(btn2, btn1); }); function addListener(elem, type, handler) { if (elem.addEventListener) { elem.addEventListener(type, handler, false); return handler; } else if (elem.attachEvent) { function wrapper() { var event = window.event; event.target = event.srcElement; handler.call(elem, event); } elem.attachEvent(&apos;on&apos; + type, wrapper); return wrapper; } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;网页中实现一个计算当年还剩多少时间的倒数计时程序,要求网页上实时动态显示”×× 年还剩 ×× 天 ×× 时 ×× 分 ×× 秒”&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;TEst&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;span id=&quot;target&quot;&gt;&lt;/span&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 为了简化。每月默认30天 function getTimeString() { var start = new Date(); var end = new Date(start.getFullYear() + 1, 0, 1); var elapse = Math.floor((end - start) / 1000); var seconds = elapse % 60 ; var minutes = Math.floor(elapse / 60) % 60; var hours = Math.floor(elapse / (60 * 60)) % 24; var days = Math.floor(elapse / (60 * 60 * 24)) % 30; var months = Math.floor(elapse / (60 * 60 * 24 * 30)) % 12; var years = Math.floor(elapse / (60 * 60 * 24 * 30 * 12)); return start.getFullYear() + &apos;年还剩&apos; + years + &apos;年&apos; + months + &apos;月&apos; + days + &apos;日&apos; + hours + &apos;小时&apos; + minutes + &apos;分&apos; + seconds + &apos;秒&apos;; } function domText(elem, text) { if (text == undefined) { if (elem.textContent) { return elem.textContent; } else if (elem.innerText) { return elem.innerText; } } else { if (elem.textContent) { elem.textContent = text; } else if (elem.innerText) { elem.innerText = text; } else { elem.innerHTML = text; } } } var target = document.getElementById(&apos;target&apos;); setInterval(function () { domText(target, getTimeString()); }, 1000) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;完成一个函数,接受数组作为参数,数组元素为整数或者数组,数组元素包含整数或数组,函数返回扁平化后的数组如：[1, [2, [ [3, 4], 5], 6]] =&gt; [1, 2, 3, 4, 5, 6] 123456789101112131415161718var data = [1, [2, [ [3, 4], 5], 6]];function flat(data, result) { var i, d, len; for (i = 0, len = data.length; i &lt; len; ++i) { d = data[i]; if (typeof d === 'number') { result.push(d); } else { flat(d, result); } }}var result = [];flat(data, result);console.log(result); 如何判断一个对象是否为数组如果浏览器支持 Array.isArray()可以直接判断否则需进行必要判断 123456789101112/** * 判断一个对象是否是数组，参数不是对象或者不是数组，返回false * * @param {Object} arg 需要测试是否为数组的对象 * @return {Boolean} 传入参数是数组返回true，否则返回false */function isArray(arg) { if (typeof arg === 'object') { return Object.prototype.toString.call(arg) === '[object Array]'; } return false;} 请评价以下事件监听器代码并给出改进意见123456789101112if (window.addEventListener) { var addListener = function (el, type, listener, useCapture) { el.addEventListener(type, listener, useCapture); };}else if (document.all) { addListener = function (el, type, listener) { el.attachEvent('on' + type, function () { listener.apply(el); }); };} 作用：浏览器功能检测实现跨浏览器 DOM 事件绑定 优点： 测试代码只运行一次，根据浏览器确定绑定方法 通过listener.apply(el)解决 IE 下监听器 this 与标准不一致的地方 在浏览器不支持的情况下提供简单的功能，在标准浏览器中提供捕获功能 缺点： document.all 作为 IE 检测不可靠，应该使用 if(el.attachEvent) addListener 在不同浏览器下 API 不一样 listener.apply使 this 与标准一致但监听器无法移除 未解决 IE 下 listener 参数 event。 target 问题 改进: 12345678910111213141516171819202122var addListener;if (window.addEventListener) { addListener = function (el, type, listener, useCapture) { el.addEventListener(type, listener, useCapture); return listener; };}else if (window.attachEvent) { addListener = function (el, type, listener) { // 标准化this，event，target var wrapper = function () { var event = window.event; event.target = event.srcElement; listener.call(el, event); }; el.attachEvent('on' + type, wrapper); return wrapper; // 返回wrapper。调用者可以保存，以后remove };}","link":"/jsw.github.io/2020/02/25/js%E7%BC%96%E7%A8%8B%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"【前端面试】经典面试题基础","text":"javascript基础面试题2 什么闭包,闭包有什么用闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量。闭包作用域链通常包括三个部分： 函数本身作用域。 闭包定义时的作用域。 全局作用域。 闭包常见用途： 创建特权方法用于访问控制 事件处理程序及回调 javascript 有哪些方法定义对象 对象字面量： var obj = {}; 构造函数： var obj = new Object(); Object.create(): var obj = Object.create(Object.prototype); 对象到字符串的转换步骤 如果对象有 toString()方法，javascript 调用它。如果返回一个原始值（primitive value 如：string number boolean）,将这个值转换为字符串作为结果 如果对象没有 toString()方法或者返回值不是原始值，javascript 寻找对象的 valueOf()方法，如果存在就调用它，返回结果是原始值则转为字符串作为结果 否则，javascript 不能从 toString()或者 valueOf()获得一个原始值，此时 throws a TypeError 对象到数字的转换步骤 如果对象有valueOf()方法并且返回元素值，javascript将返回值转换为数字作为结果 否则，如果对象有toString()并且返回原始值，javascript将返回结果转换为数字作为结果 否则，throws a TypeError &lt;,&gt;,&lt;=,&gt;=的比较规则所有比较运算符都支持任意类型，但是比较只支持数字和字符串，所以需要执行必要的转换然后进行比较，转换规则如下: 如果操作数是对象，转换为原始值：如果 valueOf 方法返回原始值，则使用这个值，否则使用 toString 方法的结果，如果转换失败则报错 经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的 16 位 unicode 值的大小） 否则，如果有一个操作数不是字符串，将两个操作数转换为数字进行比较 +运算符工作流程 如果有操作数是对象，转换为原始值 此时如果有一个操作数是字符串，其他的操作数都转换为字符串并执行连接 否则：所有操作数都转换为数字并执行加法 客户端存储 localStorage 和 sessionStorage localStorage 有效期为永久，sessionStorage 有效期为顶层窗口关闭前 同源文档可以读取并修改 localStorage 数据，sessionStorage 只允许同一个窗口下的文档访问，如通过 iframe 引入的同源文档。 Storage 对象通常被当做普通 javascript 对象使用：通过设置属性来存取字符串值，也可以通过setItem(key, value)设置，getItem(key)读取，removeItem(key)删除，clear()删除所有数据，length 表示已存储的数据项数目，key(index)返回对应索引的 key 1234567891011localStorage.setItem('x', 1); // storge x-&gt;1localStorage.getItem('x); // return value of x// 枚举所有存储的键值对for (var i = 0, len = localStorage.length; i &lt; len; ++i ) { var name = localStorage.key(i); var value = localStorage.getItem(name);}localStorage.removeItem('x'); // remove xlocalStorage.clear(); // remove all data sessionStorage,localStorage,cookie 区别 都会在浏览器端保存，有大小限制，同源限制 cookie 会在请求时发送到服务器，作为会话标识，服务器可修改 cookie；web storage 不会发送到服务器 cookie 有 path 概念，子路径可以访问父路径 cookie，父路径不能访问子路径 cookie 有效期：cookie 在设置的有效期内有效，默认为浏览器关闭；sessionStorage 在窗口关闭前有效，localStorage 长期有效，直到用户删除 共享：sessionStorage 不能共享，localStorage 在同源文档之间共享，cookie 在同源且符合 path 规则的文档之间共享 localStorage 的修改会促发其他文档窗口的 update 事件 cookie 有 secure 属性要求 HTTPS 传输 浏览器不能保存超过 300 个 cookie，单个服务器不能超过 20 个，每个 cookie 不能超过 4k。web storage 大小支持能达到 5M 评价一下三种方法实现继承的优缺点,并改进12345678910111213141516function Shape() {}function Rect() {}// 方法1Rect.prototype = new Shape();// 方法2Rect.prototype = Shape.prototype;// 方法3Rect.prototype = Object.create(Shape.prototype);Rect.prototype.area = function () { // do something}; 方法 1： 优点：正确设置原型链实现继承 优点：父类实例属性得到继承，原型链查找效率提高，也能为一些属性提供合理的默认值 缺点：父类实例属性为引用类型时，不恰当地修改会导致所有子类被修改 缺点：创建父类实例作为子类原型时，可能无法确定构造函数需要的合理参数，这样提供的参数继承给子类没有实际意义，当子类需要这些参数时应该在构造函数中进行初始化和设置 总结：继承应该是继承方法而不是属性，为子类设置父类实例属性应该是通过在子类构造函数中调用父类构造函数进行初始化 方法 2： 优点：正确设置原型链实现继承 缺点：父类构造函数原型与子类相同。修改子类原型添加方法会修改父类 方法 3： 优点：正确设置原型链且避免方法 1.2 中的缺点 缺点：ES5 方法需要注意兼容性 改进： 所有三种方法应该在子类构造函数中调用父类构造函数实现实例属性初始化 123function Rect() { Shape.call(this);} 用新创建的对象替代子类默认原型，设置Rect.prototype.constructor = Rect;保证一致性 第三种方法的 polyfill： 123456789function create(obj) { if (Object.create) { return Object.create(obj); } function f() {}; f.prototype = obj; return new f();}","link":"/jsw.github.io/2020/02/25/js%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%982/"},{"title":"js编程部分面试题2","text":"javascript 算法题 如何判断一个对象是否为函数1234567891011121314151617/** * 判断对象是否为函数，如果当前运行环境对可调用对象（如正则表达式） * 的typeof返回'function'，采用通用方法，否则采用优化方法 * * @param {Any} arg 需要检测是否是函数的对象 * @return {boolean} 如果参数是函数，返回true，否则false */function isFunction(arg) { if (arg) { if (typeof (/./) !== 'function') { return typeof arg === 'function'; } else { return Object.prototype.toString.call(arg) === '[object Function]'; } } // end if return false;} 编写一个函数接受 url 中 query string 为参数,返回解析后的 Object,query string 使用 application/x-www-form-urlencoded 编码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 解析query string转换为对象，一个key有多个值时生成数组 * * @param {String} query 需要解析的query字符串，开头可以是?， * 按照application/x-www-form-urlencoded编码 * @return {Object} 参数解析后的对象 */function parseQuery(query) { var result = {}; // 如果不是字符串返回空对象 if (typeof query !== 'string') { return result; } // 去掉字符串开头可能带的? if (query.charAt(0) === '?') { query = query.substring(1); } var pairs = query.split('&amp;'); var pair; var key, value; var i, len; for (i = 0, len = pairs.length; i &lt; len; ++i) { pair = pairs[i].split('='); // application/x-www-form-urlencoded编码会将' '转换为+ key = decodeURIComponent(pair[0]).replace(/\\+/g, ' '); value = decodeURIComponent(pair[1]).replace(/\\+/g, ' '); // 如果是新key，直接添加 if (!(key in result)) { result[key] = value; } // 如果key已经出现一次以上，直接向数组添加value else if (isArray(result[key])) { result[key].push(value); } // key第二次出现，将结果改为数组 else { var arr = [result[key]]; arr.push(value); result[key] = arr; } // end if-else } // end for return result;}function isArray(arg) { if (arg &amp;&amp; typeof arg === 'object') { return Object.prototype.toString.call(arg) === '[object Array]'; } return false;}/**console.log(parseQuery('sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8')); */ 解析一个完整的 url,返回 Object 包含域与 window.location 相同12345678910111213141516171819202122232425262728293031323334353637/** * 解析一个url并生成window.location对象中包含的域 * location: * { * href: '包含完整的url', * origin: '包含协议到pathname之前的内容', * protocol: 'url使用的协议，包含末尾的:', * username: '用户名', // 暂时不支持 * password: '密码', // 暂时不支持 * host: '完整主机名，包含:和端口', * hostname: '主机名，不包含端口' * port: '端口号', * pathname: '服务器上访问资源的路径/开头', * search: 'query string，?开头', * hash: '#开头的fragment identifier' * } * * @param {string} url 需要解析的url * @return {Object} 包含url信息的对象 */function parseUrl(url) { var result = {}; var keys = ['href', 'origin', 'protocol', 'host', 'hostname', 'port', 'pathname', 'search', 'hash']; var i, len; var regexp = /(([^:]+:)\\/\\/(([^:\\/\\?#]+)(:\\d+)?))(\\/[^?#]*)?(\\?[^#]*)?(#.*)?/; var match = regexp.exec(url); if (match) { for (i = keys.length - 1; i &gt;= 0; --i) { result[keys[i]] = match[i] ? match[i] : ''; } } return result;} 完成函数 getViewportSize 返回指定窗口的视口尺寸1234567891011121314151617181920212223242526272829/*** 查询指定窗口的视口尺寸，如果不指定窗口，查询当前窗口尺寸**/function getViewportSize(w) { w = w || window; // IE9及标准浏览器中可使用此标准方法 if ('innerHeight' in w) { return { width: w.innerWidth, height: w.innerHeight }; } var d = w.document; // IE 8及以下浏览器在标准模式下 if (document.compatMode === 'CSS1Compat') { return { width: d.documentElement.clientWidth, height: d.documentElement.clientHeight }; } // IE8及以下浏览器在怪癖模式下 return { width: d.body.clientWidth, height: d.body.clientHeight };} 完成函数 getScrollOffset 返回窗口滚动条偏移量/** * 获取指定window中滚动条的偏移量，如未指定则获取当前window * 滚动条偏移量 * * @param {window} w 需要获取滚动条偏移量的窗口 * @return {Object} obj.x为水平滚动条偏移量,obj.y为竖直滚动条偏移量 */ function getScrollOffset(w) { w = w || window; // 如果是标准浏览器 if (w.pageXOffset != null) { return { x: w.pageXOffset, y: w.pageYOffset }; } // 老版本IE，根据兼容性不同访问不同元素 var d = w.document; if (d.compatMode === &apos;CSS1Compat&apos;) { return { x: d.documentElement.scrollLeft, y: d.documentElement.scrollTop } } return { x: d.body.scrollLeft, y: d.body.scrollTop }; }现有一个字符串 richText,是一段富文本,需要显示在页面上.有个要求,需要给其中只包含一个 img 元素的 p 标签增加一个叫 pic 的 class.请编写代码实现.可以使用 jQuery 或 KISSY.function richText(text) { var div = document.createElement(&apos;div&apos;); div.innerHTML = text; var p = div.getElementsByTagName(&apos;p&apos;); var i, len; for (i = 0, len = p.length; i &lt; len; ++i) { if (p[i].getElementsByTagName(&apos;img&apos;).length === 1) { p[i].classList.add(&apos;pic&apos;); } } return div.innerHTML; }请实现一个 Event 类,继承自此类的对象都会拥有两个方法 on,off,once 和 triggerfunction Event() { if (!(this instanceof Event)) { return new Event(); } this._callbacks = {}; } Event.prototype.on = function (type, handler) { this_callbacks = this._callbacks || {}; this._callbacks[type] = this.callbacks[type] || []; this._callbacks[type].push(handler); return this; }; Event.prototype.off = function (type, handler) { var list = this._callbacks[type]; if (list) { for (var i = list.length; i &gt;= 0; --i) { if (list[i] === handler) { list.splice(i, 1); } } } return this; }; Event.prototype.trigger = function (type, data) { var list = this._callbacks[type]; if (list) { for (var i = 0, len = list.length; i &lt; len; ++i) { list[i].call(this, data); } } }; Event.prototype.once = function (type, handler) { var self = this; function wrapper() { handler.apply(self, arguments); self.off(type, wrapper); } this.on(type, wrapper); return this; };编写一个函数将列表子元素顺序反转1234567891011121314151617&lt;ul id=&quot;target&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var target = document.getElementById('target'); var i; var frag = document.createDocumentFragment(); for (i = target.children.length - 1; i &gt;= 0; --i) { frag.appendChild(target.children[i]); } target.appendChild(frag);&lt;/script&gt; 以下函数的作用是?空白区域应该填写什么123456789101112131415161718192021// define(function (window) { function fn(str) { this.str = str; } fn.prototype.format = function () { var arg = __1__; return this.str.replace(__2__, function (a, b) { return arg[b] || ''; }); }; window.fn = fn;})(window);// use(function () { var t = new fn('&lt;p&gt;&lt;a href=&quot;{0}&quot;&gt;{1}&lt;/a&gt;&lt;span&gt;{2}&lt;/span&gt;&lt;/p&gt;'); console.log(t.format('http://www.alibaba.com', 'Alibaba', 'Welcome'));})(); define 部分定义一个简单的模板类，使用{}作为转义标记，中间的数字表示替换目标，format 实参用来替换模板内标记横线处填： Array.prototype.slice.call(arguments, 0) /\\{\\s*(\\d+)\\s*\\}/g 编写一个函数实现 form 的序列化(即将一个表单中的键值序列化为可提交的字符串)&lt;form id=&quot;target&quot;&gt; &lt;select name=&quot;age&quot;&gt; &lt;option value=&quot;aaa&quot;&gt;aaa&lt;/option&gt; &lt;option value=&quot;bbb&quot; selected&gt;bbb&lt;/option&gt; &lt;/select&gt; &lt;select name=&quot;friends&quot; multiple&gt; &lt;option value=&quot;qiu&quot; selected&gt;qiu&lt;/option&gt; &lt;option value=&quot;de&quot;&gt;de&lt;/option&gt; &lt;option value=&quot;qing&quot; selected&gt;qing&lt;/option&gt; &lt;/select&gt; &lt;input name=&quot;name&quot; value=&quot;qiudeqing&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;11111&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;salery&quot; value=&quot;3333&quot;&gt; &lt;textarea name=&quot;description&quot;&gt;description&lt;/textarea&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; checked value=&quot;football&quot;&gt;Football &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;basketball&quot;&gt;Basketball &lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked value=&quot;Female&quot;&gt;Female &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;Male&quot;&gt;Male &lt;/form&gt; &lt;script&gt; /** * 将一个表单元素序列化为可提交的字符串 * * @param {FormElement} form 需要序列化的表单元素 * @return {string} 表单序列化后的字符串 */ function serializeForm(form) { if (!form || form.nodeName.toUpperCase() !== &apos;FORM&apos;) { return; } var result = []; var i, len; var field, fieldName, fieldType; for (i = 0, len = form.length; i &lt; len; ++i) { field = form.elements[i]; fieldName = field.name; fieldType = field.type; if (field.disabled || !fieldName) { continue; } // enf if switch (fieldType) { case &apos;text&apos;: case &apos;password&apos;: case &apos;hidden&apos;: case &apos;textarea&apos;: result.push(encodeURIComponent(fieldName) + &apos;=&apos; + encodeURIComponent(field.value)); break; case &apos;radio&apos;: case &apos;checkbox&apos;: if (field.checked) { result.push(encodeURIComponent(fieldName) + &apos;=&apos; + encodeURIComponent(field.value)); } break; case &apos;select-one&apos;: case &apos;select-multiple&apos;: for (var j = 0, jLen = field.options.length; j &lt; jLen; ++j) { if (field.options[j].selected) { result.push(encodeURIComponent(fieldName) + &apos;=&apos; + encodeURIComponent(field.options[j].value || field.options[j].text)); } } // end for break; case &apos;file&apos;: case &apos;submit&apos;: break; // 是否处理？ default: break; } // end switch } // end for return result.join(&apos;&amp;&apos;); } var form = document.getElementById(&apos;target&apos;); console.log(serializeForm(form)); &lt;/script&gt;使用原生 javascript 给下面列表中的 li 节点绑定点击事件,点击时创建一个 Object 对象,兼容 IE 和标准浏览器12345678910111213&lt;ul id=&quot;nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;http://11111&quot;&gt;111&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://2222&quot;&gt;222&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://333&quot;&gt;333&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://444&quot;&gt;444&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;Object:{ &quot;index&quot;: 1, &quot;name&quot;: &quot;111&quot;, &quot;link&quot;: &quot;http://1111&quot;} script: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778var EventUtil = { getEvent: function (event) { return event || window.event; }, getTarget: function (event) { return event.target || event.srcElement; }, // 返回注册成功的监听器，IE中需要使用返回值来移除监听器 on: function (elem, type, handler) { if (elem.addEventListener) { elem.addEventListener(type, handler, false); return handler; } else if (elem.attachEvent) { function wrapper(event) { return handler.call(elem, event); }; elem.attachEvent('on' + type, wrapper); return wrapper; } }, off: function (elem, type, handler) { if (elem.removeEventListener) { elem.removeEventListener(type, handler, false); } else if (elem.detachEvent) { elem.detachEvent('on' + type, handler); } }, preventDefault: function (event) { if (event.preventDefault) { event.preventDefault(); } else if ('returnValue' in event) { event.returnValue = false; } }, stopPropagation: function (event) { if (event.stopPropagation) { event.stopPropagation(); } else if ('cancelBubble' in event) { event.cancelBubble = true; } }};var DOMUtil = { text: function (elem) { if ('textContent' in elem) { return elem.textContent; } else if ('innerText' in elem) { return elem.innerText; } }, prop: function (elem, propName) { return elem.getAttribute(propName); }};var nav = document.getElementById('nav');EventUtil.on(nav, 'click', function (event) { var event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); var children = this.children; var i, len; var anchor; var obj = {}; for (i = 0, len = children.length; i &lt; len; ++i) { if (children[i] === target) { obj.index = i + 1; anchor = target.getElementsByTagName('a')[0]; obj.name = DOMUtil.text(anchor); obj.link = DOMUtil.prop(anchor, 'href'); } } alert('index: ' + obj.index + ' name: ' + obj.name + ' link: ' + obj.link);}); 有一个大数组,var a = [‘1’, ‘2’, ‘3’, …];a 的长度是 100,内容填充随机整数的字符串.请先构造此数组 a,然后设计一个算法将其内容去重123456789101112131415161718192021222324252627282930313233343536373839404142434445/*** 数组去重**/function normalize(arr) { if (arr &amp;&amp; Array.isArray(arr)) { var i, len, map = {}; for (i = arr.length; i &gt;= 0; --i) { if (arr[i] in map) { arr.splice(i, 1); } else { map[arr[i]] = true; } } } return arr;}/*** 用100个随机整数对应的字符串填充数组。**/function fillArray(arr, start, end) { start = start == undefined ? 1 : start; end = end == undefined ? 100 : end; if (end &lt;= start) { end = start + 100; } var width = end - start; var i; for (i = 100; i &gt;= 1; --i) { arr.push('' + (Math.floor(Math.random() * width) + start)); } return arr;}var input = [];fillArray(input, 1, 100);input.sort(function (a, b) { return a - b;});console.log(input);normalize(input);console.log(input);","link":"/jsw.github.io/2020/02/25/js%E7%BC%96%E7%A8%8B%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%982/"}],"tags":[{"name":"面试题基础","slug":"面试题基础","link":"/jsw.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9F%BA%E7%A1%80/"},{"name":"面试题算法","slug":"面试题算法","link":"/jsw.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"面试","slug":"面试","link":"/jsw.github.io/categories/%E9%9D%A2%E8%AF%95/"}]}