{"pages":[],"posts":[{"title":"【前端面试】经典面试题基础","text":"javascript基础面试题 说说写JavaScript的基本规范？ 不要在同一行声明多个变量使用 ===或!==来比较true/false或者数值switch必须带有default分支函数应该有返回值语句结束加分号命名要有意义，使用驼峰命名法 javascript的typeof返回哪些数据类型. string,boolean,number,undefined,function,object,es6新增symbol 栈和堆的区别？ 栈（stack）：由编译器自动分配释放，存放函数的参数值，局部变量等；堆（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统释放。 null，undefined的区别？ null表示一个对象被定义了，但存放了空指针，转换为数值时为0。undefined表示声明的变量未初始化，转换为数值时为NAN。typeof(null) – object;typeof(undefined) – undefined split() join() 的区别 前者是将字符串切割成数组的形式，后者是将数组转换成字符串 [“1”, “2”, “3”].map(parseInt) 答案是多少？ 答案：[1,NaN,NaN] 是不是很奇怪, 1 为什么能被转换成1 其他2 ，3 会被转换成NAN12345678解析： Array.prototype.map() array.map(callback[, thisArg]) callback函数的执行规则 参数：自动传入三个参数 currentValue（当前被传递的元素）； index（当前被传递的元素的索引）； array（调用map方法的数组） javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？ 除了正常模式运行外，ECMAscript添加了第二种运行模式：“严格模式”。作用： 1) 消除js不合理，不严谨地方，减少怪异行为2) 消除代码运行的不安全之处，3) 提高编译器的效率，增加运行速度4) 为未来的js新版本做铺垫。 如何判断一个对象是否属于某个类？ 使用instanceof 即if(a instanceof Person){alert(‘yes’);} new操作符具体干了什么呢? 1) 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。2) 属性和方法被加入到 this 引用的对象中。3) 新创建的对象由 this 所引用，并且最后隐式的返回 this 。","link":"/jsw.github.io/2019/03/12/js%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"【前端面试】经典面试题基础","text":"javascript基础面试题2 什么闭包,闭包有什么用闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量。闭包作用域链通常包括三个部分： 函数本身作用域。 闭包定义时的作用域。 全局作用域。 闭包常见用途： 创建特权方法用于访问控制 事件处理程序及回调 javascript 有哪些方法定义对象 对象字面量： var obj = {}; 构造函数： var obj = new Object(); Object.create(): var obj = Object.create(Object.prototype); 对象到字符串的转换步骤 如果对象有 toString()方法，javascript 调用它。如果返回一个原始值（primitive value 如：string number boolean）,将这个值转换为字符串作为结果 如果对象没有 toString()方法或者返回值不是原始值，javascript 寻找对象的 valueOf()方法，如果存在就调用它，返回结果是原始值则转为字符串作为结果 否则，javascript 不能从 toString()或者 valueOf()获得一个原始值，此时 throws a TypeError 对象到数字的转换步骤 如果对象有valueOf()方法并且返回元素值，javascript将返回值转换为数字作为结果 否则，如果对象有toString()并且返回原始值，javascript将返回结果转换为数字作为结果 否则，throws a TypeError &lt;,&gt;,&lt;=,&gt;=的比较规则所有比较运算符都支持任意类型，但是比较只支持数字和字符串，所以需要执行必要的转换然后进行比较，转换规则如下: 如果操作数是对象，转换为原始值：如果 valueOf 方法返回原始值，则使用这个值，否则使用 toString 方法的结果，如果转换失败则报错 经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的 16 位 unicode 值的大小） 否则，如果有一个操作数不是字符串，将两个操作数转换为数字进行比较 +运算符工作流程 如果有操作数是对象，转换为原始值 此时如果有一个操作数是字符串，其他的操作数都转换为字符串并执行连接 否则：所有操作数都转换为数字并执行加法 客户端存储 localStorage 和 sessionStorage localStorage 有效期为永久，sessionStorage 有效期为顶层窗口关闭前 同源文档可以读取并修改 localStorage 数据，sessionStorage 只允许同一个窗口下的文档访问，如通过 iframe 引入的同源文档。 Storage 对象通常被当做普通 javascript 对象使用：通过设置属性来存取字符串值，也可以通过setItem(key, value)设置，getItem(key)读取，removeItem(key)删除，clear()删除所有数据，length 表示已存储的数据项数目，key(index)返回对应索引的 key 1234567891011localStorage.setItem('x', 1); // storge x-&gt;1localStorage.getItem('x); // return value of x// 枚举所有存储的键值对for (var i = 0, len = localStorage.length; i &lt; len; ++i ) { var name = localStorage.key(i); var value = localStorage.getItem(name);}localStorage.removeItem('x'); // remove xlocalStorage.clear(); // remove all data sessionStorage,localStorage,cookie 区别 都会在浏览器端保存，有大小限制，同源限制 cookie 会在请求时发送到服务器，作为会话标识，服务器可修改 cookie；web storage 不会发送到服务器 cookie 有 path 概念，子路径可以访问父路径 cookie，父路径不能访问子路径 cookie 有效期：cookie 在设置的有效期内有效，默认为浏览器关闭；sessionStorage 在窗口关闭前有效，localStorage 长期有效，直到用户删除 共享：sessionStorage 不能共享，localStorage 在同源文档之间共享，cookie 在同源且符合 path 规则的文档之间共享 localStorage 的修改会促发其他文档窗口的 update 事件 cookie 有 secure 属性要求 HTTPS 传输 浏览器不能保存超过 300 个 cookie，单个服务器不能超过 20 个，每个 cookie 不能超过 4k。web storage 大小支持能达到 5M 评价一下三种方法实现继承的优缺点,并改进12345678910111213141516function Shape() {}function Rect() {}// 方法1Rect.prototype = new Shape();// 方法2Rect.prototype = Shape.prototype;// 方法3Rect.prototype = Object.create(Shape.prototype);Rect.prototype.area = function () { // do something}; 方法 1： 优点：正确设置原型链实现继承 优点：父类实例属性得到继承，原型链查找效率提高，也能为一些属性提供合理的默认值 缺点：父类实例属性为引用类型时，不恰当地修改会导致所有子类被修改 缺点：创建父类实例作为子类原型时，可能无法确定构造函数需要的合理参数，这样提供的参数继承给子类没有实际意义，当子类需要这些参数时应该在构造函数中进行初始化和设置 总结：继承应该是继承方法而不是属性，为子类设置父类实例属性应该是通过在子类构造函数中调用父类构造函数进行初始化 方法 2： 优点：正确设置原型链实现继承 缺点：父类构造函数原型与子类相同。修改子类原型添加方法会修改父类 方法 3： 优点：正确设置原型链且避免方法 1.2 中的缺点 缺点：ES5 方法需要注意兼容性 改进： 所有三种方法应该在子类构造函数中调用父类构造函数实现实例属性初始化 123function Rect() { Shape.call(this);} 用新创建的对象替代子类默认原型，设置Rect.prototype.constructor = Rect;保证一致性 第三种方法的 polyfill： 123456789function create(obj) { if (Object.create) { return Object.create(obj); } function f() {}; f.prototype = obj; return new f();}","link":"/jsw.github.io/2020/02/25/js%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%982/"},{"title":"js编程部分面试题","text":"","link":"/jsw.github.io/2020/02/25/js%E7%BC%96%E7%A8%8B%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试题基础","slug":"面试题基础","link":"/jsw.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9F%BA%E7%A1%80/"}],"categories":[{"name":"面试","slug":"面试","link":"/jsw.github.io/categories/%E9%9D%A2%E8%AF%95/"}]}